var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key2, value) => {
  __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
  return value;
};
import { inject, reactive, watch, provide, computed, defineComponent, createVNode, mergeProps, h as h$1, ref, onMounted, onBeforeUnmount, getCurrentInstance, nextTick, Transition, createApp, createTextVNode, withDirectives, vShow, isVNode, Fragment, renderSlot, toRefs, Teleport, resolveDirective, customRef, onBeforeMount, toRef, shallowRef, vModelText, unref, watchEffect, markRaw, onUpdated, render as render$1, onUnmounted, toRaw, withModifiers, TransitionGroup } from "vue";
var reset = "";
var alert = "";
var affix = "";
var backtop = "";
var badge = "";
var breadcrumb = "";
var button = "";
var card = "";
var checkbox = "";
var collapse = "";
var collapseTransition = "";
var dialog = "";
var exception = "";
var fixedNavbar = "";
var input = "";
var link = "";
var dropdown = "";
var loading = "";
var modal = "";
var progress = "";
var radio = "";
var rate = "";
var star$1 = "";
var swiper = "";
var select = "";
var sideslider = "";
var switcher = "";
var table = "";
var tag = "";
var form = "";
var steps = "";
var message = "";
var notify = "";
var tree = "";
var slider = "";
var menu = "";
var navigation = "";
var datePicker = "";
var divider = "";
var tab = "";
var process = "";
var virtualRender$1 = "";
var transfer$1 = "";
var pagination = "";
var timeline = "";
var codeDiff = "";
var resizeLayout = "";
var upload$1 = "";
var tagInput = "";
var container = "";
var cascader = "";
var colorPicker = "";
var timePicker = "";
var searchSelect = "";
var configProvider = "";
var popConfirm = "";
function scrollTop(el, from = 0, to, duration = 500, endCallback) {
  const difference = Math.abs(from - to);
  const step = Math.ceil(difference / duration * 50);
  function scroll(start2, end2, step2) {
    if (start2 === end2) {
      endCallback == null ? void 0 : endCallback();
      return;
    }
    let d2 = start2 + step2 > end2 ? end2 : start2 + step2;
    if (start2 > end2) {
      d2 = start2 - step2 < end2 ? end2 : start2 - step2;
    }
    if (el === window) {
      window.scrollTo(d2, d2);
    } else {
      el.scrollTop = d2;
    }
    window.requestAnimationFrame(() => scroll(d2, end2, step2));
  }
  scroll(from, to, step);
}
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject$1(value) {
  return value !== null && /^\[object (Object|Module)\]/.test(Object.prototype.toString.call(value));
}
function clone(source) {
  if (isArray(source)) {
    return source.map(clone);
  }
  if (isObject$1(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k2 = 0;
    for (; k2 < klen; ++k2) {
      target[keys[k2]] = clone(source[keys[k2]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key2) {
  return ["__proto__", "prototype", "constructor"].indexOf(key2) === -1;
}
function mergerFn(key2, target, source, options) {
  if (!isValidKey(key2)) {
    return;
  }
  const tval = target[key2];
  const sval = source[key2];
  if (isObject$1(tval) && isObject$1(sval)) {
    merge$1(tval, sval, options);
  } else {
    target[key2] = clone(sval);
  }
}
function merge$1(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject$1(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || mergerFn;
  for (let i2 = 0; i2 < ilen; ++i2) {
    source = sources[i2];
    if (!isObject$1(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k2 = 0, klen = keys.length; k2 < klen; ++k2) {
      merger(keys[k2], target, source, options);
    }
  }
  return target;
}
function isElement$4(obj) {
  try {
    return obj instanceof HTMLElement;
  } catch (e) {
    return typeof obj === "object" && obj.nodeType === 1 && typeof obj.style === "object" && typeof obj.ownerDocument === "object";
  }
}
function hasOverflowEllipsis(element) {
  return element.offsetWidth < element.scrollWidth || element.offsetHeight < element.scrollHeight;
}
const formKey = Symbol("form");
const formItemKey = Symbol("formItem");
const useForm = () => inject(formKey);
const useFormItem = () => inject(formItemKey, void 0);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace2 = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset2 = array.length;
      while (++index2 < length) {
        array[offset2 + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key2, collection2) {
        if (predicate(value, key2, collection2)) {
          result = key2;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key2) {
      return function(object) {
        return object == null ? undefined$1 : object[key2];
      };
    }
    function basePropertyOf(object) {
      return function(key2) {
        return object == null ? undefined$1 : object[key2];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props2) {
      return arrayMap(props2, function(key2) {
        return [key2, object[key2]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props2) {
      return arrayMap(props2, function(key2) {
        return object[key2];
      });
    }
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key2) {
      return object == null ? undefined$1 : object[key2];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data2, result = [];
      while (!(data2 = iterator.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key2) {
        result[++index2] = [key2, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace2.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length = end2 - start2, index2 = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed2 = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key2) {
        var result2 = this.has(key2) && delete this.__data__[key2];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key2) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result2 = data2[key2];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty.call(data2, key2) ? data2[key2] : undefined$1;
      }
      function hashHas(key2) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key2] !== undefined$1 : hasOwnProperty.call(data2, key2);
      }
      function hashSet(key2, value) {
        var data2 = this.__data__;
        this.size += this.has(key2) ? 0 : 1;
        data2[key2] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key2) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key2) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        return index2 < 0 ? undefined$1 : data2[index2][1];
      }
      function listCacheHas(key2) {
        return assocIndexOf(this.__data__, key2) > -1;
      }
      function listCacheSet(key2, value) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        if (index2 < 0) {
          ++this.size;
          data2.push([key2, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key2) {
        var result2 = getMapData(this, key2)["delete"](key2);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key2) {
        return getMapData(this, key2).get(key2);
      }
      function mapCacheHas(key2) {
        return getMapData(this, key2).has(key2);
      }
      function mapCacheSet(key2, value) {
        var data2 = getMapData(this, key2), size2 = data2.size;
        data2.set(key2, value);
        this.size += data2.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key2) {
        var data2 = this.__data__, result2 = data2["delete"](key2);
        this.size = data2.size;
        return result2;
      }
      function stackGet(key2) {
        return this.__data__.get(key2);
      }
      function stackHas(key2) {
        return this.__data__.has(key2);
      }
      function stackSet(key2, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key2, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key2, value);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key2 in value) {
          if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n2) {
        return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key2, value) {
        if (value !== undefined$1 && !eq(object[key2], value) || value === undefined$1 && !(key2 in object)) {
          baseAssignValue(object, key2, value);
        }
      }
      function assignValue(object, key2, value) {
        var objValue = object[key2];
        if (!(hasOwnProperty.call(object, key2) && eq(objValue, value)) || value === undefined$1 && !(key2 in object)) {
          baseAssignValue(object, key2, value);
        }
      }
      function assocIndexOf(array, key2) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key2)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key2, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key2, value) {
        if (key2 == "__proto__" && defineProperty) {
          defineProperty(object, key2, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key2] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key2, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key2, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag2 = getTag(value), isFunc = tag2 == funcTag || tag2 == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag2 == objectTag || tag2 == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag2]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag2, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key3) {
            result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props2 = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props2 || value, function(subValue, key3) {
          if (props2) {
            key3 = subValue;
            subValue = value[key3];
          }
          assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props2 = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props2);
        };
      }
      function baseConformsTo(object, source, props2) {
        var length = props2.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key2 = props2[length], predicate = source[key2], value = object[key2];
          if (value === undefined$1 && !(key2 in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed2, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start2, end2) {
        var length = array.length;
        start2 = toInteger2(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 === undefined$1 || end2 > length ? length : toInteger2(end2);
        if (end2 < 0) {
          end2 += length;
        }
        end2 = start2 > end2 ? 0 : toLength(end2);
        while (start2 < end2) {
          array[start2++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props2) {
        return arrayFilter(props2, function(key2) {
          return isFunction(object[key2]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key2) {
        return object != null && hasOwnProperty.call(object, key2);
      }
      function baseHasIn(object, key2) {
        return object != null && key2 in Object2(object);
      }
      function baseInRange(number, start2, end2) {
        return number >= nativeMin(start2, end2) && number < nativeMax(start2, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key2, object2) {
          setter(accumulator, iteratee2(value), key2, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data2 = matchData[index2];
          var key2 = data2[0], objValue = object[key2], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$1 && !(key2 in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key2, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key2 in Object2(object)) {
          if (hasOwnProperty.call(object, key2) && key2 != "constructor") {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key2 in object) {
          if (!(key2 == "constructor" && (isProto || !hasOwnProperty.call(object, key2)))) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key2, collection2) {
          result2[++index2] = iteratee2(value, key2, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key2) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key2, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key2, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key2, newValue);
      }
      function baseNth(array, n2) {
        var length = array.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array[n2] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key2, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end2, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string, n2) {
        var result2 = "";
        if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string += string;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n2, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key2 = toKey(path[index2]), newValue = value;
          if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key2];
            newValue = customizer ? customizer(objValue, key2, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key2, newValue);
          nested = nested[key2];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start2, end2) {
        var index2 = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 > length ? length : end2;
        if (end2 < 0) {
          end2 += length;
        }
        length = start2 > end2 ? 0 : end2 - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed2, seen)) {
            var seen = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes2(seen, computed2, comparator)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props2, values2, assignFunc) {
        var index2 = -1, length = props2.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props2[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start2, end2) {
        var length = array.length;
        end2 = end2 === undefined$1 ? length : end2;
        return !start2 && end2 >= length ? array : baseSlice(array, start2, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order2 = orders[index2];
            return result2 * (order2 == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props2, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props2.length;
        while (++index2 < length) {
          var key2 = props2[index2];
          var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key2];
          }
          if (isNew) {
            baseAssignValue(object, key2, newValue);
          } else {
            assignValue(object, key2, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props2 = keysFunc(object), length = props2.length;
          while (length--) {
            var key2 = props2[fromRight ? length : ++index2];
            if (iteratee2(iterable[key2], key2, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn2, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key2) {
              return iteratee2(iterable[key2], key2, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end2, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
            end2 = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end2 === undefined$1) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite(step);
          return baseRange(start2, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag2 = getTag(object);
          if (tag2 == mapTag) {
            return mapToArray(object);
          }
          if (tag2 == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger2(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data2 = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key2, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key2]) && !hasOwnProperty.call(object, key2)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key2, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack) {
        switch (tag2) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key2 = objProps[index2];
          if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key2 = objProps[index2];
          var objValue = object[key2], othValue = other[key2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key2 == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data2 = array[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key2) {
        var data2 = map2.__data__;
        return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key2 = result2[length], value = object[key2];
          result2[length] = [key2, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key2) {
        var value = getValue(object, key2);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag2;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start2, end2, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data2 = transforms[index2], size2 = data2.size;
          switch (data2.type) {
            case "drop":
              start2 += size2;
              break;
            case "dropRight":
              end2 -= size2;
              break;
            case "take":
              end2 = nativeMin(end2, start2 + size2);
              break;
            case "takeRight":
              start2 = nativeMax(start2, end2 - size2);
              break;
          }
        }
        return { "start": start2, "end": end2 };
      }
      function getWrapDetails(source) {
        var match2 = source.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key2 = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key2))) {
            break;
          }
          object = object[key2];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key2, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag2, isDeep) {
        var Ctor = object.constructor;
        switch (tag2) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key2, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key2] === srcValue && (srcValue !== undefined$1 || key2 in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key2) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key2;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data2, source) {
        var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
        }
        if (data2[9] == null) {
          data2[9] = source[9];
        }
        data2[0] = source[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key2 in Object2(object)) {
            result2.push(key2);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start2, transform2) {
        start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key2) {
        if (key2 === "constructor" && typeof object[key2] === "function") {
          return;
        }
        if (key2 == "__proto__") {
          return;
        }
        return object[key2];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference2, bitmask) {
        var source = reference2 + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match2, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger2(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size2);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        n2 = length - n2;
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start2, end2) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
          start2 = 0;
          end2 = length;
        }
        return baseFill(array, value, start2, end2);
      }
      function findIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger2(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join3(array, separator2) {
        return array == null ? "" : nativeJoin.call(array, separator2);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger2(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n2) {
        return array && array.length ? baseNth(array, toInteger2(n2)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start2, end2) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end2 && typeof end2 != "number" && isIterateeCall(array, start2, end2)) {
          start2 = 0;
          end2 = length;
        } else {
          start2 = start2 == null ? 0 : toInteger2(start2);
          end2 = end2 === undefined$1 ? length : toInteger2(end2);
        }
        return baseSlice(array, start2, end2);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length && eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n2, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        n2 = length - n2;
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done2 = this.__index__ >= this.__values__.length, value = done2 ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done2, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key2) {
        if (hasOwnProperty.call(result2, key2)) {
          ++result2[key2];
        } else {
          baseAssignValue(result2, key2, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex2);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key2) {
        if (hasOwnProperty.call(result2, key2)) {
          result2[key2].push(value);
        } else {
          baseAssignValue(result2, key2, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key2) {
        baseAssignValue(result2, key2, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key2) {
        result2[key2 ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag2 = getTag(collection);
        if (tag2 == mapTag || tag2 == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$1 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key2, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key2, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key2)) {
            return cache.get(key2);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key2, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger2(start2);
        return baseRest(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax(toInteger2(start2), 0);
        return baseRest(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag2 = getTag(value);
        if (tag2 == mapTag || tag2 == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key2 in value) {
          if (hasOwnProperty.call(value, key2)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag2 = baseGetTag(value);
        return tag2 == errorTag || tag2 == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag2 = baseGetTag(value);
        return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag2 = getTag(value), func = tag2 == mapTag ? mapToArray : tag2 == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key2 in source) {
          if (hasOwnProperty.call(source, key2)) {
            assignValue(object, key2, source[key2]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props2 = keysIn(source);
          var propsIndex = -1;
          var propsLength = props2.length;
          while (++propsIndex < propsLength) {
            var key2 = props2[propsIndex];
            var value = object[key2];
            if (value === undefined$1 || eq(value, objectProto[key2]) && !hasOwnProperty.call(object, key2)) {
              object[key2] = source[key2];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key2;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key2) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key2);
        } else {
          result2[value] = [key2];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key2, object2) {
          baseAssignValue(result2, iteratee2(value, key2, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key2, object2) {
          baseAssignValue(result2, key2, iteratee2(value, key2, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props2 = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props2, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start2, end2) {
        start2 = toFinite(start2);
        if (end2 === undefined$1) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        number = toNumber(number);
        return baseInRange(number, start2, end2);
      }
      function random2(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word2, index2) {
        word2 = word2.toLowerCase();
        return result2 + (index2 ? capitalize2(word2) : word2);
      });
      function capitalize2(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger2(position), 0, length);
        var end2 = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end2) == target;
      }
      function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? "-" : "") + word2.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? " " : "") + word2.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad2(string, length, chars) {
        string = toString(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n2, guard) {
        if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        return baseRepeat(toString(string), n2);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? "_" : "") + word2.toLowerCase();
      });
      function split(string, separator2, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator2, limit)) {
          separator2 = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator2 == "string" || separator2 != null && !isRegExp(separator2))) {
          separator2 = baseToString(separator2);
          if (!separator2 && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator2, limit);
      }
      var startCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word2);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template2(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset2 + match2.length;
          return match2;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end2).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end2).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator2 = "separator" in options ? options.separator : separator2;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end2 = length - stringSize(omission);
        if (end2 < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
        if (separator2 === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end2 += result2.length - end2;
        }
        if (isRegExp(separator2)) {
          if (string.slice(end2).search(separator2)) {
            var match2, substring = result2;
            if (!separator2.global) {
              separator2 = RegExp2(separator2.source, toString(reFlags.exec(separator2)) + "g");
            }
            separator2.lastIndex = 0;
            while (match2 = separator2.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string.indexOf(baseToString(separator2), end2) != end2) {
          var index2 = result2.lastIndexOf(separator2);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word2, index2) {
        return result2 + (index2 ? " " : "") + word2.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key2) {
          key2 = toKey(key2);
          baseAssignValue(object, key2, bind(object[key2], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props2 = keys(source), methodNames = baseFunctions(source, props2);
        if (options == null && !(isObject2(source) && (methodNames.length || !props2.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n2) {
        n2 = toInteger2(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger2(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n2) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min2(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex2;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join3;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad2;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random2;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template2;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger2;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger2(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end2) {
        start2 = toInteger2(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end2 !== undefined$1) {
          end2 = toInteger2(end2);
          result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key2 = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key2)) {
            realNames[key2] = [];
          }
          realNames[key2].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var _$1 = lodash.exports;
const lowerStr = "abcdefghijklmnopqrstuvwxyz0123456789";
const random = (n2, str = lowerStr) => {
  let result = "";
  for (let i2 = 0; i2 < n2; i2++) {
    result += str[parseInt((Math.random() * str.length).toString(), 10)];
  }
  return result;
};
const observerResize$1 = (root, callbackFn, delay = 60, immediate = false) => {
  const callFn = lodash.exports.throttle(() => {
    if (typeof callbackFn === "function") {
      callbackFn();
    }
  }, delay);
  const resizeObserver = new ResizeObserver(() => {
    callFn();
  });
  if (immediate) {
    if (typeof callbackFn === "function") {
      callbackFn();
    }
  }
  return {
    start: () => {
      resizeObserver.observe(root);
    },
    stop: () => {
      resizeObserver.disconnect();
      resizeObserver.unobserve(root);
    }
  };
};
const capitalize = (str) => str[0].toUpperCase() + str.slice(1);
function checkOverflow(el) {
  if (!el)
    return false;
  const createDom = (el2, css) => {
    const dom = document.createElement("div");
    const width = parseFloat(css.width) ? `${Math.ceil(parseFloat(css.width))}px` : css.width;
    dom.style.cssText = `
      width: ${width};
      line-height: ${css["line-height"]};
      font-size: ${css["font-size"]};
      word-break: ${css["word-break"]};
      padding: ${css.padding};
    `;
    dom.textContent = el2.textContent;
    return dom;
  };
  let isOverflow = false;
  try {
    const css = window.getComputedStyle(el, null);
    const lineClamp = css.webkitLineClamp;
    if (lineClamp !== "none") {
      const targetHeight = parseFloat(css.height);
      const dom = createDom(el, css);
      document.body.appendChild(dom);
      const domHeight = window.getComputedStyle(dom, null).height;
      document.body.removeChild(dom);
      isOverflow = targetHeight < parseFloat(domHeight);
    } else {
      isOverflow = el.clientWidth < el.scrollWidth || el.clientHeight < el.scrollHeight;
    }
  } catch (e) {
    console.warn("There is an error when check element overflow state: ", e);
  }
  return isOverflow;
}
const BKLAYERD_INDEX_EFAULT_VALUE = {
  ["bottom"]: 0,
  ["content"]: 1,
  ["navi"]: 100,
  ["fullScreen"]: 1e3,
  ["modal"]: 3e3,
  ["plugins"]: 8e3,
  ["message"]: 1e4,
  ["popper"]: 99999
};
class BKZIndexManager {
  constructor() {
    this.storageLayerIndexValue = {};
    this.copyDefaultValue();
  }
  getNextIndex(type) {
    if (Object.prototype.hasOwnProperty.call(this.storageLayerIndexValue, type)) {
      this.storageLayerIndexValue[type] = this.storageLayerIndexValue[type] + 1;
      return this.storageLayerIndexValue[type];
    }
    this.storageLayerIndexValue["modal"] = this.storageLayerIndexValue["modal"] + 1;
    return this.storageLayerIndexValue["modal"];
  }
  getModalNextIndex() {
    return this.getNextIndex("modal");
  }
  getMessageNextIndex() {
    return this.getNextIndex("message");
  }
  getFullScreenNextIndex() {
    return this.getNextIndex("fullScreen");
  }
  getNaviNextIndex() {
    return this.getNextIndex("navi");
  }
  getPopperIndex() {
    return BKLAYERD_INDEX_EFAULT_VALUE.popper;
  }
  setDefaultZIndex(config) {
    Object.keys(config || {}).forEach((key2) => {
      if (Object.prototype.hasOwnProperty.call(this.storageLayerIndexValue.__proto__, key2)) {
        Object.assign(this.storageLayerIndexValue.__proto__, { [key2]: config[key2] });
      }
    });
    this.copyDefaultValue();
  }
  resetZIndex(config) {
    Object.keys(config || {}).forEach((key2) => {
      if (Object.prototype.hasOwnProperty.call(this.storageLayerIndexValue, key2)) {
        Object.assign(this.storageLayerIndexValue, { [key2]: config[key2] });
      }
    });
  }
  copyDefaultValue() {
    const properties = Object.keys(BKLAYERD_INDEX_EFAULT_VALUE).reduce((props2, key2) => Object.assign(props2, {
      [key2]: {
        value: BKLAYERD_INDEX_EFAULT_VALUE[key2],
        writable: true,
        configurable: true
      }
    }), {});
    this.storageLayerIndexValue = Object.create(BKLAYERD_INDEX_EFAULT_VALUE, properties);
  }
}
const bkZIndexManager = new BKZIndexManager();
`__bk_mask_${random(16)}`;
class MaskQueueMaker {
  constructor() {
    this.timer = null;
    this.store = [];
    this.maskMap = /* @__PURE__ */ new WeakMap();
  }
  appendMaker(fn2) {
    this.store.push(fn2);
    this.executeMaker();
  }
  pushMaskStyle(parentNode, style2) {
    const value = this.getMaskMap(parentNode);
    if (!(value == null ? void 0 : value.styles)) {
      this.setMaskMap(parentNode, __spreadValues({ styles: [style2] }, value || {}));
    } else {
      value.styles.push(style2);
    }
  }
  getMaskStyles(parentNode) {
    var _a;
    return ((_a = this.getMaskMap(parentNode)) == null ? void 0 : _a.styles) || [];
  }
  setMaskId(parentNode, id) {
    const value = this.getMaskMap(parentNode);
    if (!value) {
      this.setMaskMap(parentNode, __spreadValues({ id }, value || {}));
    } else {
      Object.assign(value, { id });
      this.setMaskMap(parentNode, value);
    }
  }
  getMaskId(parentNode) {
    var _a;
    return (_a = this.getMaskMap(parentNode)) == null ? void 0 : _a.id;
  }
  setMaskMap(key2, value) {
    this.maskMap.set(key2, value);
  }
  getMaskMap(key2) {
    return this.maskMap.get(key2);
  }
  executeMaker() {
    this.timer && cancelAnimationFrame(this.timer);
    this.timer = requestAnimationFrame(() => {
      const fn2 = this.store.pop();
      if (typeof fn2 === "function") {
        Reflect.apply(fn2, this, []);
        this.executeMaker();
      }
    });
  }
}
const bkMaskMaker = new MaskQueueMaker();
class BkMaskManager {
  constructor(config) {
    this.multiInstance = false;
    this.uniqueMaskAttrTag = "";
    this.parentNode = document.body;
    this.activeInstance = void 0;
    this.zIndexStore = /* @__PURE__ */ new Map();
    this.lastUUID = null;
    this.maskStyle = {
      position: "fixed",
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      display: "none",
      "background-color": "rgba(0,0,0,.6)"
    };
    this.isInit = false;
    this.maskAttrTag = "auto";
    const { multiInstance = false, maskAttrTag = "auto", parentNode = document.body, maskStyle = {}, onClick = null, popInstance = null } = config || {};
    this.parentNode = parentNode || document;
    this.maskAttrTag = maskAttrTag;
    this.onClick = onClick;
    this.activeInstance = void 0;
    this.multiInstance = multiInstance;
    this.popInstance = popInstance;
    this.uniqueMaskAttrTag = this.getMaskAttrTag(maskAttrTag);
    bkMaskMaker.appendMaker(() => {
      this.initInstance(maskStyle);
    });
  }
  setOption(option) {
    const { parentNode = document.body, maskStyle = {}, onClick = null, maskAttrTag = this.maskAttrTag } = option || {};
    this.onClick = onClick;
    this.parentNode = parentNode || document;
    this.setMaskStyle(Object.assign({}, this.maskStyle, maskStyle));
    this.uniqueMaskAttrTag = this.getMaskAttrTag(maskAttrTag);
  }
  show(content, zIndex, showMask = true, appendStyle = {}, uuid2 = null, transfer2 = false) {
    const uid = uuid2 != null ? uuid2 : random(16);
    const localZIndex = /-?\d+/.test(`${zIndex}`) ? zIndex : bkZIndexManager.getModalNextIndex();
    let style2 = Object.assign({}, this.maskStyle, appendStyle || {});
    if (!showMask) {
      if (this.lastUUID) {
        const preStore = this.zIndexStore.get(this.lastUUID);
        if (preStore) {
          style2 = preStore == null ? void 0 : preStore.style;
        }
      }
    }
    this.storeMaskInsCfg({
      zIndex: localZIndex,
      style: __spreadValues({}, style2),
      uuid: uid,
      preUID: this.lastUUID
    });
    Object.assign(style2, {
      display: "block",
      "z-index": `${localZIndex}`,
      "pointer-events": "all"
    });
    this.initInstance(style2);
    this.catchClickEvent();
    this.setMaskStyle(style2);
    bkMaskMaker.pushMaskStyle(this.parentNode, __spreadValues({}, style2));
    this.backupMask.style.setProperty("z-index", `${localZIndex - 1}`);
    if (!showMask) {
      this.mask.style.setProperty("pointer-events", "none");
      content == null ? void 0 : content.style.setProperty("pointer-events", "all");
    }
    if (content) {
      if (transfer2)
        content.style.setProperty("z-index", `${localZIndex + 1}`);
      this.activeInstance = content;
      this.appendContentToMask(content);
    }
  }
  hide(transfer2 = false, content, uuid2) {
    var _a;
    const uid = uuid2 != null ? uuid2 : this.lastUUID;
    if (!transfer2) {
      content == null ? void 0 : content.remove();
      (_a = this.activeInstance) == null ? void 0 : _a.remove();
    }
    this.removeClickEvent();
    this.activeInstance = void 0;
    this.popIndexStore(uid);
    const maskList = bkMaskMaker.getMaskStyles(this.parentNode);
    maskList == null ? void 0 : maskList.pop();
    if (!(maskList == null ? void 0 : maskList.length)) {
      this.mask.style.setProperty("display", "none");
    } else {
      const style2 = maskList.slice(-1)[0];
      this.setMaskStyle(style2);
    }
  }
  storeMaskInsCfg(config) {
    this.zIndexStore.set(config.uuid, config);
    this.lastUUID = config.uuid;
    return this.zIndexStore.get(config.uuid);
  }
  popIndexStore(uuid2) {
    if (this.zIndexStore.has(uuid2)) {
      const rmIns = this.zIndexStore.get(uuid2);
      this.lastUUID = rmIns.preUID;
      return this.zIndexStore.delete(uuid2);
    }
    this.lastUUID = null;
    return false;
  }
  backupActiveInstance() {
    if (this.activeInstance) {
      this.backupMask.append(this.activeInstance);
    }
  }
  backupContentElement(content) {
    content && this.backupMask.append(content);
  }
  getActiveContentInstance() {
    return this.activeInstance;
  }
  initInstance(maskStyle) {
    if (!this.isInit) {
      this.isInit = true;
      const { instance, isExist } = this.getMask();
      this.mask = instance;
      this.backupMask = this.getBackupMask();
      !isExist && this.setMaskStyle(Object.assign({}, this.maskStyle, maskStyle));
    }
  }
  getMask() {
    if (this.multiInstance) {
      return { instance: this.createMask(), isExist: false };
    }
    let isExist = true;
    let div = this.parentNode.querySelector(`[data-bk-mask-uid='${this.uniqueMaskAttrTag}']`);
    if (!div) {
      isExist = false;
      div = this.createMask();
    }
    return {
      instance: div,
      isExist
    };
  }
  catchClickEvent() {
    if (this.mask) {
      this.mask.addEventListener("click", (e) => this.handleMaskClick(e), true);
    }
  }
  removeClickEvent() {
    if (this.mask) {
      this.mask.removeEventListener("click", this.handleMaskClick);
    }
  }
  handleMaskClick(e) {
    if (e.target === this.mask) {
      if (typeof this.onClick === "function") {
        Reflect.apply(this.onClick, this.popInstance || this, [e]);
      }
    }
  }
  getBackupMask() {
    const attrName = "data-bk-backup-uid";
    let div = this.parentNode.querySelector(`[${attrName}]`);
    if (!div) {
      div = this.createMask(attrName);
    }
    return div;
  }
  createMask(attrName = "data-bk-mask-uid") {
    const div = document.createElement("div");
    div.setAttribute(attrName, this.uniqueMaskAttrTag);
    this.parentNode.append(div);
    return div;
  }
  setMaskStyle(maskStyle = {}) {
    if (this.mask) {
      Object.entries(maskStyle).forEach((cfg) => this.mask.style.setProperty(cfg[0], cfg[1]));
    }
  }
  getMaskAttrTag(tag2) {
    if (/^(auto|\s+)$/i.test(tag2) || tag2 === null || tag2 === void 0 || tag2 === "") {
      if (!bkMaskMaker.getMaskId(this.parentNode)) {
        bkMaskMaker.setMaskId(this.parentNode, `__bk_mask_${random(16)}`);
      }
      return bkMaskMaker.getMaskId(this.parentNode);
    }
    return tag2;
  }
  appendContentToMask(content) {
    this.mask.append(content);
  }
}
new BkMaskManager({});
class BKPopIndexManager {
  constructor(options) {
    this.popInstanceList = [];
    this.clickFn = void 0;
    this.uuidAttrName = "data-bk-pop-uuid";
    this.bKMaskManagerInstance = new BkMaskManager({
      parentNode: this.getParentNode(options == null ? void 0 : options.transfer),
      popInstance: this,
      onClick: this.onMaskClickFn
    });
  }
  getParentNode(transfer2) {
    if (typeof transfer2 === "string") {
      const target = document.querySelector(transfer2);
      if (target) {
        return target;
      }
    }
    if (isElement$4(transfer2)) {
      return transfer2;
    }
    return document.body;
  }
  onMaskClick(callFn, target) {
    this.clickFn = { fn: callFn, target };
  }
  show(content, showMask = true, appendStyle = {}, transfer2 = false, zindex = void 0) {
    if (!content) {
      console.warn("pop show error: content is null or undefined");
      return;
    }
    const zIndex = typeof zindex === "number" ? zindex : bkZIndexManager.getModalNextIndex();
    const uuid2 = random(16);
    content.setAttribute(this.uuidAttrName, uuid2);
    this.popInstanceList.push({ uuid: uuid2, zIndex, content, showMask, appendStyle });
    showMask && this.bKMaskManagerInstance.backupActiveInstance();
    this.bKMaskManagerInstance.show(content, zIndex, showMask, appendStyle, uuid2, transfer2);
  }
  destroy(content, transfer2 = false) {
    this.clickFn = void 0;
    this.hide(content, transfer2);
  }
  popHide(removeLastContent = true) {
    if (this.popInstanceList.length) {
      if (removeLastContent) {
        const lastItem = this.popInstanceList.pop();
        this.bKMaskManagerInstance.popIndexStore(lastItem.uuid);
        lastItem.remove();
      }
      if (this.popInstanceList.length) {
        const activeItem = this.popInstanceList.slice(-1)[0];
        const { zIndex, content, showMask, appendStyle, uuid: uuid2 } = activeItem;
        this.bKMaskManagerInstance.show(content, zIndex, showMask, appendStyle, uuid2);
      } else {
        this.bKMaskManagerInstance.hide();
      }
    }
  }
  hide(content, transfer2 = false) {
    const uuid2 = content == null ? void 0 : content.getAttribute(this.uuidAttrName);
    if (uuid2) {
      const itemIndex = this.popInstanceList.findIndex((item) => item.uuid === uuid2);
      if (itemIndex >= 0) {
        if (!transfer2)
          this.popInstanceList[itemIndex].content.remove();
        this.popInstanceList.splice(itemIndex, 1);
        this.bKMaskManagerInstance.popIndexStore(uuid2);
        if (!this.popInstanceList.length) {
          this.bKMaskManagerInstance.hide(transfer2);
        } else {
          this.popHide(false);
        }
      }
    } else {
      content == null ? void 0 : content.remove();
    }
  }
  onMaskClickFn(e) {
    const { fn: fn2 } = this.clickFn;
    if (fn2) {
      Reflect.apply(fn2, this, [e]);
    }
  }
}
new BKPopIndexManager();
var rngBrowser = { exports: {} };
var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
if (getRandomValues) {
  var rnds8 = new Uint8Array(16);
  rngBrowser.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  var rnds = new Array(16);
  rngBrowser.exports = function mathRNG() {
    for (var i2 = 0, r2; i2 < 16; i2++) {
      if ((i2 & 3) === 0)
        r2 = Math.random() * 4294967296;
      rnds[i2] = r2 >>> ((i2 & 3) << 3) & 255;
    }
    return rnds;
  };
}
var byteToHex = [];
for (var i$1 = 0; i$1 < 256; ++i$1) {
  byteToHex[i$1] = (i$1 + 256).toString(16).substr(1);
}
function bytesToUuid$2(buf, offset2) {
  var i2 = offset2 || 0;
  var bth = byteToHex;
  return [
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]]
  ].join("");
}
var bytesToUuid_1 = bytesToUuid$2;
var rng$1 = rngBrowser.exports;
var bytesToUuid$1 = bytesToUuid_1;
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1$1(options, buf, offset2) {
  var i2 = buf && offset2 || 0;
  var b2 = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = rng$1();
    if (node == null) {
      node = _nodeId = [
        seedBytes[0] | 1,
        seedBytes[1],
        seedBytes[2],
        seedBytes[3],
        seedBytes[4],
        seedBytes[5]
      ];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b2[i2++] = tl >>> 24 & 255;
  b2[i2++] = tl >>> 16 & 255;
  b2[i2++] = tl >>> 8 & 255;
  b2[i2++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b2[i2++] = tmh >>> 8 & 255;
  b2[i2++] = tmh & 255;
  b2[i2++] = tmh >>> 24 & 15 | 16;
  b2[i2++] = tmh >>> 16 & 255;
  b2[i2++] = clockseq >>> 8 | 128;
  b2[i2++] = clockseq & 255;
  for (var n2 = 0; n2 < 6; ++n2) {
    b2[i2 + n2] = node[n2];
  }
  return buf ? buf : bytesToUuid$1(b2);
}
var v1_1 = v1$1;
var rng = rngBrowser.exports;
var bytesToUuid = bytesToUuid_1;
function v4$1(options, buf, offset2) {
  var i2 = buf && offset2 || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i2 + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid(rnds);
}
var v4_1 = v4$1;
var v1 = v1_1;
var v4 = v4_1;
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
var uuid_1 = uuid;
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName$1(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow$1(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$3(node) {
  var OwnElement = getWindow$1(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement$1(node) {
  var OwnElement = getWindow$1(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot$1(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max$2 = Math.max;
var min$2 = Math.min;
var round$1 = Math.round;
function getBoundingClientRect$1(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement$1(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round$1(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round$1(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect$1(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains$1(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].indexOf(getNodeName$1(element)) >= 0;
}
function getDocumentElement$1(element) {
  return ((isElement$3(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode$1(element) {
  if (getNodeName$1(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot$1(element) ? element.host : null) || getDocumentElement$1(element);
}
function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock$1(element) {
  var isFirefox2 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle$2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode$1(element);
  if (isShadowRoot$1(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
    var css = getComputedStyle$2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox2 && css.willChange === "filter" || isFirefox2 && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent$1(element) {
  var window2 = getWindow$1(element);
  var offsetParent = getTrueOffsetParent$1(element);
  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock$1(element) || window2;
}
function getMainAxisFromPlacement$1(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within$1(min2, value, max2) {
  return max$2(min2, min$2(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within$1(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow$1(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement$1(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent$1(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within$1(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains$1(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$2 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow$1,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y2 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x2 * dpr) / dpr || 0,
    y: round$1(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent$1(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow$1(popper2)) {
      offsetParent = getDocumentElement$1(popper2);
      if (getComputedStyle$2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow$1(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$3[matched];
  });
}
var hash$2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash$2[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow$1(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop2 = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop: scrollTop2
  };
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect$1(element) {
  var win = getWindow$1(element);
  var html2 = getDocumentElement$1(element);
  var visualViewport = win.visualViewport;
  var width = html2.clientWidth;
  var height = html2.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX$1(element),
    y: y2
  };
}
function getDocumentRect$1(element) {
  var _element$ownerDocumen;
  var html2 = getDocumentElement$1(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$2(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$2(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX$1(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$2(body || html2).direction === "rtl") {
    x2 += max$2(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$2(element), overflow2 = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow2 + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName$1(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement$1(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode$1(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow$1(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode$1(target)));
}
function rectToClientRect$1(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect$1(element) {
  var rect = getBoundingClientRect$1(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect$1(getViewportRect$1(element)) : isElement$3(clippingParent) ? getInnerBoundingClientRect$1(clippingParent) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode$1(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;
  if (!isElement$3(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$3(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
  });
}
function getClippingRect$1(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max$2(rect.top, accRect.top);
    accRect.right = min$2(rect.right, accRect.right);
    accRect.bottom = min$2(rect.bottom, accRect.bottom);
    accRect.left = max$2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement$1(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow$1(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect$1(isElement$3(element) ? element : element.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow$1(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip$1(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement$1(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow2 = detectOverflow$1(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement$1(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement$1(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow2[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow2[mainVariationSide] <= 0, overflow2[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$2 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip$1,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets$1(overflow2, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow2.top - rect.height - preventedOffsets.y,
    right: overflow2.right - rect.width + preventedOffsets.x,
    bottom: overflow2.bottom - rect.height + preventedOffsets.y,
    left: overflow2.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped$1(overflow2) {
  return [top, right, bottom, left].some(function(side) {
    return overflow2[side] >= 0;
  });
}
function hide$2(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow$1(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow$1(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets$1(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets$1(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped$1(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped$1(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$3 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide$2
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
function offset$1(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data2;
}
var offset$2 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset$1
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow2 = detectOverflow$1(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement$1(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow2[mainSide];
    var max2 = offset2 - overflow2[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within$1(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent$1(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within$1(tether ? min$2(min2, tetherMin) : min2, offset2, tether ? max$2(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow2[_mainSide];
    var _max = _offset - overflow2[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within$1(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data2;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll$1(node) {
  if (node === getWindow$1(node) || !isHTMLElement$1(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement$1(offsetParent);
  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect$1(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement$3(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent$1(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce$1(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$2, preventOverflow$1, arrow$2, hide$3];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
class BKPopover {
  constructor(reference2, popperRefer, options) {
    var _a, _b;
    this.isShow = false;
    this.trigger = void 0;
    this.instance = void 0;
    this.always = false;
    this.reference = void 0;
    this.referenceTarget = void 0;
    this.popperRefer = void 0;
    this.delay = 50;
    this.isInnerPopper = false;
    this.disabled = false;
    this.afterShow = null;
    this.afterHidden = null;
    this.appendTo = "parent";
    this.container = null;
    this.fixOnBoundary = false;
    this.instanceOptions = this.initDefaultOptions(options);
    this.reference = this.resolveInputSelectorToHtmlElement(reference2);
    this.popperRefer = this.resolveInputSelectorToHtmlElement(popperRefer);
    this.referenceTarget = this.getTargetReferenceElement();
    this.container = (_a = this.popperRefer) == null ? void 0 : _a.parentElement;
    this.isShow = !!((_b = this.instanceOptions) == null ? void 0 : _b.isShow);
    this.always = this.instanceOptions.always;
    this.trigger = this.instanceOptions.trigger;
    this.disabled = this.instanceOptions.disabled;
    this.appendTo = this.instanceOptions.appendTo;
    this.afterHidden = typeof options.afterHidden === "function" ? options.afterHidden : () => {
    };
    this.afterShow = typeof options.afterShow === "function" ? options.afterShow : () => {
    };
    this.fixOnBoundary = this.instanceOptions.fixOnBoundary;
    this.initInstance();
    this.registerEvents();
    if (this.isShow || this.always) {
      this.show(null);
    }
  }
  forceUpdate() {
    var _a;
    (_a = this.instance) == null ? void 0 : _a.forceUpdate();
  }
  update() {
    var _a;
    (_a = this.instance) == null ? void 0 : _a.update();
  }
  updateOptions(options) {
    var _a;
    this.instanceOptions = this.initDefaultOptions(options);
    this.isShow = !!((_a = this.instanceOptions) == null ? void 0 : _a.isShow);
    this.trigger = this.instanceOptions.trigger;
    this.disabled = this.instanceOptions.disabled;
    this.setOptions(this.instanceOptions);
  }
  setOptions(options) {
    var _a;
    (_a = this.instance) == null ? void 0 : _a.setOptions(options);
  }
  destroy() {
    var _a;
    (_a = this.instance) == null ? void 0 : _a.destroy();
  }
  updateDisabled(disabled) {
    this.disabled = disabled != null ? disabled : !this.disabled;
    this.disabled && this.hide();
  }
  show(_event) {
    var _a;
    if (!this.disabled) {
      (_a = this.popperRefer) == null ? void 0 : _a.setAttribute("data-show", "");
      this.setOptions({
        modifiers: [...this.instanceOptions.modifiers || [], { name: "eventListeners", enabled: true }]
      });
      this.update();
      this.isShow = true;
      this.afterShow();
      if (!this.fixOnBoundary) {
        this.appendToTarget();
      }
    }
  }
  hide() {
    var _a;
    if (this.always)
      return;
    (_a = this.popperRefer) == null ? void 0 : _a.removeAttribute("data-show");
    this.setOptions({
      modifiers: [...this.instanceOptions.modifiers || [], { name: "eventListeners", enabled: false }]
    });
    this.isShow = false;
    this.isInnerPopper = false;
    this.afterHidden();
    if (!this.fixOnBoundary) {
      this.restorePopContent();
    }
  }
  restorePopContent() {
    const target = this.getAppendToTarget();
    if (isElement$4(target) && target.contains(this.popperRefer) && this.container && !this.container.contains(this.popperRefer)) {
      this.container.append(this.popperRefer);
    }
  }
  appendToTarget() {
    const target = this.getAppendToTarget();
    if (isElement$4(target) && target.contains(this.popperRefer)) {
      target.append(this.popperRefer);
    }
  }
  getAppendToTarget() {
    const { appendTo } = this;
    let target = appendTo;
    if (appendTo !== "parent") {
      if (typeof appendTo === "string") {
        target = document.querySelector(appendTo);
      }
    }
    return target;
  }
  initDefaultOptions(opts) {
    const defaultCfg = {
      placement: "top",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 8]
          }
        }
      ],
      strategy: "absolute",
      onFirstUpdate: void 0,
      isShow: false,
      theme: "dark",
      trigger: "hover",
      disabled: false
    };
    const targetOptions = merge$1(defaultCfg, opts || {});
    const sourceOnFirstUpdate = targetOptions.onFirstUpdate;
    targetOptions.onFirstUpdate = (state) => {
      if (typeof sourceOnFirstUpdate === "function") {
        sourceOnFirstUpdate.call(this, state);
        this.handleFirstUpdate();
      }
    };
    return targetOptions;
  }
  handleFirstUpdate() {
    if (this.fixOnBoundary) {
      this.appendToTarget();
    }
  }
  getTargetReferenceElement() {
    if (this.isElement(this.reference)) {
      return this.reference.childElementCount === 1 ? this.reference.firstElementChild : this.reference;
    }
    return this.reference;
  }
  initInstance() {
    var _a, _b;
    if (this.referenceTarget) {
      if (this.referenceTarget && this.popperRefer) {
        this.instance = createPopper(this.referenceTarget, this.popperRefer, this.instanceOptions);
        (_b = this.popperRefer) == null ? void 0 : _b.setAttribute("data-theme", (_a = this.instanceOptions.theme) != null ? _a : "dark");
      } else {
        console.error("reference or popperRefer is null, please check html element.");
      }
    }
  }
  resolveInputSelectorToHtmlElement(refer) {
    if (this.isElement(refer)) {
      return refer;
    }
    if (typeof refer === "string") {
      return document.querySelector(refer);
    }
    if (typeof refer === "object") {
      if (Object.prototype.hasOwnProperty.call(refer, "getBoundingClientRect")) {
        return refer;
      }
    } else {
      console.error("'getBoundingClientRect' is needed when use virtual elements");
    }
    return null;
  }
  isElement(obj) {
    return isElement$4(obj);
  }
  registerEvents() {
    if (this.isElement(this.referenceTarget)) {
      if (this.trigger === "hover") {
        const showEvents = ["mouseenter", "focus"];
        const hideEvents = ["mouseleave", "blur"];
        const contentEvents = ["mouseenter", "mouseleave"];
        showEvents.forEach((event) => {
          this.referenceTarget.addEventListener(event, (evt) => {
            if (event === "mouseenter")
              this.isInnerPopper = true;
            this.show(evt);
          });
        });
        hideEvents.forEach((event) => {
          this.referenceTarget.addEventListener(event, () => {
            this.isInnerPopper = false;
            setTimeout(() => {
              !this.isInnerPopper && this.hide();
            }, this.delay);
          });
        });
        if (this.isElement(this.popperRefer)) {
          contentEvents.forEach((event) => {
            this.popperRefer.addEventListener(event, () => {
              if (event === "mouseenter")
                this.isInnerPopper = true;
              if (event === "mouseleave")
                this.hide();
            });
          });
        }
      }
    }
    if (this.trigger === "click") {
      const showEvents = ["click"];
      showEvents.forEach((event) => {
        document.body.addEventListener(event, (event2) => {
          if (this.isSameElement(event2.target, this.reference) || this.reference.contains(event2.target)) {
            this.show(event2);
          } else {
            if (this.isShow && !this.isSameElement(event2.target, this.popperRefer) && !this.popperRefer.contains(event2.target)) {
              this.hide();
            }
          }
        });
      });
    }
  }
  isSameElement(source, target) {
    return source && (source === target || source === target.firstElementChild);
  }
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isPlainObject(o2) {
  var ctor, prot;
  if (isObject(o2) === false)
    return false;
  ctor = o2.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function t() {
  return t = Object.assign || function(e) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2)
        Object.prototype.hasOwnProperty.call(r2, n2) && (e[n2] = r2[n2]);
    }
    return e;
  }, t.apply(this, arguments);
}
function r(e, t2) {
  if (e == null)
    return {};
  var r2, n2, i2 = {}, o2 = Object.keys(e);
  for (n2 = 0; n2 < o2.length; n2++)
    t2.indexOf(r2 = o2[n2]) >= 0 || (i2[r2] = e[r2]);
  return i2;
}
const n = { silent: false, logLevel: "warn" }, i = ["validator"], o = Object.prototype, a = o.toString, s = o.hasOwnProperty, u = /^\s*function (\w+)/;
function l(e) {
  var t2;
  const r2 = (t2 = e == null ? void 0 : e.type) !== null && t2 !== void 0 ? t2 : e;
  if (r2) {
    const e2 = r2.toString().match(u);
    return e2 ? e2[1] : "";
  }
  return "";
}
const c = isPlainObject, f = (e) => e;
let d = f;
const p = (e, t2) => s.call(e, t2), y = Number.isInteger || function(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}, v = Array.isArray || function(e) {
  return a.call(e) === "[object Array]";
}, h = (e) => a.call(e) === "[object Function]", b = (e) => c(e) && p(e, "_vueTypes_name"), g = (e) => c(e) && (p(e, "type") || ["_vueTypes_name", "validator", "default", "required"].some((t2) => p(e, t2)));
function O(e, t2) {
  return Object.defineProperty(e.bind(t2), "__original", { value: e });
}
function m(e, t2, r2 = false) {
  let n2, i2 = true, o2 = "";
  n2 = c(e) ? e : { type: e };
  const a2 = b(n2) ? n2._vueTypes_name + " - " : "";
  if (g(n2) && n2.type !== null) {
    if (n2.type === void 0 || n2.type === true)
      return i2;
    if (!n2.required && t2 === void 0)
      return i2;
    v(n2.type) ? (i2 = n2.type.some((e2) => m(e2, t2, true) === true), o2 = n2.type.map((e2) => l(e2)).join(" or ")) : (o2 = l(n2), i2 = o2 === "Array" ? v(t2) : o2 === "Object" ? c(t2) : o2 === "String" || o2 === "Number" || o2 === "Boolean" || o2 === "Function" ? function(e2) {
      if (e2 == null)
        return "";
      const t3 = e2.constructor.toString().match(u);
      return t3 ? t3[1] : "";
    }(t2) === o2 : t2 instanceof n2.type);
  }
  if (!i2) {
    const e2 = `${a2}value "${t2}" should be of type "${o2}"`;
    return r2 === false ? (d(e2), false) : e2;
  }
  if (p(n2, "validator") && h(n2.validator)) {
    const e2 = d, o3 = [];
    if (d = (e3) => {
      o3.push(e3);
    }, i2 = n2.validator(t2), d = e2, !i2) {
      const e3 = (o3.length > 1 ? "* " : "") + o3.join("\n* ");
      return o3.length = 0, r2 === false ? (d(e3), i2) : e3;
    }
  }
  return i2;
}
function j(e, t2) {
  const r2 = Object.defineProperties(t2, { _vueTypes_name: { value: e, writable: true }, isRequired: { get() {
    return this.required = true, this;
  } }, def: { value(e2) {
    return e2 === void 0 ? (p(this, "default") && delete this.default, this) : h(e2) || m(this, e2, true) === true ? (this.default = v(e2) ? () => [...e2] : c(e2) ? () => Object.assign({}, e2) : e2, this) : (d(`${this._vueTypes_name} - invalid default value: "${e2}"`), this);
  } } }), { validator: n2 } = r2;
  return h(n2) && (r2.validator = O(n2, r2)), r2;
}
function _(e, t2) {
  const r2 = j(e, t2);
  return Object.defineProperty(r2, "validate", { value(e2) {
    return h(this.validator) && d(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O(e2, this), this;
  } });
}
function T(e, t2, n2) {
  const o2 = function(e2) {
    const t3 = {};
    return Object.getOwnPropertyNames(e2).forEach((r2) => {
      t3[r2] = Object.getOwnPropertyDescriptor(e2, r2);
    }), Object.defineProperties({}, t3);
  }(t2);
  if (o2._vueTypes_name = e, !c(n2))
    return o2;
  const { validator: a2 } = n2, s2 = r(n2, i);
  if (h(a2)) {
    let { validator: e2 } = o2;
    e2 && (e2 = (l2 = (u2 = e2).__original) !== null && l2 !== void 0 ? l2 : u2), o2.validator = O(e2 ? function(t3) {
      return e2.call(this, t3) && a2.call(this, t3);
    } : a2, o2);
  }
  var u2, l2;
  return Object.assign(o2, s2);
}
function $(e) {
  return e.replace(/^(?!\s*$)/gm, "  ");
}
const w = () => _("any", {}), P = () => _("function", { type: Function }), x = () => _("boolean", { type: Boolean }), E = () => _("string", { type: String }), N = () => _("number", { type: Number }), q = () => _("array", { type: Array }), A = () => _("object", { type: Object }), V = () => j("integer", { type: Number, validator: (e) => y(e) }), S = () => j("symbol", { validator: (e) => typeof e == "symbol" });
function k(e, t2 = "custom validation failed") {
  if (typeof e != "function")
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return j(e.name || "<<anonymous function>>", { type: null, validator(r2) {
    const n2 = e(r2);
    return n2 || d(`${this._vueTypes_name} - ${t2}`), n2;
  } });
}
function D(e) {
  if (!v(e))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  const t2 = `oneOf - value should be one of "${e.join('", "')}".`, r2 = e.reduce((e2, t3) => {
    if (t3 != null) {
      const r3 = t3.constructor;
      e2.indexOf(r3) === -1 && e2.push(r3);
    }
    return e2;
  }, []);
  return j("oneOf", { type: r2.length > 0 ? r2 : void 0, validator(r3) {
    const n2 = e.indexOf(r3) !== -1;
    return n2 || d(t2), n2;
  } });
}
function L(e) {
  if (!v(e))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  let t2 = false, r2 = [];
  for (let n3 = 0; n3 < e.length; n3 += 1) {
    const i2 = e[n3];
    if (g(i2)) {
      if (b(i2) && i2._vueTypes_name === "oneOf" && i2.type) {
        r2 = r2.concat(i2.type);
        continue;
      }
      if (h(i2.validator) && (t2 = true), i2.type === true || !i2.type) {
        d('oneOfType - invalid usage of "true" or "null" as types.');
        continue;
      }
      r2 = r2.concat(i2.type);
    } else
      r2.push(i2);
  }
  r2 = r2.filter((e2, t3) => r2.indexOf(e2) === t3);
  const n2 = r2.length > 0 ? r2 : null;
  return j("oneOfType", t2 ? { type: n2, validator(t3) {
    const r3 = [], n3 = e.some((e2) => {
      const n4 = m(b(e2) && e2._vueTypes_name === "oneOf" ? e2.type || null : e2, t3, true);
      return typeof n4 == "string" && r3.push(n4), n4 === true;
    });
    return n3 || d(`oneOfType - provided value does not match any of the ${r3.length} passed-in validators:
${$(r3.join("\n"))}`), n3;
  } } : { type: n2 });
}
function F(e) {
  return j("arrayOf", { type: Array, validator(t2) {
    let r2 = "";
    const n2 = t2.every((t3) => (r2 = m(e, t3, true), r2 === true));
    return n2 || d(`arrayOf - value validation error:
${$(r2)}`), n2;
  } });
}
function Y(e) {
  return j("instanceOf", { type: e });
}
function B(e) {
  return j("objectOf", { type: Object, validator(t2) {
    let r2 = "";
    const n2 = Object.keys(t2).every((n3) => (r2 = m(e, t2[n3], true), r2 === true));
    return n2 || d(`objectOf - value validation error:
${$(r2)}`), n2;
  } });
}
function I(e) {
  const t2 = Object.keys(e), r2 = t2.filter((t3) => {
    var r3;
    return !((r3 = e[t3]) === null || r3 === void 0 || !r3.required);
  }), n2 = j("shape", { type: Object, validator(n3) {
    if (!c(n3))
      return false;
    const i2 = Object.keys(n3);
    if (r2.length > 0 && r2.some((e2) => i2.indexOf(e2) === -1)) {
      const e2 = r2.filter((e3) => i2.indexOf(e3) === -1);
      return d(e2.length === 1 ? `shape - required property "${e2[0]}" is not defined.` : `shape - required properties "${e2.join('", "')}" are not defined.`), false;
    }
    return i2.every((r3) => {
      if (t2.indexOf(r3) === -1)
        return this._vueTypes_isLoose === true || (d(`shape - shape definition does not include a "${r3}" property. Allowed keys: "${t2.join('", "')}".`), false);
      const i3 = m(e[r3], n3[r3], true);
      return typeof i3 == "string" && d(`shape - "${r3}" property validation error:
 ${$(i3)}`), i3 === true;
    });
  } });
  return Object.defineProperty(n2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n2, "loose", { get() {
    return this._vueTypes_isLoose = true, this;
  } }), n2;
}
const J = ["name", "validate", "getter"], M = /* @__PURE__ */ (() => {
  var e, t2;
  return t2 = e = class {
    static get any() {
      return w();
    }
    static get func() {
      return P().def(this.defaults.func);
    }
    static get bool() {
      return x().def(this.defaults.bool);
    }
    static get string() {
      return E().def(this.defaults.string);
    }
    static get number() {
      return N().def(this.defaults.number);
    }
    static get array() {
      return q().def(this.defaults.array);
    }
    static get object() {
      return A().def(this.defaults.object);
    }
    static get integer() {
      return V().def(this.defaults.integer);
    }
    static get symbol() {
      return S();
    }
    static extend(e2) {
      if (v(e2))
        return e2.forEach((e3) => this.extend(e3)), this;
      const { name: t3, validate: n2 = false, getter: i2 = false } = e2, o2 = r(e2, J);
      if (p(this, t3))
        throw new TypeError(`[VueTypes error]: Type "${t3}" already defined`);
      const { type: a2 } = o2;
      if (b(a2))
        return delete o2.type, Object.defineProperty(this, t3, i2 ? { get: () => T(t3, a2, o2) } : { value(...e3) {
          const r2 = T(t3, a2, o2);
          return r2.validator && (r2.validator = r2.validator.bind(r2, ...e3)), r2;
        } });
      let s2;
      return s2 = i2 ? { get() {
        const e3 = Object.assign({}, o2);
        return n2 ? _(t3, e3) : j(t3, e3);
      }, enumerable: true } : { value(...e3) {
        const r2 = Object.assign({}, o2);
        let i3;
        return i3 = n2 ? _(t3, r2) : j(t3, r2), r2.validator && (i3.validator = r2.validator.bind(i3, ...e3)), i3;
      }, enumerable: true }, Object.defineProperty(this, t3, s2);
    }
  }, e.defaults = {}, e.sensibleDefaults = void 0, e.config = n, e.custom = k, e.oneOf = D, e.instanceOf = Y, e.oneOfType = L, e.arrayOf = F, e.objectOf = B, e.shape = I, e.utils = { validate: (e2, t3) => m(t3, e2, true) === true, toType: (e2, t3, r2 = false) => r2 ? _(e2, t3) : j(e2, t3) }, t2;
})();
function R(e = { func: () => {
}, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
  var r2, n2;
  return n2 = r2 = class extends M {
    static get sensibleDefaults() {
      return t({}, this.defaults);
    }
    static set sensibleDefaults(r3) {
      this.defaults = r3 !== false ? t({}, r3 !== true ? r3 : e) : {};
    }
  }, r2.defaults = t({}, e), n2;
}
class z extends R() {
}
const propTypesNS = R({});
function stringEnum(o2) {
  return o2.reduce((res, key2) => {
    res[key2] = key2;
    return res;
  }, /* @__PURE__ */ Object.create(null));
}
var SizeEnum = /* @__PURE__ */ ((SizeEnum2) => {
  SizeEnum2["SMALL"] = "small";
  SizeEnum2["LARGE"] = "large";
  SizeEnum2["DEFAULT"] = "default";
  return SizeEnum2;
})(SizeEnum || {});
function renderDirectiveType() {
  return E().def("show");
}
var AlignEnum = /* @__PURE__ */ ((AlignEnum2) => {
  AlignEnum2["LEFT"] = "left";
  AlignEnum2["CENTER"] = "center";
  AlignEnum2["RIGHT"] = "right";
  return AlignEnum2;
})(AlignEnum || {});
function alignType() {
  return E().def("left");
}
var ThemeEnum = /* @__PURE__ */ ((ThemeEnum2) => {
  ThemeEnum2["PRIMARY"] = "primary";
  ThemeEnum2["WARNING"] = "warning";
  ThemeEnum2["SUCCESS"] = "success";
  ThemeEnum2["DANGER"] = "danger";
  return ThemeEnum2;
})(ThemeEnum || {});
var PlacementEnum = /* @__PURE__ */ ((PlacementEnum2) => {
  PlacementEnum2["AUTO"] = "auto";
  PlacementEnum2["AUTO_START"] = "auto-start";
  PlacementEnum2["AUTO_END"] = "auto-end";
  PlacementEnum2["TOP"] = "top";
  PlacementEnum2["RIGHT"] = "right";
  PlacementEnum2["BOTTOM"] = "bottom";
  PlacementEnum2["LEFT"] = "left";
  PlacementEnum2["TOP_START"] = "top-start";
  PlacementEnum2["TOP_END"] = "top-end";
  PlacementEnum2["BOTTOM_START"] = "bottom-start";
  PlacementEnum2["BOTTOM_END"] = "bottom-end";
  PlacementEnum2["RIGHT_START"] = "right-start";
  PlacementEnum2["RIGHT_END"] = "right-end";
  PlacementEnum2["LEFT_START"] = "left-start";
  PlacementEnum2["LEFT_END"] = "left-end";
  return PlacementEnum2;
})(PlacementEnum || {});
function placementType$1() {
  return E().def("bottom");
}
function triggerType$1() {
  return E().def("hover");
}
var RenderType = /* @__PURE__ */ ((RenderType2) => {
  RenderType2["AUTO"] = "auto";
  RenderType2["SHOWN"] = "shown";
  return RenderType2;
})(RenderType || {});
function renderType() {
  return j("popRenderType", {}).def("shown");
}
function dialogTypeUnion() {
  return j("dialogType", {
    default: "operation"
  });
}
function directionType() {
  return j("direction", {}).def("horizontal");
}
function lineStyleType() {
  return j("lineType", {}).def("dashed");
}
var TagThemeEnum = /* @__PURE__ */ ((TagThemeEnum2) => {
  TagThemeEnum2["SUCCESS"] = "success";
  TagThemeEnum2["INFO"] = "info";
  TagThemeEnum2["WARNING"] = "warning";
  TagThemeEnum2["DANGER"] = "danger";
  return TagThemeEnum2;
})(TagThemeEnum || {});
function TagThemeType() {
  return j("tagTheme", {}).def();
}
function InputBehaviorType() {
  return j("behavior", {}).def("normal");
}
class PropTypes extends propTypesNS {
  static size() {
    const defaultList = ["small", "default", "large"];
    return j("Size", {
      validator: (val) => {
        if (!val || defaultList.includes(val)) {
          return true;
        }
        console.error(`invalid theme, ${val}, the theme must be one of \u3010${defaultList.join(" | ")}\u3011`);
        return false;
      },
      default: "default"
    });
  }
  static theme() {
    const themes2 = ["primary", "warning", "success", "danger"];
    return j("Theme", {
      validator: (val) => {
        if (!val || themes2.includes(val)) {
          return true;
        }
        console.error(`invalid theme, ${val}, the theme must be one of \u3010${themes2.join(" | ")}\u3011`);
        return false;
      }
    });
  }
  static placement() {
    const placements2 = ["top", "left", "right", "bottom"];
    return j("Placements", {
      validator: (val) => {
        if (!val || placements2.includes(val)) {
          return true;
        }
        return false;
      },
      default: "top"
    });
  }
  static style() {
    return j("Style", {
      type: [String, Object]
    });
  }
  static position(positions = ["top-left", "top-right", "bottom-left", "bottom-right"]) {
    return j("positions", {
      type: String,
      validator: (val) => {
        if (!val || positions.includes(val)) {
          return true;
        }
        console.error(`invalid positions, ${val}, the position must be one of \u3010${positions.join(" | ")}\u3011`);
        return false;
      },
      default: "top-center"
    });
  }
}
function classes(dynamicCls, constCls = "") {
  return Object.entries(dynamicCls).filter((entry) => entry[1]).map((entry) => entry[0]).join(" ").concat(constCls ? ` ${constCls}` : "");
}
const EMPTY_OBJ = /* @__PURE__ */ Object.create({});
const isEmptyObj = (target) => Object.keys(target).length < 1;
const withInstall = (component) => {
  component.install = function(app, { prefix } = {}) {
    const pre = app.config.globalProperties.bkUIPrefix || prefix || "Bk";
    app.component(pre + component.name, component);
  };
  return component;
};
const withInstallProps = (component, childComponents, isProps = false, directive) => {
  component.install = function(app, { prefix } = {}) {
    const pre = app.config.globalProperties.bkUIPrefix || prefix || "Bk";
    if (directive) {
      app.directive(pre + directive.name, directive.directive);
    }
    app.component(pre + component.name, component);
    !isProps && Object.values(childComponents).forEach((child) => {
      app.component(pre + child.name, child);
    });
  };
  Object.keys(childComponents).forEach((key2) => {
    component[key2] = childComponents[key2];
  });
  return component;
};
function resolveClassName(clsName, prefix = "lesscode-bk") {
  return `${prefix}-${clsName}`;
}
function debounce(delay = 300, fn2, immediate = false) {
  let timeout;
  let result;
  const debounced = function() {
    const ctx = this;
    const args = arguments;
    if (timeout)
      clearTimeout(timeout);
    if (immediate) {
      const applyImmediate = !timeout;
      timeout = setTimeout(() => {
        timeout = null;
      }, delay);
      if (applyImmediate)
        result = fn2.apply(ctx, args);
    } else {
      timeout = setTimeout(() => {
        fn2.apply(ctx, args);
      }, delay);
    }
    return result;
  };
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = null;
  };
  return debounced;
}
function arrayEqual(arr1 = [], arr2 = []) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i2 = 0; i2 < arr1.length; i2++) {
    if (Array.isArray(arr1[i2])) {
      return arrayEqual(arr1[i2], arr2[i2]);
    }
    if (arr1[i2] !== arr2[i2]) {
      return false;
    }
  }
  return true;
}
const zhCn = {
  lang: "zh-cn",
  steps: {
    step1: "\u6B65\u9AA41",
    step2: "\u6B65\u9AA42",
    step3: "\u6B65\u9AA43"
  },
  datePicker: {
    selectDate: "\u9009\u62E9\u65E5\u671F",
    selectTime: "\u9009\u62E9\u65F6\u95F4",
    clear: "\u6E05\u9664",
    ok: "\u786E\u5B9A",
    weekdays: {
      sun: "\u65E5",
      mon: "\u4E00",
      tue: "\u4E8C",
      wed: "\u4E09",
      thu: "\u56DB",
      fri: "\u4E94",
      sat: "\u516D"
    },
    hour: "\u65F6",
    min: "\u5206",
    sec: "\u79D2",
    toNow: "\u81F3\u4ECA"
  },
  dialog: {
    ok: "\u786E\u5B9A",
    cancel: "\u53D6\u6D88",
    prev: "\u4E0A\u4E00\u6B65",
    next: "\u4E0B\u4E00\u6B65"
  },
  popConfirm: {
    ok: "\u786E\u5B9A",
    cancel: "\u53D6\u6D88"
  },
  form: {
    notBeEmpty: "\u4E0D\u80FD\u4E3A\u7A7A",
    incorrectFormat: "\u683C\u5F0F\u4E0D\u6B63\u786E",
    max: "\u6700\u5927\u503C",
    min: "\u6700\u5C0F\u503C",
    maxLen: "\u6700\u5927\u957F\u5EA6",
    verifyError: "\u9A8C\u8BC1\u9519\u8BEF"
  },
  pagination: {
    eachPage: "\u6BCF\u9875",
    strip: "\u6761",
    total: "\u5171\u8BA1"
  },
  process: {
    step1: "\u6B65\u9AA41",
    step2: "\u6B65\u9AA42",
    step3: "\u6B65\u9AA43",
    step4: "\u6B65\u9AA44"
  },
  searchSelect: {
    pleaseSelect: "\u8BF7\u9009\u62E9",
    loading: "\u52A0\u8F7D\u4E2D...",
    filterQueryMustHasValue: "\u5305\u542B\u952E\u503C\u7684\u8FC7\u6EE4\u67E5\u8BE2\u5FC5\u987B\u6709\u4E00\u4E2A\u503C",
    ok: "\u786E\u8BA4",
    cancel: "\u53D6\u6D88",
    or: "\u6216",
    and: "\u4E14"
  },
  select: {
    noData: "\u65E0\u6570\u636E",
    noMatchedData: "\u65E0\u5339\u914D\u6570\u636E",
    loading: "\u52A0\u8F7D\u4E2D...",
    pleaseSelect: "\u8BF7\u9009\u62E9",
    enterKeywords: "\u8BF7\u8F93\u5165\u5173\u952E\u5B57",
    all: "\u5168\u90E8"
  },
  table: {
    emptyText: "\u6682\u65E0\u6570\u636E",
    confirm: "\u786E\u5B9A",
    reset: "\u91CD\u7F6E",
    setting: {
      title: "\u8868\u683C\u8BBE\u7F6E",
      fields: {
        title: "\u5B57\u6BB5\u663E\u793A\u8BBE\u7F6E",
        subtitle: (max2) => `\uFF08\u6700\u591A${max2}\u9879\uFF09`,
        selectAll: "\u5168\u9009"
      },
      lineHeight: {
        title: "\u8868\u683C\u884C\u9AD8",
        small: "\u5C0F",
        medium: "\u4E2D",
        large: "\u5927"
      },
      options: {
        ok: "\u786E\u8BA4",
        cancel: "\u53D6\u6D88"
      }
    }
  },
  transfer: {
    sourceList: "\u6E90\u5217\u8868",
    targetList: "\u76EE\u6807\u5217\u8868",
    removeAll: "\u6E05\u7A7A",
    selectAll: "\u9009\u62E9\u5168\u90E8",
    noData: "\u65E0\u6570\u636E",
    noSelected: "\u672A\u9009\u62E9\u4EFB\u4F55\u9879",
    search: "\u641C\u7D22"
  },
  upload: {
    uploadSuccess: "\u4E0A\u4F20\u6210\u529F",
    uploadFailed: "\u4E0A\u4F20\u5931\u8D25",
    drapFileOr: "\u5C06\u6587\u4EF6\u62D6\u5230\u6B64\u5904\u6216",
    clickUpload: "\u70B9\u51FB\u4E0A\u4F20",
    uploadLabel: "\u4E0A\u4F20\u6587\u4EF6"
  },
  input: {
    placeholder: "\u8BF7\u8F93\u5165"
  },
  tagInput: {
    placeholder: "\u8BF7\u8F93\u5165\u5E76\u6309Enter\u7ED3\u675F"
  }
};
const rootProviderKey = Symbol("rootProviderData");
const defaultRootConfig = {
  locale: zhCn,
  prefix: "bk"
};
const setPrefixVariable = (prefix) => {
  document.documentElement.style.setProperty("--bk-prefix", prefix || defaultRootConfig.prefix);
};
const provideGlobalConfig = (config) => {
  const configData = reactive(__spreadValues({}, lodash.exports.merge(defaultRootConfig, config)));
  setPrefixVariable(config.prefix);
  Object.keys(config).forEach((key2) => {
    watch(() => config[key2], () => {
      if (key2 === "prefix")
        setPrefixVariable(config[key2]);
      configData[key2] = config[key2];
    });
  });
  provide(rootProviderKey, configData);
};
const useGlobalConfig = () => {
  const config = inject(rootProviderKey, defaultRootConfig);
  return computed(() => config);
};
const configProviderProps = {
  locale: {
    type: Object
  },
  prefix: {
    type: String,
    default: "bk"
  }
};
var Component$G = defineComponent({
  name: "ConfigProvider",
  inheritAttrs: false,
  props: configProviderProps,
  setup(props2, {
    slots
  }) {
    provideGlobalConfig(props2);
    return () => {
      var _a;
      return (_a = slots.default) == null ? void 0 : _a.call(slots);
    };
  }
});
function useLocale(compName) {
  const config = inject(rootProviderKey, defaultRootConfig);
  return computed(() => {
    const { locale: locale2 } = config;
    return locale2 && compName ? locale2[compName] : {};
  });
}
function usePrefix() {
  const config = inject(rootProviderKey, defaultRootConfig);
  const prefix = computed(() => {
    const { prefix: prefix2 } = config;
    return "lesscode-bk";
  });
  function resolveClassName2(cls) {
    return `${prefix.value}-${cls.replace(new RegExp(`^${defaultRootConfig.prefix}-`), "")}`;
  }
  return {
    prefix,
    resolveClassName: resolveClassName2
  };
}
const BkConfigProvider = withInstall(Component$G);
function generate(node, key2, rootAttrs) {
  return h$1(node.name, __spreadProps(__spreadValues({
    key: key2
  }, node.attributes), {
    style: `${node.attributes.style} ${rootAttrs || ""}`
  }), (node.elements || []).map((element, index2) => generate(element, `${key2}-${node.name}-${index2}`)));
}
const bkIcon = (props2, context) => {
  const _a = __spreadValues(__spreadValues({}, context.attrs), props2), {
    data: data2,
    name,
    width,
    height,
    fill
  } = _a, restProps = __objRest(_a, [
    "data",
    "name",
    "width",
    "height",
    "fill"
  ]);
  const rootAttrs = `width: ${width}; height: ${height}; fill: ${fill}`;
  const iconBoxStyle = {
    display: "inline-flex",
    "align-items": "center",
    "justify-content": "center"
  };
  return createVNode("span", mergeProps({
    "style": iconBoxStyle
  }, restProps), [generate(data2, name, rootAttrs)]);
};
bkIcon.inheritAttrs = false;
bkIcon.displayName = "bkIcon";
const data$1e = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 744.64L789.6 462.72 880 554.56 512 928 144 554.56 234.4 462.72 512 744.64z"}},{"type":"element","name":"path","attributes":{"d":"M144 187.68L234.4 96 512 377.76 789.6 96 880 187.68 512 561.28 144 187.68z"}}]}');
const angleDoubleDownLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$1e,
    "name": "angleDoubleDownLine"
  }), null);
};
angleDoubleDownLine.displayName = "angleDoubleDownLine";
angleDoubleDownLine.inheritAttrs = false;
const data$1d = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M279.36 512L561.28 789.6 469.44 880 96 512 469.44 144 561.28 234.4 279.36 512z"}},{"type":"element","name":"path","attributes":{"d":"M836.32 144L928 234.4 646.08 512 928 789.6 836.32 880 462.72 512 836.32 144z"}}]}');
const angleDoubleLeftLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$1d,
    "name": "angleDoubleLeftLine"
  }), null);
};
angleDoubleLeftLine.displayName = "angleDoubleLeftLine";
angleDoubleLeftLine.inheritAttrs = false;
const data$1c = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M697.6 281.6l48 48-176 176 176 176-48 48-224-224L697.6 281.6z"}},{"type":"element","name":"path","attributes":{"d":"M505.6 281.6l48 48-176 176 176 176-48 48-224-224L505.6 281.6z"}}]}');
const angleDoubleLeft = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$1c,
    "name": "angleDoubleLeft"
  }), null);
};
angleDoubleLeft.displayName = "angleDoubleLeft";
angleDoubleLeft.inheritAttrs = false;
const data$1b = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M744.64 512L462.72 789.6 554.56 880 928 512 554.56 144 462.72 234.4 744.64 512z"}},{"type":"element","name":"path","attributes":{"d":"M187.68 144L96 234.4 377.76 512 96 789.6 187.68 880 561.28 512 187.68 144z"}}]}');
const angleDoubleRightLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$1b,
    "name": "angleDoubleRightLine"
  }), null);
};
angleDoubleRightLine.displayName = "angleDoubleRightLine";
angleDoubleRightLine.inheritAttrs = false;
const data$1a = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M358.4 729.6l-48-48 176-176-176-176 48-48 224 224L358.4 729.6z"}},{"type":"element","name":"path","attributes":{"d":"M550.4 729.6l-48-48 176-176-176-176 48-48 224 224L550.4 729.6z"}}]}');
const angleDoubleRight = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$1a,
    "name": "angleDoubleRight"
  }), null);
};
angleDoubleRight.displayName = "angleDoubleRight";
angleDoubleRight.inheritAttrs = false;
const data$19 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 279.36L789.6 561.28 880 469.44 512 96 144 469.44 234.4 561.28 512 279.36z"}},{"type":"element","name":"path","attributes":{"d":"M144 836.32L234.4 928 512 646.08 789.6 928 880 836.32 512 462.72 144 836.32z"}}]}');
const angleDoubleUpLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$19,
    "name": "angleDoubleUpLine"
  }), null);
};
angleDoubleUpLine.displayName = "angleDoubleUpLine";
angleDoubleUpLine.inheritAttrs = false;
const data$18 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 256L96 704 187.04 704 512 704 836.96 704 928 704 512 256z"}}]}');
const angleDownFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$18,
    "name": "angleDownFill"
  }), null);
};
angleDownFill.displayName = "angleDownFill";
angleDownFill.inheritAttrs = false;
const data$17 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 762.56L98.72 349.28 189.28 258.72 512 581.44 834.72 258.72 925.28 349.28 512 762.56z"}}]}');
const angleDownLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$17,
    "name": "angleDownLine"
  }), null);
};
angleDownLine.displayName = "angleDownLine";
angleDownLine.inheritAttrs = false;
const data$16 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M288 448L336 400 512 576 688 400 736 448 512 672z"}}]}');
const angleDown = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$16,
    "name": "angleDown"
  }), null);
};
angleDown.displayName = "angleDown";
angleDown.inheritAttrs = false;
const data$15 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M376 504L600 280 648 328 472 504 648 680 600 728 376 504z"}}]}');
const angleLeft = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$15,
    "name": "angleLeft"
  }), null);
};
angleLeft.displayName = "angleLeft";
angleLeft.inheritAttrs = false;
const data$14 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M424 728L376 680 552 504 376 328 424 280 648 504 424 728z"}}]}');
const angleRight = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$14,
    "name": "angleRight"
  }), null);
};
angleRight.displayName = "angleRight";
angleRight.inheritAttrs = false;
const data$13 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 704L96 256 187.04 256 512 256 836.96 256 928 256 512 704z"}}]}');
const angleUpFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$13,
    "name": "angleUpFill"
  }), null);
};
angleUpFill.displayName = "angleUpFill";
angleUpFill.inheritAttrs = false;
const data$12 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 368L736 592 688 640 512 464 336 640 288 592 512 368z"}}]}');
const angleUp = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$12,
    "name": "angleUp"
  }), null);
};
angleUp.displayName = "angleUp";
angleUp.inheritAttrs = false;
const data$11 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1194.667","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"fill-rule":"evenodd","d":"M661.331584 0C696.6651477333332 0 745.9971968 20.667040213333333 770.6658858666666 45.333077333333335L978.6642816 253.3329224533333C1003.3316394666667 278.00029312 1024 327.33370112 1024 362.66728575999997L1024 1130.6680490666665C1024 1166.0002986666666 995.3336490666667 1194.6666666666665 959.9974143999999 1194.6666666666665L64 1194.6666666666665C28.666351530666663 1194.6666666666665 0 1166.0002986666666 0 1130.6680490666665L0 64C0 28.666367530666665 28.667684991999998 0 64 0L661.331584 0ZM224 522.6666666666666L138.66666666666666 522.6666666666666 138.66666666666666 818.6666666666666 309.3333333333333 818.6666666666666 309.3333333333333 605.3333333333333 224 605.3333333333333 224 522.6666666666666ZM245.33333333333331 669.3333333333333L245.33333333333331 754.6666666666666 202.66666666666666 754.6666666666666 202.66666666666666 669.3333333333333 245.33333333333331 669.3333333333333ZM309.3333333333333 437.3333333333333L224 437.3333333333333 224 522.6666666666666 309.3333333333333 522.6666666666666 309.3333333333333 437.3333333333333ZM224 352L138.66666666666666 352 138.66666666666666 437.3333333333333 224 437.3333333333333 224 352ZM309.3333333333333 266.66666666666663L224 266.66666666666663 224 352 309.3333333333333 352 309.3333333333333 266.66666666666663ZM682.6666666666666 90.66615466666667L682.6666666666666 341.33352362666665 933.3325610666667 341.33352362666665C929.3322325333334 329.9992546133333 923.3317418666667 318.66631850666664 918.6646911999999 313.9992661333333L709.9995776000001 105.33269930666667C705.3325269333333 100.66564736 693.9982634666667 94.66648490666667 682.6666666666666 90.66615466666667ZM224 181.33333333333331L138.66666666666666 181.33333333333331 138.66666666666666 266.66666666666663 224 266.66666666666663 224 181.33333333333331ZM309.3333333333333 96L224 96 224 181.33333333333331 309.3333333333333 181.33333333333331 309.3333333333333 96Z"}}]}');
const archiveFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$11,
    "name": "archiveFill"
  }), null);
};
archiveFill.displayName = "archiveFill";
archiveFill.inheritAttrs = false;
const data$10 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M416 480h320v64H416l96 96-48 48L288 512l176-176L512 384 416 480z"}}]}');
const arrowsLeft = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$10,
    "name": "arrowsLeft"
  }), null);
};
arrowsLeft.displayName = "arrowsLeft";
arrowsLeft.inheritAttrs = false;
const data$$ = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M608 480H288v64H608l-96 96 48 48L736 512l-176-176L512 384Z"}}]}');
const arrowsRight = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$$,
    "name": "arrowsRight"
  }), null);
};
arrowsRight.displayName = "arrowsRight";
arrowsRight.inheritAttrs = false;
const data$_ = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1303.273","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M664.4363636363637 0C676.8000000000001 0 688.5818181818182 4.945454545454545 697.3090909090909 13.672727272727274L697.3090909090909 13.672727272727274 1010.3272727272728 326.6909090909091C1019.0545454545455 335.41818181818184 1024 347.3454545454546 1024 359.70909090909095L1024 359.70909090909095 1024 1256.7272727272727C1024 1282.4727272727273 1003.2 1303.2727272727273 977.4545454545455 1303.2727272727273L977.4545454545455 1303.2727272727273 46.54545454545455 1303.2727272727273C20.8 1303.2727272727273 0 1282.4727272727273 0 1256.7272727272727L0 1256.7272727272727 0 46.54545454545455C0 20.8 20.8 0 46.54545454545455 0L46.54545454545455 0ZM655.2545466181818 560.2713367272728L460.52727249454546 619.8349730909091C436.9818181818182 626.5804288 417.7636361309091 651.1440616727273 417.7636361309091 674.6895173818182L417.7636361309091 880.1077015272728C417.7636361309091 880.1077015272728 403.6363636363636 870.5622434909092 372.19999976727274 875.0167924363637 326 881.6349742545455 288.5818181818182 917.016790109091 288.5818181818182 954.1804264727273 288.5818181818182 991.3440628363637 326 1014.1258798545455 372.19999976727274 1007.5076980363638 418.4 1001.016790109091 452.2545454545455 966.6531560727274 452.2545454545455 929.4895197090908L452.2545454545455 754.1076992000001C452.2545454545455 737.5622469818182 472.10908858181824 730.562243490909 472.10908858181824 730.562243490909L644.3090897454546 676.5986071272727C644.3090897454546 676.5986071272727 663.4000011636364 670.2349730909091 663.4000011636364 687.7986071272728L663.4000011636364 828.689519709091C663.4000011636364 828.689519709091 645.8363624727273 818.6349707636364 614.4 822.4531549090909 568.2000011636363 828.053154909091 530.7818170181819 862.6713367272728 530.7818170181819 899.8349730909091 530.7818170181819 936.9986094545455 568.2000011636363 960.5440651636363 614.4 954.9440651636363 660.5999988363636 949.3440651636365 698.0181829818182 914.7258833454546 698.0181829818182 877.5622469818182L698.0181829818182 590.8167912727273C698.0181829818182 567.1440616727273 678.9272715636364 553.5258810181818 655.2545466181818 560.2713367272728ZM642.9090909090909 107.34545454545454L642.9090909090909 381.0909090909091 916.6545454545455 381.0909090909091 642.9090909090909 107.34545454545454Z"}}]}');
const audioFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$_,
    "name": "audioFill"
  }), null);
};
audioFill.displayName = "audioFill";
audioFill.inheritAttrs = false;
const data$Z = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M384 289.28c103.50933333333333 18.986666666666665 183.89333333333332 99.37066666666666 202.62399999999997 201.344l5.3759999999999994 37.376c1.664 83.62666666666667 32.59733333333333 159.7013333333333 82.94399999999999 218.70933333333335 32.72533333333333 37.84533333333333 81.024 62.29333333333333 135.08266666666665 63.53066666666667 2.9013333333333335 0.128 6.0586666666666655 0.21333333333333332 9.216 0.21333333333333332 49.834666666666664 0 95.488-17.962666666666664 130.81599999999997-47.78666666666667 47.40266666666666-42.367999999999995 77.312-104.10666666666665 77.312-172.79999999999998 0-13.952-1.2373333333333334-27.562666666666665-3.584-40.831999999999994-15.786666666666665-115.62666666666667-96.29866666666666-210.43200000000002-203.73333333333335-246.91199999999998-5.8453333333333335-59.98933333333333-33.49333333333333-112.21333333333332-75.47733333333332-148.224-37.33333333333333-34.432-87.03999999999999-55.42399999999999-141.61066666666665-55.42399999999999-15.445333333333332 0-30.506666666666664 1.664-45.01333333333333 4.864-50.986666666666665 13.141333333333332-95.01866666666666 42.83733333333333-126.208 83.072-5.333333333333333 6.143999999999999-8.362666666666666 13.568-8.362666666666666 21.674666666666667 0 9.685333333333332 4.309333333333333 18.389333333333333 11.136 24.27733333333333l3.8826666666666663 0.042666666666666665c-16.21333333333333-4.053333333333333-34.901333333333326-6.613333333333333-54.10133333333333-7.04-6.101333333333333-0.38399999999999995-12.927999999999999-0.6399999999999999-19.797333333333334-0.6399999999999999s-13.696 0.21333333333333332-20.43733333333333 0.6826666666666666l0.9386666666666665-10.922666666666666c2.1333333333333333-25.813333333333333 17.194666666666667-47.70133333333334 38.656-59.30666666666666 9.173333333333332-6.015999999999999 14.933333333333332-15.872 14.933333333333332-27.093333333333334 0-17.749333333333333-14.378666666666668-32.128-32.128-32.128-6.528 0-12.629333333333332 1.9626666666666666-17.706666666666663 5.333333333333333-21.290666666666667 13.653333333333332-38.18666666666667 32.81066666666666-48.81066666666666 55.42399999999999-15.274666666666665-6.442666666666666-32.85333333333333-10.709333333333333-51.413333333333334-10.709333333333333-8.661333333333333 0-17.109333333333332 0.9386666666666665-25.258666666666663 2.6879999999999997-14.037333333333333 3.1999999999999997-24.959999999999997 16.256-24.959999999999997 31.872 0 18.090666666666664 14.677333333333332 32.768 32.768 32.768 2.474666666666667 0 4.906666666666666-0.29866666666666664 7.253333333333334-0.8106666666666666 2.1333333333333333-0.29866666666666664 4.8213333333333335-0.512 7.552-0.512 18.048 0 34.176 8.405333333333333 44.629333333333335 21.546666666666667l0.08533333333333333 0.128c-122.24000000000001 28.16-197.12 139.51999999999998-240 236.79999999999998-33.28 74.88-80.63999999999999 215.67999999999998-24.319999999999997 316.79999999999995 29.610666666666663 61.056 88.96 103.55199999999999 158.72 108.75733333333332l704.64 0.042666666666666665c17.663999999999998 0 32-14.336 32-32s-14.336-32-32-32h-704c-46.848-4.906666666666666-85.80266666666667-34.474666666666664-103.97866666666665-75.34933333333333-44.50133333333333-80.17066666666666 3.498666666666667-208.81066666666666 26.538666666666664-260.65066666666667 65.91999999999999-147.2 156.79999999999998-217.59999999999997 275.84-206.71999999999997zM480 229.12c22.826666666666668-30.976 55.296-53.63199999999999 92.88533333333334-63.744 10.069333333333333-2.1759999999999997 20.266666666666666-3.2426666666666666 30.72-3.2426666666666666 37.888 0 72.448 14.250666666666667 98.60266666666666 37.67466666666667 31.786666666666665 28.8 51.754666666666665 70.39999999999999 51.754666666666665 116.69333333333333 0 1.2373333333333334 0 2.474666666666667-0.042666666666666665 3.7119999999999997l0 32.46933333333333 24.959999999999997 3.84c95.27466666666666 23.296 167.25333333333333 101.50399999999999 180.992 198.4 1.92 10.495999999999999 2.944 21.119999999999997 2.944 32 0 52.522666666666666-23.59466666666667 99.49866666666665-60.75733333333333 130.98666666666665-21.503999999999998 16.554666666666666-48.512 26.368-77.824 26.368-4.224 0-8.448-0.21333333333333332-12.586666666666666-0.5973333333333333 0.512 0.042666666666666665 0.512 0.042666666666666665 0.512 0.042666666666666665-35.583999999999996 0-67.54133333333333-15.530666666666665-89.472-40.19199999999999-39.38133333333333-48.768-63.40266666666666-111.18933333333332-64.08533333333332-179.15733333333333l-5.76-42.410666666666664c-22.954666666666668-111.744-100.30933333333333-201.38666666666666-202.58133333333333-241.152-1.1093333333333333-0.6399999999999999 0.21333333333333332-0.5546666666666666 1.5359999999999998-0.5546666666666666 10.239999999999998 0 19.413333333333334-4.522666666666666 25.599999999999998-11.690666666666667z"}}]}');
const bk = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$Z,
    "name": "bk"
  }), null);
};
bk.displayName = "bk";
bk.inheritAttrs = false;
const data$Y = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 0c-17.919999999999998 0-32 14.08-32 32s14.08 32 32 32c247.04 0 448 200.95999999999998 448 448 0 17.919999999999998 14.08 32 32 32s32-14.08 32-32c0-282.24-229.76-512-512-512z"}}]}');
const circle = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$Y,
    "name": "circle"
  }), null);
};
circle.displayName = "circle";
circle.inheritAttrs = false;
const data$X = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M902.56 166.56L857.44 121.44 512 466.72 166.56 121.44 121.44 166.56 466.72 512 121.44 857.44 166.56 902.56 512 557.28 857.44 902.56 902.56 857.44 557.28 512 902.56 166.56z"}}]}');
const closeLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$X,
    "name": "closeLine"
  }), null);
};
closeLine.displayName = "closeLine";
closeLine.inheritAttrs = false;
const data$W = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zM670.4 625.1l-45.3 45.3L512 557.3 398.9 670.4l-45.3-45.3L466.7 512 353.6 398.9l45.3-45.3L512 466.7l113.1-113.1 45.3 45.3L557.3 512 670.4 625.1z"}}]}');
const close$1 = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$W,
    "name": "close"
  }), null);
};
close$1.displayName = "close";
close$1.inheritAttrs = false;
const data$V = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M1011.1999999999999 489.59999999999997l-224-224c-12.799999999999999-12.799999999999999-32.64-12.799999999999999-45.44 0s-12.799999999999999 32.64 0 45.44l201.59999999999997 200.95999999999998-201.59999999999997 201.59999999999997c-12.799999999999999 12.799999999999999-12.799999999999999 32.64 0 45.44 6.3999999999999995 6.3999999999999995 14.719999999999999 9.6 22.4 9.6s16.64-3.1999999999999997 22.4-9.6l224-224c12.799999999999999-12.799999999999999 12.799999999999999-33.28 0.6399999999999999-45.44z"}},{"type":"element","name":"path","attributes":{"d":"M282.24 265.59999999999997c-12.799999999999999-12.799999999999999-32.64-12.799999999999999-45.44 0l-224 224c-12.799999999999999 12.799999999999999-12.799999999999999 32.64 0 45.44l224 224c6.3999999999999995 5.76 14.719999999999999 8.959999999999999 23.04 8.959999999999999s16.64-3.1999999999999997 22.4-9.6c12.799999999999999-12.799999999999999 12.799999999999999-32.64 0-45.44l-201.59999999999997-200.95999999999998 201.59999999999997-201.59999999999997c12.159999999999998-12.159999999999998 12.159999999999998-32.64 0-44.8z"}},{"type":"element","name":"path","attributes":{"d":"M616.3199999999999 129.27999999999997c-16.64-5.119999999999999-34.56 5.119999999999999-39.04 22.4l-192 704c-4.4799999999999995 17.28 5.119999999999999 34.56 22.4 39.04 2.5599999999999996 0.6399999999999999 5.76 1.2799999999999998 8.32 1.2799999999999998 14.08 0 26.88-9.6 30.72-23.68l192-704c4.4799999999999995-16.64-5.119999999999999-34.56-22.4-39.04z"}}]}');
const code = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$V,
    "name": "code"
  }), null);
};
code.displayName = "code";
code.inheritAttrs = false;
const data$U = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M608 512A96 96 0 0 1 512 608 96 96 0 0 1 416 512 96 96 0 0 1 608 512z"}},{"type":"element","name":"path","attributes":{"d":"M860.8 558.4c4.8-30.4 4.8-62.4 0-92.8l67.2-57.6c9.6-8 14.4-22.4 9.6-35.2-19.2-59.2-51.2-115.2-92.8-161.6-6.4-6.4-14.4-11.2-24-11.2-3.2 0-8 0-11.2 1.6l-83.2 30.4c-24-19.2-52.8-35.2-81.6-46.4l-16-86.4c-1.6-12.8-12.8-22.4-25.6-25.6-60.8-12.8-124.8-12.8-185.6 0-12.8 3.2-22.4 12.8-24 25.6l-16 86.4c-28.8 11.2-56 27.2-81.6 46.4l-83.2-30.4c-3.2-1.6-6.4-1.6-11.2-1.6-9.6 0-17.6 3.2-24 11.2-41.6 46.4-73.6 100.8-92.8 161.6-4.8 12.8 0 27.2 9.6 35.2l67.2 57.6C160 496 160 528 163.2 558.4L96 616c-9.6 8-14.4 22.4-9.6 35.2 19.2 59.2 51.2 115.2 92.8 161.6 6.4 6.4 14.4 11.2 24 11.2 3.2 0 8 0 11.2-1.6l83.2-30.4c24 19.2 52.8 35.2 81.6 46.4l16 86.4c1.6 12.8 12.8 22.4 25.6 25.6 60.8 12.8 124.8 12.8 185.6 0 12.8-3.2 22.4-12.8 25.6-25.6l16-86.4c28.8-11.2 56-27.2 81.6-46.4l83.2 30.4c3.2 1.6 6.4 1.6 11.2 1.6 9.6 0 17.6-3.2 24-11.2 41.6-46.4 73.6-100.8 92.8-161.6 3.2-12.8 0-27.2-11.2-35.2L860.8 558.4zM512 672c-88 0-160-72-160-160s72-160 160-160 160 72 160 160S600 672 512 672z"}}]}');
const cogShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$U,
    "name": "cogShape"
  }), null);
};
cogShape.displayName = "cogShape";
cogShape.inheritAttrs = false;
const data$T = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M496 216l-76.32 76.32 152.64 152.8H64v101.76H572.16l-152.48 152.8L496 776 775.52 496Zm362.4 0v560H960v-560Z"}}]}');
const collapseLeft = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$T,
    "name": "collapseLeft"
  }), null);
};
collapseLeft.displayName = "collapseLeft";
collapseLeft.inheritAttrs = false;
const data$S = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M864 128H288c-17.6 0-32 14.4-32 32v96h-96c-17.6 0-32 14.4-32 32v576c0 17.6 14.4 32 32 32h576c17.6 0 32-14.4 32-32v-96h96c17.6 0 32-14.4 32-32V160C896 142.4 881.6 128 864 128zM704 704v64 64H192V320h64 64 384V704zM832 704h-64V288c0-17.6-14.4-32-32-32H320v-64h512V704z"}},{"type":"element","name":"path","attributes":{"d":"M275.2 419.2H611.2V483.2H275.2z"}},{"type":"element","name":"path","attributes":{"d":"M272 544H608V608H272z"}},{"type":"element","name":"path","attributes":{"d":"M272 672H608V736H272z"}}]}');
const copy = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$S,
    "name": "copy"
  }), null);
};
copy.displayName = "copy";
copy.inheritAttrs = false;
const data$R = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1170.2857142857142","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M176.27428571428572 248.68571428571425c100.74209523809523 24.673523809523807 216.40533333333332 38.863238095238096 335.335619047619 38.863238095238096s234.5935238095238-14.14095238095238 345.38057142857144-40.86247619047619c106.30095238095238-27.209142857142858 167.00952380952378-74.02057142857143 167.00952380952378-100.35199999999999 0-49.00571428571428-180.66285714285715-146.28571428571428-512-146.28571428571428s-512 95.81714285714285-512 146.28571428571428c0 26.33142857142857 60.70857142857143 73.14285714285714 176.27428571428572 102.4z"}},{"type":"element","name":"path","attributes":{"d":"M856.5028571428571 923.7942857142857c-99.2304761904762 25.6-213.13828571428573 40.27733333333333-330.45942857142853 40.27733333333333-4.924952380952381 0-9.849904761904762-0.04876190476190476-14.774857142857142-0.09752380952380953-3.4620952380952374 0.04876190476190476-8.387047619047618 0.09752380952380953-13.360761904761905 0.09752380952380953-117.32114285714286 0-231.18019047619046-14.677333333333332-339.87047619047615-42.37409523809524-113.37142857142858 37.156571428571425-157.98857142857142 81.77371428571428-157.98857142857142 102.25371428571428 0 49.00571428571428 180.66285714285715 146.28571428571428 512 146.28571428571428s512-95.08571428571427 512-146.28571428571428c0-20.479999999999997-44.61714285714286-65.09714285714286-167.49714285714285-100.2057142857143z"}},{"type":"element","name":"path","attributes":{"d":"M856.5028571428571 626.8342857142857c-103.37523809523809 25.063619047619046-222.0617142857143 39.44838095238095-344.16152380952377 39.44838095238095s-240.73752380952382-14.384761904761904-354.4990476190476-41.54514285714286c-113.27390476190476 37.20533333333333-157.8910476190476 82.55390476190476-157.8910476190476 106.69104761904762 0 49.00571428571428 180.66285714285715 146.28571428571428 512 146.28571428571428s512-95.08571428571427 512-146.28571428571428c0-24.137142857142855-44.61714285714286-69.48571428571428-167.49714285714285-104.5942857142857z"}},{"type":"element","name":"path","attributes":{"d":"M856.5028571428571 332.0685714285714h-13.165714285714285c-99.42552380952381 25.40495238095238-213.62590476190476 40.03352380952381-331.23961904761904 40.22857142857142-3.072 0-6.534095238095238 0.04876190476190476-10.04495238095238 0.04876190476190476-114.00533333333333 0-224.88990476190475-13.604571428571429-330.9958095238095-39.30209523809524l-2.8769523809523805 1.9504761904761905c-123.61142857142858 30.72-168.22857142857143 77.53142857142858-168.22857142857143 99.47428571428571 0 49.00571428571428 180.66285714285715 146.28571428571428 512 146.28571428571428s512-95.81714285714285 512-146.28571428571428c0-21.942857142857143-44.61714285714286-68.7542857142857-167.49714285714285-102.4z"}}]}');
const dataShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$R,
    "name": "dataShape"
  }), null);
};
dataShape.displayName = "dataShape";
dataShape.inheritAttrs = false;
const data$Q = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M928 224H672v-64c0-35.2-28.8-64-64-64H416c-35.2 0-64 28.8-64 64v64H96v64h112v576c0 35.2 28.8 64 64 64h480c35.2 0 64-28.8 64-64V288h112V224zM432 160h160c9.6 0 16 6.4 16 16v48H416v-48C416 166.4 422.4 160 432 160zM736 864H288c-9.6 0-16-6.4-16-16V288h480v560C752 857.6 745.6 864 736 864z"}},{"type":"element","name":"path","attributes":{"d":"M576 400H640V752H576V400z"}},{"type":"element","name":"path","attributes":{"d":"M384 400H448V752H384V400z"}}]}');
const del = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$Q,
    "name": "del"
  }), null);
};
del.displayName = "del";
del.inheritAttrs = false;
const data$P = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1097.143","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M698.6979072 34.411393901714284C704.0406784 39.04304329142857 707.1085714285714 45.76605271771429 707.1085714285714 52.83693527771428L707.1085714285714 1069.3276013714285C707.1085714285714 1076.3886738285712 704.0452278857143 1083.1024822857141 698.7138852571428 1087.7323337142855 693.3825389714286 1092.362185142857 686.3058176 1094.453295542857 679.3142857142858 1093.4647442285714L66.27961892571427 1005.9371263999999C42.24804234971429 1002.5144795428571 24.393142857142855 981.9369252571428 24.393142857142855 957.6628406857142L24.393142857142855 164.50169709714285C24.393142857142855 140.22761252571428 42.24804234971429 119.65005750857142 66.27961892571427 116.22741138285714L66.32838107428572 116.22741138285714 679.2655250285715 28.699792423131427C686.2647552000001 27.695727027199997 693.355136 29.77974452662857 698.6979072 34.411393901714284ZM950.9180964571428 122.22512566857142C977.8485504 122.22512566857142 999.68 144.05657417142857 999.68 170.9870306742857L999.68 951.1775049142856C999.68 978.1079625142856 977.8485504 999.9394121142856 950.9180964571428 999.9394121142856L755.8704749714285 999.9394121142856 755.8704749714285 902.4156013714285 902.1561892571428 902.4156013714285 902.1561892571428 219.7489353142857 755.8704749714285 219.7489353142857 755.8704749714285 122.22512566857142 950.9180964571428 122.22512566857142ZM268.25142857142856 366.03464959999997L170.72761892571427 366.03464959999997 170.72761892571427 756.1298870857141 268.25142857142856 756.1298870857141 365.7752382171428 658.606076342857 463.2990464 756.1298870857141 560.8228571428571 756.1298870857141 560.8228571428571 366.03464959999997 463.2990464 366.03464959999997 463.2990464 609.3077906285713 365.7752382171428 512.3203620571429 268.73904749714285 609.8441727999999 268.25142857142856 366.03464959999997Z"}}]}');
const docFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$P,
    "name": "docFill"
  }), null);
};
docFill.displayName = "docFill";
docFill.inheritAttrs = false;
const data$O = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M704 352l48 48-304 304-176-176 48-48 128 128z"}}]}');
const done = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$O,
    "name": "done"
  }), null);
};
done.displayName = "done";
done.inheritAttrs = false;
const data$N = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 768c-6.3999999999999995 0-13.44-2.5599999999999996-18.56-8.32l-356.48-384c-8.32-8.959999999999999-10.879999999999999-23.04-7.04-35.199999999999996s14.08-20.479999999999997 25.599999999999998-20.479999999999997h712.96c11.52 0 21.119999999999997 8.32 25.599999999999998 20.479999999999997s1.2799999999999998 26.24-7.04 35.199999999999996l-356.48 384c-5.119999999999999 5.76-12.159999999999998 8.32-18.56 8.32z"}}]}');
const downShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$N,
    "name": "downShape"
  }), null);
};
downShape.displayName = "downShape";
downShape.inheritAttrs = false;
const data$M = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M288 448L336 400 512 576 688 400 736 448 512 672z"}}]}');
const downSmall = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$M,
    "name": "downSmall"
  }), null);
};
downSmall.displayName = "downSmall";
downSmall.inheritAttrs = false;
const data$L = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M609.6 201.6L203.2 609.6 203.2 710.4 304 710.4 712 304z"}},{"type":"element","name":"path","attributes":{"d":"M128 800H896V896H128z"}},{"type":"element","name":"path","attributes":{"d":"M683.6717566325265 128.04165515828316L785.4933559547056 229.86680878681256 740.2377321198037 275.1208529300033 638.4161327976245 173.2956993014738z"}}]}');
const editLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$L,
    "name": "editLine"
  }), null);
};
editLine.displayName = "editLine";
editLine.inheritAttrs = false;
const data$K = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M320 512c0 35.199999999999996-28.8 64-64 64s-64-28.8-64-64c0-35.199999999999996 28.8-64 64-64s64 28.8 64 64zM512 448c-35.199999999999996 0-64 28.8-64 64s28.8 64 64 64 64-28.8 64-64c0-35.199999999999996-28.8-64-64-64zM768 448c-35.199999999999996 0-64 28.8-64 64s28.8 64 64 64 64-28.8 64-64c0-35.199999999999996-28.8-64-64-64z"}}]}');
const ellipsis$1 = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$K,
    "name": "ellipsis"
  }), null);
};
ellipsis$1.displayName = "ellipsis";
ellipsis$1.inheritAttrs = false;
const data$J = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M885.76 840.64l-148.96-149.12a344.16 344.16 0 1 0-45.28 45.28l149.12 148.96a32 32 0 1 0 45.12-45.12ZM472 752A280 280 0 1 1 752 472 280.32 280.32 0 0 1 472 752Z"}},{"type":"element","name":"path","attributes":{"d":"M576 448H496V368a32 32 0 0 0-64 0v80H352a32 32 0 0 0 0 64h80v80a32 32 0 0 0 64 0V512h80a32 32 0 0 0 0-64Z"}}]}');
const enlargeLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$J,
    "name": "enlargeLine"
  }), null);
};
enlargeLine.displayName = "enlargeLine";
enlargeLine.inheritAttrs = false;
const data$I = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"fill-rule":"evenodd","d":"M452.7573333333333 510.91200000000003L225.83338666666668 737.8346666666666 286.1730133333333 798.1738666666666 513.0965333333334 571.2511999999999 739.8399999999999 797.9946666666666 797.9946666666666 739.8399999999999 571.2511999999999 513.0965333333334 798.1738666666666 286.1730133333333 737.8346666666666 225.83338666666668 510.91200000000003 452.7573333333333 283.9867733333333 225.83338666666668 225.83338666666668 283.9867733333333 452.7573333333333 510.91200000000003Z","clip-rule":"evenodd"}}]}');
const error = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$I,
    "name": "error"
  }), null);
};
error.displayName = "error";
error.inheritAttrs = false;
const data$H = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1097.143","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M698.6369535999999 21.90055387428571C703.9797248 26.53220315428571 707.0476178285713 33.25521261714285 707.0476178285713 40.326095360000004L707.0476178285713 1056.8167606857141C707.0476178285713 1063.8778368 703.9842779428571 1070.5916416 698.6529316571427 1075.2214930285713 693.3215890285713 1079.8513481142857 686.2448676571429 1081.9424548571428 679.2533321142857 1080.953903542857L66.21866678857141 993.4262857142858C42.18708992 990.0036388571428 24.332190354285718 969.4260845714285 24.332190354285718 945.152L24.332190354285718 151.99085714285712C24.332190354285718 127.71677257142855 42.18708992 107.13921718857142 66.21866678857141 103.71657142857141L66.26742857142857 103.71657142857141 679.2045714285714 16.188952502857138C686.2038015999999 15.18488685714286 693.2941824 17.26890459428571 698.6369535999999 21.90055387428571ZM950.8571428571428 109.71428571428571C977.7876004571428 109.71428571428571 999.6190463999999 131.54573421714286 999.6190463999999 158.4761903542857L999.6190463999999 938.6666678857142C999.6190463999999 965.5971218285714 977.7876004571428 987.4285714285713 950.8571428571428 987.4285714285713L755.8095250285714 987.4285714285713 755.8095250285714 889.9047606857142 902.0952393142857 889.9047606857142 902.0952393142857 207.23809536 755.8095250285714 207.23809536 755.8095250285714 109.71428571428571 950.8571428571428 109.71428571428571ZM287.69523821714284 353.52381074285717L170.6666667885714 353.52381074285717 307.2 548.5714285714286 170.6666667885714 743.6190463999999 287.69523821714284 743.6190463999999 365.71428571428567 632.1493321142857 443.7333321142857 743.6190463999999 560.7619035428571 743.6190463999999 424.2285714285714 548.5714285714286 560.7619035428571 353.52381074285717 443.7333321142857 353.52381074285717 365.71428571428567 464.9935250285714 287.69523821714284 353.52381074285717Z"}}]}');
const excelFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$H,
    "name": "excelFill"
  }), null);
};
excelFill.displayName = "excelFill";
excelFill.inheritAttrs = false;
const data$G = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 64C264 64 64 264 64 512s200 448 448 448 448-200 448-448S760 64 512 64zM512 768c-27.2 0-48-20.8-48-48s20.8-48 48-48c27.2 0 48 20.8 48 48S539.2 768 512 768zM560 308.8L544 608c0 17.6-14.4 32-32 32-17.6 0-32-14.4-32-32l-16-299.2c0-1.6 0-3.2 0-4.8 0-27.2 20.8-48 48-48 27.2 0 48 20.8 48 48C560 305.6 560 307.2 560 308.8z"}}]}');
const exclamationCircleShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$G,
    "name": "exclamationCircleShape"
  }), null);
};
exclamationCircleShape.displayName = "exclamationCircleShape";
exclamationCircleShape.inheritAttrs = false;
const data$F = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 384a128 128 0 1 0 128 128A128 128 0 0 0 512 384Zm0 192a64 64 0 1 1 64-64A64 64 0 0 1 512 576Z"}},{"type":"element","name":"path","attributes":{"d":"M512 240C264.64 240 64 512 64 512S264.64 784 512 784 960 512 960 512 759.36 240 512 240Zm0 480C352 720 208 580.96 147.04 512 208 442.88 352 304 512 304s304 139.04 364.96 208C816 581.12 672 720 512 720Z"}}]}');
const eye = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$F,
    "name": "eye"
  }), null);
};
eye.displayName = "eye";
eye.inheritAttrs = false;
const data$E = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M128 384L192 384 192 192 384 192 384 128 128 128 128 384Z"}},{"type":"element","name":"path","attributes":{"d":"M640 128L640 192 832 192 832 384 896 384 896 128 640 128Z"}},{"type":"element","name":"path","attributes":{"d":"M192 640L128 640 128 896 384 896 384 832 192 832 192 640Z"}},{"type":"element","name":"path","attributes":{"d":"M832 832L640 832 640 896 896 896 896 640 832 640 832 832Z"}}]}');
const filliscreenLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$E,
    "name": "filliscreenLine"
  }), null);
};
filliscreenLine.displayName = "filliscreenLine";
filliscreenLine.inheritAttrs = false;
const data$D = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M928 320h-35.199999999999996c-15.402666666666665-73.55733333333333-79.744-128-156.75733333333332-128 0 0-0.042666666666666665 0-0.042666666666666665 0h-288v-32c0-53.034666666666666-42.96533333333333-96-96-96h-256c-53.034666666666666 0-96 42.96533333333333-96 96v640c0 88.36266666666667 71.63733333333333 160 160 160h704c0.38399999999999995 0 0.8533333333333333 0 1.3226666666666667 0 51.199999999999996 0 92.88533333333334-40.61866666666666 94.67733333333332-91.34933333333333l64-452.65066666666667c0-53.034666666666666-42.96533333333333-96-96-96zM64 800v-640c0-17.663999999999998 14.336-32 32-32h256c17.663999999999998 0 32 14.336 32 32v64c0 17.663999999999998 14.336 32 32 32h320c41.42933333333333 0.128 76.71466666666666 26.496 90.02666666666666 63.31733333333333l-538.0266666666666 0.6826666666666666c-0.38399999999999995 0-0.8533333333333333 0-1.3226666666666667 0-51.199999999999996 0-92.88533333333334 40.61866666666666-94.67733333333332 91.34933333333333l-64 452.65066666666667c0.128 9.856 1.7493333333333334 19.328 4.650666666666666 28.202666666666666-39.97866666666667-12.842666666666666-68.47999999999999-49.151999999999994-68.65066666666667-92.16zM896 864c0 17.663999999999998-14.336 32-32 32h-640c-0.08533333333333333 0-0.21333333333333332 0-0.29866666666666664 0-16.08533333333333 0-29.39733333333333-11.861333333333334-31.658666666666665-27.349333333333334l64-452.65066666666667c0-17.663999999999998 14.336-32 32-32h640c0.08533333333333333 0 0.21333333333333332 0 0.29866666666666664 0 16.08533333333333 0 29.39733333333333 11.861333333333334 31.658666666666665 27.349333333333334z"}}]}');
const folderOpen = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$D,
    "name": "folderOpen"
  }), null);
};
folderOpen.displayName = "folderOpen";
folderOpen.inheritAttrs = false;
const data$C = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M202.24 421.11999999999995c1.792-56.23466666666667 47.78666666666667-101.12 104.27733333333333-101.12 0.46933333333333327 0 0.9386666666666665 0 1.408 0l568.2346666666666 0c0.17066666666666666 0 0.38399999999999995 0 0.5973333333333333 0 7.082666666666666 0 12.799999999999999-5.717333333333333 12.799999999999999-12.799999999999999 0-1.3653333333333333-0.21333333333333332-2.6879999999999997-0.6399999999999999-3.925333333333333-21.205333333333332-65.024-81.40799999999999-111.27466666666666-152.40533333333332-111.27466666666666-0.17066666666666666 0-0.38399999999999995 0-0.5546666666666666 0h-287.9573333333333v-32c0-53.034666666666666-42.96533333333333-96-96-96h-256c-53.034666666666666 0-96 42.96533333333333-96 96v640c0 0.9813333333333333-0.042666666666666665 2.0906666666666665-0.042666666666666665 3.2426666666666666 0 77.056 54.44266666666667 141.39733333333334 126.976 156.58666666666664 0.896-1.92 0.8106666666666666-4.394666666666666 0.8106666666666666-6.8693333333333335s0.08533333333333333-4.949333333333334 0.256-7.381333333333332z"}},{"type":"element","name":"path","attributes":{"d":"M960 384h-652.16c-22.954666666666668 0-41.599999999999994 18.645333333333333-41.599999999999994 41.599999999999994l-74.24 521.5999999999999c-0.42666666666666664 1.92-0.6399999999999999 4.1386666666666665-0.6399999999999999 6.3999999999999995s0.256 4.4799999999999995 0.6826666666666666 6.613333333333333l703.9573333333333-0.21333333333333332c35.327999999999996 0 64-28.672 64-64l64-448c0-35.327999999999996-28.672-64-64-64z"}}]}');
const folderShapeOpen = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$C,
    "name": "folderShapeOpen"
  }), null);
};
folderShapeOpen.displayName = "folderShapeOpen";
folderShapeOpen.inheritAttrs = false;
const data$B = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M864 192h-416v-32c0-53.034666666666666-42.96533333333333-96-96-96h-256c-53.034666666666666 0-96 42.96533333333333-96 96v640c0 88.36266666666667 71.63733333333333 160 160 160h704c88.36266666666667 0 160-71.63733333333333 160-160v-448c0-88.36266666666667-71.63733333333333-160-160-160z"}}]}');
const folderShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$B,
    "name": "folderShape"
  }), null);
};
folderShape.displayName = "folderShape";
folderShape.inheritAttrs = false;
const data$A = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M864 960h-704c-88.36266666666667 0-160-71.63733333333333-160-160v-640c0-53.034666666666666 42.96533333333333-96 96-96h256c53.034666666666666 0 96 42.96533333333333 96 96v32h416c88.36266666666667 0 160 71.63733333333333 160 160v448c0 88.36266666666667-71.63733333333333 160-160 160zM96 128c-17.663999999999998 0-32 14.336-32 32v640c0 53.034666666666666 42.96533333333333 96 96 96h704c53.034666666666666 0 96-42.96533333333333 96-96v-448c0-53.034666666666666-42.96533333333333-96-96-96h-448c-17.663999999999998 0-32-14.336-32-32v-64c0-17.663999999999998-14.336-32-32-32z"}}]}');
const folder = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$A,
    "name": "folder"
  }), null);
};
folder.displayName = "folder";
folder.inheritAttrs = false;
const data$z = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M860.8 128H163.2a32 32 0 0 0-27.36 52l295.2 336 0.96 0V896l160-82.72V516.8l0.96 0 295.2-336A32 32 0 0 0 860.8 128Z"}}]}');
const funnel = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$z,
    "name": "funnel"
  }), null);
};
funnel.displayName = "funnel";
funnel.inheritAttrs = false;
const data$y = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 64C264 64 64 264 64 512c0 57.6 11.2 113.6 32 166.4V896c0 17.6 14.4 32 32 32h217.6C576 1019.2 836.8 908.8 928 678.4S908.8 187.2 678.4 96C625.6 75.2 569.6 64 512 64zM500.8 721.6c-27.2 0-48-20.8-48-48s20.8-48 48-48c27.2 0 48 20.8 48 48S528 721.6 500.8 721.6zM587.2 507.2c-36.8 20.8-48 35.2-48 62.4v14.4H464v-16c-3.2-44.8 11.2-70.4 51.2-92.8 36.8-22.4 48-35.2 48-60.8s-20.8-44.8-52.8-44.8c-28.8-1.6-52.8 19.2-56 48 0 1.6 0 1.6 0 3.2h-76.8c1.6-70.4 49.6-118.4 136-118.4 80 0 132.8 44.8 132.8 110.4C648 454.4 627.2 484.8 587.2 507.2z"}}]}');
const helpDocumentFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$y,
    "name": "helpDocumentFill"
  }), null);
};
helpDocumentFill.displayName = "helpDocumentFill";
helpDocumentFill.inheritAttrs = false;
const data$x = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 64C264 64 64 264 64 512s200 448 448 448 448-200 448-448S760 64 512 64zM500.8 721.6c-27.2 0-48-20.8-48-48s20.8-48 48-48c27.2 0 48 20.8 48 48S528 721.6 500.8 721.6zM587.2 507.2c-36.8 20.8-48 35.2-48 62.4v14.4H464v-16c-3.2-44.8 11.2-70.4 51.2-92.8 36.8-22.4 48-35.2 48-60.8s-20.8-44.8-52.8-44.8c-28.8-1.6-52.8 19.2-56 48 0 1.6 0 1.6 0 3.2h-76.8c1.6-70.4 49.6-118.4 136-118.4 80 0 132.8 44.8 132.8 110.4C648 454.4 627.2 484.8 587.2 507.2z"}}]}');
const helpFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$x,
    "name": "helpFill"
  }), null);
};
helpFill.displayName = "helpFill";
helpFill.inheritAttrs = false;
const data$w = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 128c212.8 0 384 171.2 384 384S724.8 896 512 896 128 724.8 128 512 299.2 128 512 128M512 64C264 64 64 264 64 512s200 448 448 448 448-200 448-448S760 64 512 64z"}},{"type":"element","name":"path","attributes":{"d":"M548.8 673.6A48 48 0 0 1 500.8 721.6 48 48 0 0 1 452.8 673.6 48 48 0 0 1 548.8 673.6z"}},{"type":"element","name":"path","attributes":{"d":"M513.6 302.4c80 0 132.8 44.8 132.8 110.4 0 41.6-20.8 72-60.8 96-40 24-48 35.2-48 62.4v14.4H464v-16c-3.2-44.8 11.2-70.4 51.2-92.8 36.8-22.4 48-35.2 48-60.8s-20.8-44.8-52.8-44.8c-28.8-1.6-52.8 19.2-56 48 0 1.6 0 1.6 0 3.2h-76.8C377.6 352 427.2 302.4 513.6 302.4z"}}]}');
const help = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$w,
    "name": "help"
  }), null);
};
help.displayName = "help";
help.inheritAttrs = false;
const data$v = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1303.273","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M664.4363636363637 0C676.8000000000001 0 688.5818181818182 4.945454545454545 697.3090909090909 13.672727272727274L697.3090909090909 13.672727272727274 1010.3272727272728 326.6909090909091C1019.0545454545455 335.41818181818184 1024 347.3454545454546 1024 359.70909090909095L1024 359.70909090909095 1024 1256.7272727272727C1024 1282.4727272727273 1003.2 1303.2727272727273 977.4545454545455 1303.2727272727273L977.4545454545455 1303.2727272727273 46.54545454545455 1303.2727272727273C20.8 1303.2727272727273 0 1282.4727272727273 0 1256.7272727272727L0 1256.7272727272727 0 46.54545454545455C0 20.8 20.8 0 46.54545454545455 0L46.54545454545455 0ZM637.6727272727272 744.7272727272727L474.76363636363635 954.1818181818182 358.40000000000003 814.5454545454546 195.4909090909091 1024 847.1272727272727 1024 637.6727272727272 744.7272727272727ZM465.4545454545455 558.5454545454545C414.041856 558.5454545454545 372.3636363636364 600.2236741818182 372.3636363636364 651.6363636363636 372.3636363636364 703.0490530909091 414.041856 744.7272727272727 465.4545454545455 744.7272727272727 516.8672349090909 744.7272727272727 558.5454545454545 703.0490530909091 558.5454545454545 651.6363636363636 558.5454545454545 600.2236741818182 516.8672349090909 558.5454545454545 465.4545454545455 558.5454545454545ZM642.9090909090909 107.34545454545454L642.9090909090909 381.0909090909091 916.6545454545455 381.0909090909091 642.9090909090909 107.34545454545454Z"}}]}');
const imageFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$v,
    "name": "imageFill"
  }), null);
};
imageFill.displayName = "imageFill";
imageFill.inheritAttrs = false;
const data$u = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M752 512A176 176 0 1 0 928 688 176 176 0 0 0 752 512Zm0 299.2a30.88 30.88 0 1 1 30.88-30.88A30.72 30.72 0 0 1 752 811.2Zm16.96-92.32a17.12 17.12 0 0 1-33.92 0s-13.76-118.72-13.76-123.2a30.88 30.88 0 1 1 61.6 0C782.88 600.16 768.96 718.88 768.96 718.88Z"}},{"type":"element","name":"path","attributes":{"d":"M800 176H480l-44.32 89.44-23.36 89.44-70.24 85.6 30.88-85.6-46.88-89.44L336 240h0v-0.96L359.52 176H160a96 96 0 0 0-96 96V752a96 96 0 0 0 96 96H573.44A238.88 238.88 0 0 1 512 688a243.2 243.2 0 0 1 8.16-61.44L356.8 519.84a46.72 46.72 0 0 0-70.72 2.56L128 656V272a32 32 0 0 1 32-32h118.4L272 283.36l70.08 71.52L327.36 480l108.32-107.36L530.4 240H800a32 32 0 0 1 32 32V461.92A241.92 241.92 0 0 1 896 496V272A96 96 0 0 0 800 176Z"}},{"type":"element","name":"path","attributes":{"d":"M720 400A80 80 0 0 1 640 480 80 80 0 0 1 560 400 80 80 0 0 1 720 400z"}}]}');
const imgError = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$u,
    "name": "imgError"
  }), null);
};
imgError.displayName = "imgError";
imgError.inheritAttrs = false;
const data$t = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M864 176H160a96 96 0 0 0-96 96V752a96 96 0 0 0 96 96H864a96 96 0 0 0 96-96V272A96 96 0 0 0 864 176ZM128 272a32 32 0 0 1 32-32H864a32 32 0 0 1 32 32V688l-144-114.72a57.76 57.76 0 0 0-56.32 0L592 672 356.8 439.84a46.72 46.72 0 0 0-70.72 2.56L128 656Z"}},{"type":"element","name":"path","attributes":{"d":"M752 400A96 96 0 0 1 656 496 96 96 0 0 1 560 400 96 96 0 0 1 752 400z"}}]}');
const imgPlacehoulder = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$t,
    "name": "imgPlacehoulder"
  }), null);
};
imgPlacehoulder.displayName = "imgPlacehoulder";
imgPlacehoulder.inheritAttrs = false;
const data$s = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 64C264 64 64 264 64 512s200 448 448 448 448-200 448-448S760 64 512 64zM512 896C299.2 896 128 724.8 128 512S299.2 128 512 128s384 171.2 384 384S724.8 896 512 896z"}},{"type":"element","name":"path","attributes":{"d":"M494.4 403.2c-28.8 6.4-56 20.8-76.8 41.6-24 22.4 1.6 44.8 16 27.2 9.6-12.8 24-22.4 40-28.8 11.2-1.6 17.6 1.6 19.2 9.6 1.6 14.4 0 27.2-4.8 41.6-4.8 19.2-14.4 51.2-25.6 94.4-22.4 76.8-33.6 124.8-30.4 140.8 3.2 17.6 12.8 32 28.8 41.6 17.6 8 38.4 9.6 57.6 4.8 30.4-6.4 57.6-22.4 80-44.8 25.6-25.6-3.2-43.2-17.6-28.8-9.6 12.8-24 22.4-40 25.6-14.4 3.2-22.4-3.2-25.6-16-1.6-14.4 1.6-28.8 6.4-41.6 40-136 57.6-212.8 52.8-232-3.2-14.4-12.8-27.2-25.6-33.6C532.8 398.4 512 398.4 494.4 403.2z"}},{"type":"element","name":"path","attributes":{"d":"M608 304A48 48 0 0 1 560 352 48 48 0 0 1 512 304 48 48 0 0 1 608 304z"}}]}');
const infoLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$s,
    "name": "infoLine"
  }), null);
};
infoLine.displayName = "infoLine";
infoLine.inheritAttrs = false;
const data$r = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 64A448 448 0 1 1 64 512 448 448 0 0 1 512 64ZM493.92 402.56a156 156 0 0 0-77.12 42.24c-24.32 22.88 1.44 44 16 27.52a82.56 82.56 0 0 1 40.48-28.16c11.04-2.24 17.6 1.28 19.36 10.4A118.88 118.88 0 0 1 488.16 496q-7.2 29.76-26.4 93.92-34.72 116.32-30.08 140.8a54.72 54.72 0 0 0 28.8 40.96 88 88 0 0 0 58.4 5.12 161.76 161.76 0 0 0 80-45.44c25.76-24.96-3.52-43.04-17.28-28a76.32 76.32 0 0 1-39.36 26.08c-14.24 2.88-22.72-2.4-25.28-16A104.96 104.96 0 0 1 522.88 672Q582.24 469.12 576 439.84a46.24 46.24 0 0 0-25.6-33.6A89.6 89.6 0 0 0 493.92 402.56Zm67.84-39.84A49.92 49.92 0 1 0 512 312.96 49.76 49.76 0 0 0 561.76 362.72Z"}}]}');
const info = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$r,
    "name": "info"
  }), null);
};
info.displayName = "info";
info.inheritAttrs = false;
const data$q = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M680.96 129.92c-14.08-3.84-30.08-1.2799999999999998-40.31999999999999 7.04l-439.03999999999996 356.48c-12.799999999999999 10.239999999999998-12.799999999999999 26.88 0 37.12l439.03999999999996 356.48c7.04 5.76 16.64 8.959999999999999 26.88 8.959999999999999 4.4799999999999995 0 8.959999999999999-0.6399999999999999 13.44-1.92 14.08-3.84 23.04-14.08 23.04-25.599999999999998v-712.96c0-11.52-8.959999999999999-21.759999999999998-23.04-25.599999999999998z"}}]}');
const leftShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$q,
    "name": "leftShape"
  }), null);
};
leftShape.displayName = "leftShape";
leftShape.inheritAttrs = false;
const data$p = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M192 512a320 320 0 1 0 76.96-208H352v64H160V176h64v82.08A384 384 0 1 1 128 512Z"}}]}');
const leftTurnLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$p,
    "name": "leftTurnLine"
  }), null);
};
leftTurnLine.displayName = "leftTurnLine";
leftTurnLine.inheritAttrs = false;
const data$o = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M886.56 841.28l-149.12-149.12a344.64 344.64 0 1 0-45.28 45.28l149.12 149.12A32 32 0 0 0 864 896a32 32 0 0 0 22.56-54.72ZM472.32 752A280.32 280.32 0 1 1 752 472.32 280.64 280.64 0 0 1 472.32 752Z"}},{"type":"element","name":"path","attributes":{"d":"M576 448H352a32 32 0 0 0 0 64H576a32 32 0 0 0 0-64Z"}}]}');
const narrowLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$o,
    "name": "narrowLine"
  }), null);
};
narrowLine.displayName = "narrowLine";
narrowLine.inheritAttrs = false;
const data$n = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M896 176H128a64 64 0 0 0-64 64V784a64 64 0 0 0 64 64H896a64 64 0 0 0 64-64V240A64 64 0 0 0 896 176Zm0 608H128V240H896Z"}},{"type":"element","name":"path","attributes":{"d":"M327.84 649.28h52.64V373.28H337.76A97.12 97.12 0 0 1 304 417.28a150.56 150.56 0 0 1-44.8 25.6v48a182.56 182.56 0 0 0 68.16-40Z"}},{"type":"element","name":"path","attributes":{"d":"M480.64 450.24H533.28V502.88H480.64V450.24z"}},{"type":"element","name":"path","attributes":{"d":"M480.64 596.64H533.28V649.28H480.64V596.64z"}},{"type":"element","name":"path","attributes":{"d":"M669.28 649.28h52.64V373.28H679.2a97.12 97.12 0 0 1-33.28 44 150.56 150.56 0 0 1-44.8 25.6v48a182.56 182.56 0 0 0 68.16-40Z"}}]}');
const original = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$n,
    "name": "original"
  }), null);
};
original.displayName = "original";
original.inheritAttrs = false;
const data$m = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1303.273","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"fill-rule":"evenodd","d":"M1010.3272727272728 326.8363636363636C1019.0545454545455 335.56363636363636 1024 347.3454545454546 1024 359.70909090909095L1024 1256.7272727272727C1024 1282.4727272727273 1003.2 1303.2727272727273 977.4545454545455 1303.2727272727273L46.54545454545455 1303.2727272727273C20.80000000000002 1303.2727272727273 0 1282.4727272727273 0 1256.7272727272727L0 46.54545454545455C0 20.799999999999997 20.80000000000002 0 46.54545454545455 0L664.2909090909092 0C676.6545454545455 0 688.5818181818182 4.945454545454554 697.3090909090909 13.67272727272728L1010.3272727272728 326.8363636363636ZM916.6545454545455 381.0909090909091L642.9090909090909 107.34545454545456 642.9090909090909 381.0909090909091 916.6545454545455 381.0909090909091ZM688.3156340363636 833.8269090909091C666.2443659636364 833.1156340363638 642.7679976727273 834.8014545454546 616.0974568727273 838.1381818181819 580.7549114181819 816.3389114181817 556.9643659636364 786.3825454545455 540.0625477818182 742.389820509091 540.4698158545455 740.714179490909 541.3134568727273 737.2436386909092 541.6087272727273 736.0189114181819 542.2981818181819 733.1709114181818 542.8698158545455 730.7912750545455 543.4167295999999 728.4770909090909 549.661090909091 702.1061818181818 553.0385454545456 682.8654545454546 554.0349114181819 663.4661841454545 554.788361309091 648.8130932363637 553.9767249454546 635.2945477818182 551.3774545454546 622.7738205090909 546.5803636363637 595.7425477818182 527.4443636363637 579.933090909091 503.3469067636364 578.9541841454546 480.8799976727273 578.0421818181818 460.2210909090909 590.5803636363637 454.9381818181818 610.0421818181818 446.33745221818185 641.4778181818182 451.37454545454545 682.8712727272729 469.6 753.4341818181819 446.3796363636364 808.7883636363637 415.70618181818185 873.6683659636363 395.1229067636363 909.8545477818182 367.65381818181817 924.021820509091 346.2443659636364 936.9163636363637 328.28218181818187 951.2029090909091 304.5687296 970.0625454545454 289.7658181818182 989.4429090909091 285.6843636363637 1009.8298181818183 283.71345221818177 1019.2552727272729 286.69090909090914 1031.5985454545455 293.4807272727272 1041.7018181818182 301.184 1053.1621841454546 312.8 1060.597820509091 326.7243659636364 1061.6800023272726 361.85454312727273 1064.4101818181819 405.02254312727274 1028.1905477818182 452.6734522181818 946.3956386909091 457.4661818181818 944.8101841454546 462.5352704 943.1127272727273 468.71127040000005 941.0283659636364 472.09018181818186 939.8894545454546 483.9316340363637 935.8821841454546 486.0349114181819 935.1723659636364 496.9745454545455 931.4778205090909 504.9149114181818 928.8305477818183 512.7636340363636 926.2763659636363 546.7941794909092 915.2043659636364 572.5396340363636 908.1978181818182 595.9781794909092 904.221090909091 636.6661818181818 926.0000023272728 683.7105477818181 940.288 715.3934522181818 940.288 741.5447272727273 940.288 759.2130885818183 926.7330932363637 765.5970909090909 905.4007296 771.2072704000001 886.6574568727273 766.7520000000001 864.9294568727273 754.7272704 852.9149114181819 742.2763613090909 840.6821841454545 719.3818205090909 834.8290932363636 688.3156340363636 833.8269090909091L688.3156340363636 833.8269090909091ZM327.61017716363637 1020.6196363636365L327.61017716363637 1020.0960000000001 327.79345454545455 1019.6043636363636C329.6479976727273 1014.6283613090909 332.38545221818185 1009.4109090909092 335.93890909090914 1003.9563636363637 342.17018181818185 994.3912727272727 350.7359976727273 984.32 361.3527272727273 973.6072704000001 367.0545454545455 967.8545454545455 372.992 962.2618158545456 379.9563636363637 955.9781794909092 381.5170885818182 954.5687272727273 391.46181818181816 945.7105454545456 393.32217949090904 943.9781841454546L409.5781794909091 928.8407272727272 397.76727040000003 947.6538181818181C379.8385431272727 976.2181818181818 363.6436340363636 996.7883636363637 349.74836363636365 1010.2050909090909 344.64727039999997 1015.1316340363637 340.1483636363636 1018.7869090909091 336.52508858181824 1021.121452218182 335.0312727272727 1022.0843613090909 333.7381794909091 1022.7854522181817 332.72436363636365 1023.1927249454546 332.1294522181818 1023.4298181818182 331.6029067636364 1023.5825431272726 331.0807272727273 1023.6319976727274 330.5281303272728 1023.6968587636364 329.9681698909091 1023.6166516363637 329.4559976727273 1023.3992704 328.3361233454546 1022.9301666909092 327.6080779636364 1021.8337931636364 327.61017716363637 1020.6196363636365ZM510.7869090909091 703.1374568727272L507.4996363636364 708.9658181818182 505.47781818181824 702.5876340363636C500.94836363636364 688.2909090909092 497.6421841454545 666.7461818181819 496.72727272727275 647.3192727272727 495.6858181818182 625.2145431272728 497.44000000000005 611.9403659636364 504.416 611.9403659636364 514.2196363636363 611.9403659636364 518.715638690909 627.6610885818181 519.072 651.2901818181818 519.3861818181817 672.0610909090909 516.1192727272727 693.6785454545454 510.7869090909091 703.1374568727272ZM502.336 788.1760023272727L504.5672727272727 782.2850932363638 507.60436363636364 787.805090909091C524.6080000000001 818.7069114181819 546.6705454545455 844.4843659636364 570.9323636363636 862.4450932363636L576.1614522181818 866.3170932363636 569.7905431272727 867.6320023272727C546.0407296000001 872.5367296000001 523.9083659636365 879.9330909090909 493.6596340363636 892.1294568727272 496.82181585454543 890.8552750545455 462.20799999999997 905.021090909091 453.45890676363643 908.3752727272728L445.81963403636365 911.3032750545455 449.89527039999996 904.2094545454546C467.85891141818183 872.9425454545456 484.452361309091 835.3716363636364 502.3345477818182 788.1760023272727L502.336 788.1760023272727ZM731.6101818181818 899.1010909090909C720.1716363636365 903.616 695.5709067636365 899.5796340363637 652.2370932363636 881.0836340363636L641.2392727272727 876.3898181818182 653.1650885818183 875.5069067636365C687.0487272727273 872.9992704 711.0661818181818 874.8669067636364 725.0516340363637 879.9869067636363 731.0007249454545 882.165820509091 734.9774522181818 884.9149114181819 736.7418181818182 888.064 738.6472727272728 891.4618181818182 737.7745454545455 895.0603636363637 734.7607272727273 897.2421818181818 734.109090909091 897.8632704 733.0807295999999 898.5221818181819 731.6101818181818 899.1010909090909L731.6101818181818 899.1010909090909Z"}}]}');
const pdfFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$m,
    "name": "pdfFill"
  }), null);
};
pdfFill.displayName = "pdfFill";
pdfFill.inheritAttrs = false;
const data$l = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M827.9893333333332 482.73066666666665l-585.1306666666667-474.7093333333333c-6.229333333333333-5.418666666666667-14.421333333333333-8.746666666666666-23.381333333333334-8.789333333333332-20.223999999999997 0-36.56533333333333 16.384-36.56533333333333 36.56533333333333v950.8693333333333c0 20.18133333333333 16.384 36.56533333333333 36.56533333333333 36.56533333333333 0 0 0.042666666666666665 0 0.042666666666666665 0 8.618666666666666 0 16.512-3.0293333333333328 22.698666666666668-8.106666666666666l585.088-474.66666666666663c8.874666666666666-6.741333333333333 14.506666666666668-17.28 14.506666666666668-29.184 0-11.562666666666667-5.333333333333333-21.845333333333333-13.696-28.544z"}}]}');
const playShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$l,
    "name": "playShape"
  }), null);
};
playShape.displayName = "playShape";
playShape.inheritAttrs = false;
const data$k = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M736 480L544 480 544 288 480 288 480 480 288 480 288 544 480 544 480 736 544 736 544 544 736 544z"}}]}');
const plus = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$k,
    "name": "plus"
  }), null);
};
plus.displayName = "plus";
plus.inheritAttrs = false;
const data$j = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1097.143","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"fill-rule":"evenodd","d":"M698.6857142857143 34.403266925714284C704.0284854857142 39.03491620571429 707.0963821714286 45.75792566857142 707.0963821714286 52.82880841142857L707.0963821714286 1069.3194752C707.0963821714286 1076.3805476571426 704.0330386285714 1083.0943561142856 698.7016923428572 1087.7242075428571 693.3703497142857 1092.3540589714285 686.2936283428571 1094.4451693714284 679.3020964571429 1093.4566180571428L66.26742857142857 1005.9290002285713C42.23585170285714 1002.5063533714285 24.380952502857145 981.9287990857142 24.380952502857145 957.6547145142856L24.380952502857145 164.4935701942857C24.380952502857145 140.21948562285712 42.23585170285714 119.64193024 66.26742857142857 116.21928448L66.31619035428571 116.21928448 679.2533321142857 28.691665554285713C686.252565942857 27.68759990857143 693.3429430857143 29.771617645714286 698.6857142857143 34.403266925714284ZM950.905903542857 122.21699876571428C977.8363611428571 122.21699876571428 999.6678107428571 144.04844726857144 999.6678107428571 170.97890340571428L999.6678107428571 951.1693787428571C999.6678107428571 978.0998363428571 977.8363611428571 999.931285942857 950.905903542857 999.931285942857L755.8582857142857 999.931285942857 755.8582857142857 902.4074751999999 902.1439999999999 902.4074751999999 902.1439999999999 219.74080841142853 755.8582857142857 219.74080841142853 755.8582857142857 122.21699876571428 950.905903542857 122.21699876571428ZM544.5566976 333.5185846857143L154.46146048 333.5185846857143 154.46146048 723.613824 251.98526976 723.613824 251.98526976 626.0900132571428 544.5566976 626.0900132571428 544.5566976 333.5185846857143ZM447.03289051428567 431.0423954285714L447.03289051428567 528.5662061714285 251.98526976 528.5662061714285 251.98526976 431.0423954285714 447.03289051428567 431.0423954285714Z"}}]}');
const pptFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$j,
    "name": "pptFill"
  }), null);
};
pptFill.displayName = "pptFill";
pptFill.inheritAttrs = false;
const data$i = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1117.090909090909","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M314.1818181818182 1117.090909090909h-30.720000000000002c-58.78690909090909-0.6516363636363637-112.73309090909092-21.038545454545456-155.5549090909091-54.87709090909091-18.01309090909091-17.31490909090909-29.55636363636364-42.216727272727276-29.55636363636364-69.86472727272727 0-1.3032727272727274 0.04654545454545455-2.6530909090909094 0.0930909090909091-3.956363636363637 0.1861818181818182-11.776 3.025454545454546-23.04 7.866181818181819-33.09381818181818-0.1861818181818182 0.32581818181818184-0.1861818181818182 0.1861818181818182-0.1861818181818182 0 0-18.478545454545458 7.168-35.281454545454544 18.897454545454547-47.75563636363636 8.424727272727273-10.100363636363637 18.10618181818182-18.897454545454547 28.811636363636364-26.205090909090906-7.866181818181819-12.008727272727274-16.19781818181818-25.506909090909094-23.691636363636366-39.47054545454545-17.268363636363638 19.78181818181818-42.123636363636365 34.443636363636365-70.42327272727273 37.05018181818182-19.642181818181818-1.349818181818182-35.70036363636364-13.870545454545454-42.170181818181824-31.045818181818184-51.75854545454546-139.96218181818182 26.43781818181818-264.9367272727273 87.17963636363636-336.1512727272728-0.32581818181818184-3.2581818181818187-0.512-7.028363636363636-0.512-10.798545454545456s0.1861818181818182-7.586909090909091 0.5585454545454546-11.310545454545455c-0.3723636363636364-2.699636363636364-0.5585454545454546-6.3767272727272735-0.5585454545454546-10.053818181818182 0-18.990545454545455 5.12-36.77090909090909 14.056727272727272-52.08436363636364 0.4189090909090909-23.505454545454548 10.705454545454547-44.96290909090909 26.903272727272725-60.22981818181819 2.0014545454545454-203.264 167.2378181818182-367.29018181818185 370.78109090909095-367.29018181818185 0.512 0 0.9774545454545456 0 1.4894545454545456 0 104.40145454545454 1.2567272727272727 198.42327272727272 44.86981818181818 265.8210909090909 114.40872727272729 65.34981818181818 65.25672727272728 106.82181818181819 154.25163636363638 110.40581818181818 252.88145454545455 22.43490909090909 28.904727272727275 36.02618181818182 65.1170909090909 36.02618181818182 104.44800000000001 0 12.706909090909091-1.3963636363636363 25.088-4.096 37.00363636363637 51.2 64.512 134.28363636363636 203.45018181818185 70.05090909090909 343.7847272727273-7.493818181818182 17.268363636363638-24.34327272727273 29.184-43.985454545454544 29.323636363636364h0c-27.694545454545455-4.654545454545455-50.87418181818182-20.945454545454545-64.69818181818181-43.566545454545455-8.424727272727273 15.63927272727273-16.57018181818182 29.137454545454545-25.46036363636364 42.030545454545454 14.382545454545454 6.935272727272727 25.925818181818183 16.942545454545453 35.51418181818182 28.57890909090909 11.450181818181818 11.86909090909091 18.71127272727273 27.46181818181818 19.735272727272726 44.73018181818182 4.654545454545455 9.774545454545455 7.493818181818182 21.038545454545456 7.680000000000001 32.954181818181816 0.04654545454545455 1.2101818181818182 0.0930909090909091 2.5134545454545454 0.0930909090909091 3.816727272727273 0 27.601454545454544-11.543272727272727 52.54981818181818-30.06836363636364 70.23709090909091-42.30981818181819 33.466181818181816-96.256 53.85309090909091-154.90327272727274 54.50472727272727-10.14690909090909 1.2101818181818182-21.736727272727276 1.8618181818181818-33.512727272727275 1.8618181818181818-66.28072727272728 0-127.44145454545455-21.643636363636364-176.91927272727273-58.32145454545454l-33.419636363636364 0.5585454545454546c-47.19709090909091 36.25890909090909-107.14763636363637 58.088727272727276-172.17163636363637 58.088727272727276-3.3047272727272725 0-6.56290909090909-0.04654545454545455-9.821090909090909-0.1861818181818182zM187.11272727272726 946.7345454545455l18.152727272727272 11.17090909090909-38.4 30.720000000000002c0.8378181818181818 8.238545454545454 3.8632727272727276 15.63927272727273 8.471272727272726 21.736727272727276 31.232000000000003 22.900363636363636 70.51636363636364 36.72436363636364 113.01236363636363 36.910545454545456 9.588363636363637 1.442909090909091 20.57309090909091 2.280727272727273 31.744000000000003 2.280727272727273 53.061818181818175 0 101.74836363636364-18.80436363636364 139.72945454545453-50.0829090909091l10.100363636363637-9.495272727272727h21.643636363636364c6.469818181818183 0.46545454545454545 14.010181818181819 0.7447272727272728 21.643636363636364 0.7447272727272728s15.173818181818183-0.2792727272727273 22.667636363636365-0.7912727272727273l14.336 0.04654545454545455 11.17090909090909 10.472727272727273c37.376000000000005 31.09236363636364 85.9229090909091 49.98981818181819 138.8450909090909 49.98981818181819 11.636363636363637 0 23.04-0.9309090909090909 34.16436363636364-2.6530909090909094-0.6516363636363637 0.1861818181818182 0 0.1861818181818182 0.6516363636363637 0.1861818181818182 42.07709090909091 0 80.94254545454547-13.637818181818181 112.45381818181818-36.67781818181818 3.6770909090909094-4.561454545454546 6.2370909090909095-11.031272727272727 6.2370909090909095-18.10618181818182 0-1.8618181818181818-0.1861818181818182-3.6770909090909094-0.512-5.445818181818182l-38.35345454545455-30.533818181818184 18.152727272727272-9.774545454545455c-10.053818181818182-7.633454545454546-21.969454545454546-13.451636363636363-34.955636363636366-16.61672727272727l-55.80800000000001-14.103272727272728 37.70181818181818-42.58909090909091c29.649454545454546-33.18690909090909 52.1309090909091-73.49527272727273 64.41890909090908-117.99272727272728l24.948363636363638-94.25454545454545 40.49454545454545 85.87636363636364c8.843636363636364 19.456 19.316363636363636 36.21236363636364 31.744000000000003 51.386181818181825 30.39418181818182-108.63709090909092-47.104-218.25163636363638-83.40945454545455-262.2370909090909l-13.265454545454544-15.360000000000001 6.9818181818181815-18.85090909090909c3.1185454545454547-9.076363636363636 4.887272727272728-19.54909090909091 4.887272727272728-30.440727272727276 0-25.134545454545457-9.541818181818181-48.034909090909096-25.227636363636368-65.25672727272728l-9.681454545454546-10.379636363636363v-13.963636363636363c-0.32581818181818184-169.70472727272727-135.40072727272727-307.75854545454547-303.9418181818182-312.78545454545457-1.349818181818182 0-2.373818181818182-0.04654545454545455-3.444363636363636-0.04654545454545455-167.7498181818182 0-303.70909090909095 135.95927272727272-303.70909090909095 303.70909090909095 0 3.6770909090909094 0.04654545454545455 7.354181818181819 0.1861818181818182 11.031272727272727l0 20.433454545454545-17.454545454545453 13.963636363636363c-5.678545454545454 3.1650909090909094-9.448727272727274 9.076363636363636-9.448727272727274 15.918545454545455 0 1.3032727272727274 0.13963636363636364 2.5134545454545454 0.3723636363636364 3.7236363636363636l4.189090909090909 27.089454545454544-16.756363636363638 7.680000000000001c-0.3723636363636364 2.7461818181818183-0.6050909090909091 5.864727272727273-0.6050909090909091 9.076363636363636s0.23272727272727273 6.330181818181819 0.6516363636363637 9.448727272727274c0.512 6.842181818181818 2.280727272727273 13.451636363636363 4.980363636363636 19.54909090909091l8.238545454545454 19.874909090909092-14.661818181818182 16.05818181818182c-59.485090909090914 55.482181818181814-96.53527272727273 134.28363636363636-96.53527272727273 221.7890909090909 0 10.891636363636364 0.5585454545454546 21.69018181818182 1.722181818181818 32.30254545454545 12.288-14.754909090909091 23.179636363636366-29.88218181818182 32.11636363636364-46.21963636363636l41.099636363636364-70.98181818181818 23.73818181818182 78.89454545454547c13.312 44.12509090909091 35.14181818181818 82.19927272727273 63.76727272727273 114.0829090909091l36.07272727272728 40.215272727272726-52.36363636363637 16.05818181818182c-12.427636363636365 2.3272727272727276-23.458909090909092 6.935272727272727-33.14036363636364 13.451636363636363zM165.4690909090909 474.76363636363635v0z"}}]}');
const qq = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$i,
    "name": "qq"
  }), null);
};
qq.displayName = "qq";
qq.inheritAttrs = false;
const data$h = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M822.3999999999999 493.43999999999994l-439.03999999999996-356.48c-10.239999999999998-8.32-26.24-10.879999999999999-40.31999999999999-7.04s-23.04 14.08-23.04 25.599999999999998v712.96c0 11.52 8.959999999999999 21.119999999999997 23.04 25.599999999999998 4.4799999999999995 1.2799999999999998 8.959999999999999 1.92 13.44 1.92 10.239999999999998 0 19.84-3.1999999999999997 26.88-8.959999999999999l439.03999999999996-356.48c12.799999999999999-10.239999999999998 12.799999999999999-26.88 0-37.12z"}}]}');
const rightShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$h,
    "name": "rightShape"
  }), null);
};
rightShape.displayName = "rightShape";
rightShape.inheritAttrs = false;
const data$g = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M832 512a320 320 0 1 1-76.96-208H672v64H864V176H800v82.08A384 384 0 1 0 896 512Z"}}]}');
const rightTurnLine = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$g,
    "name": "rightTurnLine"
  }), null);
};
rightTurnLine.displayName = "rightTurnLine";
rightTurnLine.inheritAttrs = false;
const data$f = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M842.56 797.28l-151.52-151.52a336 336 0 1 0-45.28 45.28l151.52 151.52a32 32 0 0 0 45.28-45.28ZM432 704A272 272 0 1 1 704 432 272 272 0 0 1 432 704Z"}}]}');
const search = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$f,
    "name": "search"
  }), null);
};
search.displayName = "search";
search.inheritAttrs = false;
const data$e = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"icon","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M981.333333 1024H42.666667a42.666667 42.666667 0 0 1-42.666667-42.666667V42.666667a42.666667 42.666667 0 0 1 42.666667-42.666667h341.333333a42.666667 42.666667 0 0 1 0 85.333333H85.333333v853.333334h853.333334V618.666667a42.666667 42.666667 0 0 1 85.333333 0v362.666666a42.666667 42.666667 0 0 1-42.666667 42.666667z m0-576a42.666667 42.666667 0 0 1-42.666666-42.666667V152.746667L315.306667 796.8a48 48 0 0 1-67.2 0 47.36 47.36 0 0 1 0-66.133333L871.893333 85.333333H640a42.666667 42.666667 0 0 1 0-85.333333h341.333333a42.666667 42.666667 0 0 1 42.666667 42.666667v362.666666a42.666667 42.666667 0 0 1-42.666667 42.666667z"}}]}');
const share = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$e,
    "name": "share"
  }), null);
};
share.displayName = "share";
share.inheritAttrs = false;
const data$d = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lds-spin","preserveAspectRatio":"xMidYMid","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M874.3255040000001 512A55.125504 55.125504 0 0 1 819.2 567.125504 55.125504 55.125504 0 0 1 764.074496 512 55.125504 55.125504 0 0 1 874.3255040000001 512z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.9166666666666666s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.9166666666666666s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".917","d":"M826.5220089266763 693.5878203150381A55.978496 55.978496 0 0 1 750.0539613250309 714.0773719166838 55.978496 55.978496 0 0 1 729.5644097233852 637.6093243150382 55.978496 55.978496 0 0 1 826.5220089266763 693.5878203150381z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.8333333333333334s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.8333333333333334s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".833","d":"M694.0170969047495 827.2583983352753A56.83200000000001 56.83200000000001 0 0 1 616.3831411568723 806.4564425873981 56.83200000000001 56.83200000000001 0 0 1 637.1850969047495 728.8224868395207 56.83200000000001 56.83200000000001 0 0 1 694.0170969047495 827.2583983352753z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.75s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.75s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".75","d":"M512 876.8855040000001A57.685504 57.685504 0 0 1 454.314496 819.2 57.685504 57.685504 0 0 1 512 761.5144959999999 57.685504 57.685504 0 0 1 512 876.8855040000001z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.6666666666666666s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.6666666666666666s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".667","d":"M329.1269198807941 828.7408206328269A58.538495999999995 58.538495999999995 0 0 1 307.7003432454604 748.7757479974932 58.538495999999995 58.538495999999995 0 0 1 387.6654158807941 727.3491713621594 58.538495999999995 58.538495999999995 0 0 1 329.1269198807941 828.7408206328269z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.5833333333333334s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.5833333333333334s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".583","d":"M194.5170177632531 695.2980006130954A59.39199999999999 59.39199999999999 0 0 1 216.2559985448185 614.16701983153 59.39199999999999 59.39199999999999 0 0 1 297.3869793263839 635.9060006130953 59.39199999999999 59.39199999999999 0 0 1 194.5170177632531 695.2980006130954z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.5s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.5s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".5","d":"M144.55449600000003 512A60.245504000000004 60.245504000000004 0 0 1 204.80000000000004 451.754496 60.245504000000004 60.245504000000004 0 0 1 265.04550400000005 512 60.245504000000004 60.245504000000004 0 0 1 144.55449600000003 512z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.4166666666666667s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.4166666666666667s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".417","d":"M193.04947448121268 327.85151812453734A61.098496 61.098496 0 0 1 276.5115721502346 305.48791645551546 61.098496 61.098496 0 0 1 298.87517381925653 388.95001412453735 61.098496 61.098496 0 0 1 193.04947448121268 327.85151812453734z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.3333333333333333s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.3333333333333333s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".333","d":"M332.5476411431614 201.1754130120454A51.711999999999996 51.711999999999996 0 0 1 403.1875468236623 220.1033186925463 51.711999999999996 51.711999999999996 0 0 1 384.2596411431614 290.7432243730472 51.711999999999996 51.711999999999996 0 0 1 332.5476411431614 201.1754130120454z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.25s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.25s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".25","d":"M512 152.234496A52.565504000000004 52.565504000000004 0 0 1 564.565504 204.8 52.565504000000004 52.565504000000004 0 0 1 512 257.365504 52.565504000000004 52.565504000000004 0 0 1 512 152.234496z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.16666666666666666s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.16666666666666666s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".167","d":"M692.3075781671167 199.69299071449373A53.418496000000005 53.418496000000005 0 0 1 711.8601047350743 272.66401328245115 53.418496000000005 53.418496000000005 0 0 1 638.8890821671168 292.21653985040854 53.418496000000005 53.418496000000005 0 0 1 692.3075781671167 199.69299071449373z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"-0.08333333333333333s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"-0.08333333333333333s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]},{"type":"element","name":"path","attributes":{"fill-opacity":".083","d":"M825.0362880000001 331.264A54.27213621356492 54.27213621356492 0 0 1 805.1712000000001 405.401088 54.27213621356492 54.27213621356492 0 0 1 731.034112 385.536 54.27213621356492 54.27213621356492 0 0 1 825.0362880000001 331.264z"},"elements":[{"type":"element","name":"animateTransform","attributes":{"attributeName":"transform","begin":"0s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","type":"scale","values":"1.2 1.2;1 1"}},{"type":"element","name":"animate","attributes":{"attributeName":"fill-opacity","begin":"0s","dur":"1s","keyTimes":"0;1","repeatCount":"indefinite","values":"1;0"}}]}]}');
const spinner = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$d,
    "name": "spinner"
  }), null);
};
spinner.displayName = "spinner";
spinner.inheritAttrs = false;
const data$c = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zM485.7 670.3l-181-181L350 444l135.8 135.8L712 353.5l45.3 45.3L485.7 670.3z"}}]}');
const success = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$c,
    "name": "success"
  }), null);
};
success.displayName = "success";
success.inheritAttrs = false;
const data$b = JSON.parse('{"type":"element","name":"svg","attributes":{"aria-hidden":"true","class":"anticon-spin","data-icon":"loading","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 0 0-94.3-139.9 437.71 437.71 0 0 0-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3 0.1 19.9-16 36-35.9 36z"}}]}');
const switcherLoading = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$b,
    "name": "switcherLoading"
  }), null);
};
switcherLoading.displayName = "switcherLoading";
switcherLoading.inheritAttrs = false;
const data$a = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M704 64L704 64H128v896h768V256l0 0L704 64zM704 154.5L805.5 256H704V154.5zM832 896H192V128h448v192h192V896z","class":"st0"}},{"type":"element","name":"path","attributes":{"d":"M288 320H544V384H288V320z","class":"st0"}},{"type":"element","name":"path","attributes":{"d":"M288 448H736V512H288V448z","class":"st0"}},{"type":"element","name":"path","attributes":{"d":"M288 576H736V640H288V576z","class":"st0"}},{"type":"element","name":"path","attributes":{"d":"M288 704H736V768H288V704z","class":"st0"}}]}');
const textFile = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$a,
    "name": "textFile"
  }), null);
};
textFile.displayName = "textFile";
textFile.inheritAttrs = false;
const data$9 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1303.273","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M664.4363636363637 0C676.8000000000001 0 688.5818181818182 4.945454545454545 697.3090909090909 13.672727272727274L697.3090909090909 13.672727272727274 1010.3272727272728 326.6909090909091C1019.0545454545455 335.41818181818184 1024 347.3454545454546 1024 359.70909090909095L1024 359.70909090909095 1024 1256.7272727272727C1024 1282.4727272727273 1003.2 1303.2727272727273 977.4545454545455 1303.2727272727273L977.4545454545455 1303.2727272727273 46.54545454545455 1303.2727272727273C20.8 1303.2727272727273 0 1282.4727272727273 0 1256.7272727272727L0 1256.7272727272727 0 46.54545454545455C0 20.8 20.8 0 46.54545454545455 0L46.54545454545455 0ZM721.4545454545455 930.909090909091L302.54545454545456 930.909090909091C289.6922824145455 930.909090909091 279.27272727272725 941.3286446545454 279.27272727272725 954.1818181818182L279.27272727272725 954.1818181818182 279.27272727272725 1000.7272727272727C279.27272727272725 1013.5804462545456 289.6922824145455 1024 302.54545454545456 1024L302.54545454545456 1024 721.4545454545455 1024C734.3077189818182 1024 744.7272727272727 1013.5804462545456 744.7272727272727 1000.7272727272727L744.7272727272727 1000.7272727272727 744.7272727272727 954.1818181818182C744.7272727272727 941.3286446545454 734.3077189818182 930.909090909091 721.4545454545455 930.909090909091L721.4545454545455 930.909090909091ZM628.3636363636364 744.7272727272727L302.54545454545456 744.7272727272727C289.6922824145455 744.7272727272727 279.27272727272725 755.1468264727272 279.27272727272725 768L279.27272727272725 768 279.27272727272725 814.5454545454546C279.27272727272725 827.3986280727273 289.6922824145455 837.8181818181819 302.54545454545456 837.8181818181819L302.54545454545456 837.8181818181819 628.3636363636364 837.8181818181819C641.2168098909091 837.8181818181819 651.6363636363636 827.3986280727273 651.6363636363636 814.5454545454546L651.6363636363636 814.5454545454546 651.6363636363636 768C651.6363636363636 755.1468264727272 641.2168098909091 744.7272727272727 628.3636363636364 744.7272727272727L628.3636363636364 744.7272727272727ZM442.1818181818182 558.5454545454545L302.54545454545456 558.5454545454545C289.6922824145455 558.5454545454545 279.27272727272725 568.9650082909092 279.27272727272725 581.8181818181819L279.27272727272725 581.8181818181819 279.27272727272725 628.3636363636364C279.27272727272725 641.2168098909091 289.6922824145455 651.6363636363636 302.54545454545456 651.6363636363636L302.54545454545456 651.6363636363636 442.1818181818182 651.6363636363636C455.0349903127273 651.6363636363636 465.4545454545455 641.2168098909091 465.4545454545455 628.3636363636364L465.4545454545455 628.3636363636364 465.4545454545455 581.8181818181819C465.4545454545455 568.9650082909092 455.0349903127273 558.5454545454545 442.1818181818182 558.5454545454545L442.1818181818182 558.5454545454545ZM642.9090909090909 107.34545454545454L642.9090909090909 381.0909090909091 916.6545454545455 381.0909090909091 642.9090909090909 107.34545454545454Z"}}]}');
const textFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$9,
    "name": "textFill"
  }), null);
};
textFill.displayName = "textFill";
textFill.inheritAttrs = false;
const data$8 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"fill-rule":"evenodd","d":"M832 448L618.6800000000001 224.00000000000003 617.0133344000001 368.9411776 192 368.94117760000006 192 448.00000000000006 832 448ZM832 576L192 576 405.34666560000005 800 407.01333439999996 655.0588224 832 655.0588224 832 576Z"}}]}');
const transfer = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$8,
    "name": "transfer"
  }), null);
};
transfer.displayName = "transfer";
transfer.inheritAttrs = false;
const data$7 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M432.64 576h156.79999999999998l-79.36-260.48-77.44 260.48z"}},{"type":"element","name":"path","attributes":{"d":"M512 0c-282.75199999999995 0-512 229.248-512 512s229.248 512 512 512c282.75199999999995 0 512-229.248 512-512s-229.248-512-512-512zM681.5999999999999 768h-9.6c-0.042666666666666665 0-0.128 0-0.21333333333333332 0-14.250666666666667 0-26.325333333333333-9.301333333333332-30.464-22.186666666666667l-32.04266666666666-105.81333333333333h-192l-33.28 105.6c-4.1386666666666665 13.994666666666667-16.896 24.02133333333333-32 24.02133333333333-18.389333333333333 0-33.32266666666666-14.933333333333332-33.32266666666666-33.32266666666666 0-3.328 0.46933333333333327-6.485333333333333 1.3653333333333333-9.514666666666667l133.07733333333334-429.82399999999996c9.813333333333333-23.552 32.64-39.808 59.263999999999996-39.808 24.917333333333332 0 46.464 14.208 57.04533333333333 34.986666666666665l134.57066666666665 434.304c1.152 3.157333333333333 1.792 6.784 1.792 10.581333333333333 0 14.890666666666664-10.197333333333333 27.434666666666665-23.97866666666667 30.976z"}}]}');
const treeApplicationShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$7,
    "name": "treeApplicationShape"
  }), null);
};
treeApplicationShape.displayName = "treeApplicationShape";
treeApplicationShape.inheritAttrs = false;
const data$6 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M384 896L320 896 320 704 128 704 128 640 384 640 384 896Z"}},{"type":"element","name":"path","attributes":{"d":"M896 640L896 704 704 704 704 896 640 896 640 640 896 640Z"}},{"type":"element","name":"path","attributes":{"d":"M320 128L384 128 384 384 128 384 128 320 320 320 320 128Z"}},{"type":"element","name":"path","attributes":{"d":"M704 320L896 320 896 384 640 384 640 128 704 128 704 320Z"}}]}');
const unfullScreen = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$6,
    "name": "unfullScreen"
  }), null);
};
unfullScreen.displayName = "unfullScreen";
unfullScreen.inheritAttrs = false;
const data$5 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M500.16 304a355.04 355.04 0 0 1 128 24.8l48-48.96a426.08 426.08 0 0 0-176-39.84v64Z"}},{"type":"element","name":"path","attributes":{"d":"M763.2 328.8l-46.08 46.08a822.24 822.24 0 0 1 160 138.88 807.52 807.52 0 0 1-86.88 85.12C723.84 654.24 620.48 720 502.56 720a331.52 331.52 0 0 1-111.04-19.52l-49.44 49.28a402.4 402.4 0 0 0 160 34.24C768 784 960 512 960 512A962.56 962.56 0 0 0 763.2 328.8Z"}},{"type":"element","name":"path","attributes":{"d":"M254.88 701.12l46.08-46.08a706.56 706.56 0 0 1-156.64-144C197.44 442.88 328.16 304 500.16 304V240h0C234.72 240 64 512 64 512A838.72 838.72 0 0 0 254.88 701.12Z"}},{"type":"element","name":"path","attributes":{"d":"M512 640a128 128 0 0 0 110.24-192.96L888 181.28A32 32 0 1 0 842.72 136L576.96 401.76a128 128 0 0 0-176 176L136 842.72a32 32 0 1 0 45.28 45.28L447.04 622.24A128 128 0 0 0 512 640Zm64-128a64 64 0 0 1-64 64 60.96 60.96 0 0 1-16-2.4L573.6 496A60.96 60.96 0 0 1 576 512Zm-64-64a60.96 60.96 0 0 1 16 2.4L450.4 528A60.96 60.96 0 0 1 448 512 64 64 0 0 1 512 448Z"}}]}');
const unvisible = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$5,
    "name": "unvisible"
  }), null);
};
unvisible.displayName = "unvisible";
unvisible.inheritAttrs = false;
const data$4 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M896 671.3599999999999c0-2.5599999999999996-0.6399999999999999-4.4799999999999995-1.2799999999999998-7.04-0.6399999999999999-1.92-0.6399999999999999-3.84-1.2799999999999998-5.119999999999999s-1.2799999999999998-2.5599999999999996-1.92-3.1999999999999997c-1.2799999999999998-2.5599999999999996-2.5599999999999996-4.4799999999999995-4.4799999999999995-6.3999999999999995 0 0 0 0 0-0.6399999999999999l-356.48-384c-10.239999999999998-11.52-26.88-11.52-37.12 0l-356.48 384c0 0 0 0.6399999999999999 0 0.6399999999999999-1.92 1.92-2.5599999999999996 3.84-3.84 6.3999999999999995-0.6399999999999999 1.2799999999999998-1.92 2.5599999999999996-2.5599999999999996 3.84s-0.6399999999999999 3.1999999999999997-1.2799999999999998 5.119999999999999c-0.6399999999999999 1.2799999999999998-1.2799999999999998 3.84-1.2799999999999998 6.3999999999999995 0 0 0 0.6399999999999999 0 0.6399999999999999 0 1.92 0.6399999999999999 3.1999999999999997 0.6399999999999999 4.4799999999999995 0 2.5599999999999996 0.6399999999999999 4.4799999999999995 1.2799999999999998 7.04s1.92 4.4799999999999995 3.1999999999999997 6.3999999999999995c0.6399999999999999 1.2799999999999998 1.2799999999999998 2.5599999999999996 1.92 3.84 0 0 0 0 0.6399999999999999 0.6399999999999999 1.2799999999999998 1.92 3.1999999999999997 3.1999999999999997 5.119999999999999 4.4799999999999995 1.2799999999999998 0.6399999999999999 2.5599999999999996 1.92 3.84 2.5599999999999996s2.5599999999999996 0.6399999999999999 3.84 1.2799999999999998c1.92 0 3.84 1.2799999999999998 6.3999999999999995 1.2799999999999998 0 0 0.6399999999999999 0 0.6399999999999999 0h712.96c3.84 0 7.68-0.6399999999999999 10.879999999999999-2.5599999999999996 0.6399999999999999 0 0.6399999999999999-0.6399999999999999 1.2799999999999998-0.6399999999999999 3.1999999999999997-1.92 5.76-3.84 8.32-6.3999999999999995 0 0 0 0 0.6399999999999999 0 0.6399999999999999-1.2799999999999998 1.2799999999999998-2.5599999999999996 1.92-3.84 1.2799999999999998-1.92 2.5599999999999996-3.84 3.1999999999999997-6.3999999999999995 0.6399999999999999-1.92 0.6399999999999999-4.4799999999999995 1.2799999999999998-7.04 0-1.92 0.6399999999999999-3.1999999999999997 0.6399999999999999-4.4799999999999995-0.6399999999999999-0.6399999999999999-0.6399999999999999-1.2799999999999998-0.6399999999999999-1.2799999999999998z"}}]}');
const upShape = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$4,
    "name": "upShape"
  }), null);
};
upShape.displayName = "upShape";
upShape.inheritAttrs = false;
const data$3 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M897.6 422.4c-27.2-27.2-62.4-48-100.8-57.6C768 209.6 619.2 104 462.4 131.2c-120 20.8-212.8 115.2-233.6 233.6C131.2 388.8 64 475.2 64 574.4v9.6C64 704 160 800 278.4 800H320v-64h-41.6C195.2 736 128 668.8 128 585.6v-9.6c0-83.2 67.2-150.4 150.4-150.4H288c0-3.2 0-4.8 0-8l0 0c0-1.6 0-3.2 0-4.8v-1.6c0-1.6 0-3.2 0-4.8 0 0 0 0 0-1.6 0-1.6 0-3.2 0-4.8v-1.6c0-1.6 0-3.2 0-3.2 0-1.6 0-1.6 0-3.2 0 0 0-1.6 0-1.6 1.6-9.6 3.2-20.8 6.4-30.4l0 0c30.4-120 153.6-192 272-161.6 78.4 20.8 140.8 81.6 161.6 161.6l0 0c3.2 9.6 4.8 20.8 4.8 30.4 0 0 0 1.6 0 1.6 0 0 0 1.6 0 3.2 0 1.6 0 3.2 0 3.2V400c0 1.6 0 3.2 0 3.2v1.6c0 1.6 0 3.2 0 4.8v1.6c0 1.6 0 3.2 0 4.8l0 0c0 3.2 0 4.8 0 8h9.6c83.2-1.6 152 65.6 153.6 148.8 0 1.6 0 1.6 0 3.2v9.6c0 83.2-67.2 150.4-150.4 150.4l0 0H704v64h41.6C864 800 960 704 960 585.6v-9.6C960 518.4 937.6 464 897.6 422.4z"}},{"type":"element","name":"path","attributes":{"d":"M376 603.2L420.8 648 480 588.8 480 896 544 896 544 588.8 603.2 648 648 603.2 512 467.2z"}}]}');
const upload = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$3,
    "name": "upload"
  }), null);
};
upload.displayName = "upload";
upload.inheritAttrs = false;
const data$2 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1303.273","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"fill-rule":"evenodd","d":"M664.4363636363636 0C676.8 0 688.5818181818182 4.945454545454554 697.3090909090909 13.67272727272728L697.3090909090909 13.67272727272728 1010.3272727272728 326.69090909090914C1019.0545454545455 335.41818181818184 1024 347.3454545454546 1024 359.70909090909095L1024 359.70909090909095 1024 1256.7272727272727C1024 1282.4727272727273 1003.2 1303.2727272727273 977.4545454545455 1303.2727272727273L977.4545454545455 1303.2727272727273 46.54545454545455 1303.2727272727273C20.80000000000002 1303.2727272727273 0 1282.4727272727273 0 1256.7272727272727L0 1256.7272727272727 0 46.54545454545455C0 20.799999999999997 20.80000000000002 0 46.54545454545455 0L46.54545454545455 0ZM397.1878772363637 614.0514816000001L397.1878772363637 848.3380922181818C397.1878772363637 912.7669108363636 440.14042298181823 936.1955746909091 494.8073006545455 901.0525835636363L650.9983744 797.5759965090909C703.7128610909091 758.5282280727272 703.7128610909091 699.9565730909092 650.9983744 664.8135819636365L494.8073006545455 561.3369949090909C442.0928139636364 526.1940037818182 397.1878772363637 549.6226676363636 397.1878772363637 614.0514816000001ZM642.9090909090909 107.34545454545456L642.9090909090909 381.0909090909091 916.6545454545455 381.0909090909091 642.9090909090909 107.34545454545456Z"}}]}');
const videoFill = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$2,
    "name": "videoFill"
  }), null);
};
videoFill.displayName = "videoFill";
videoFill.inheritAttrs = false;
const data$1 = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","class":"lesscode-bk-icon","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;","overflow":"hidden","viewBox":"0 0 1024 1024"},"elements":[{"type":"element","name":"path","attributes":{"d":"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zM544 704h-64v-64h64V704zM544 576h-64V320h64V576z"}}]}');
const warn = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data$1,
    "name": "warn"
  }), null);
};
warn.displayName = "warn";
warn.inheritAttrs = false;
const data = JSON.parse('{"type":"element","name":"svg","attributes":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 1024 1024","style":"width: 1em; height: 1em; vertical-align: middle;fill: currentColor;overflow: hidden;"},"elements":[{"type":"element","name":"path","attributes":{"d":"M603.52 348.8c0 26.496-22.357333333333333 48-49.919999999999995 48s-49.919999999999995-21.503999999999998-49.919999999999995-48c0-26.496 22.357333333333333-48 49.919999999999995-48s49.919999999999995 21.503999999999998 49.919999999999995 48z"}},{"type":"element","name":"path","attributes":{"d":"M357.11999999999995 348.8c0 26.496-22.357333333333333 48-49.919999999999995 48s-49.919999999999995-21.503999999999998-49.919999999999995-48c0-26.496 22.357333333333333-48 49.919999999999995-48s49.919999999999995 21.503999999999998 49.919999999999995 48z"}},{"type":"element","name":"path","attributes":{"d":"M693.12 604.16c0 15.914666666666665-13.184 28.8-29.439999999999998 28.8s-29.439999999999998-12.885333333333332-29.439999999999998-28.8c0-15.914666666666665 13.184-28.8 29.439999999999998-28.8s29.439999999999998 12.885333333333332 29.439999999999998 28.8z"}},{"type":"element","name":"path","attributes":{"d":"M951.68 832c43.775999999999996-42.410666666666664 71.29599999999999-101.41866666666665 72.32-166.86933333333332-4.608-109.696-77.35466666666666-201.0453333333333-176.72533333333334-233.30133333333333 5.674666666666667-12.117333333333331 10.154666666666666-26.282666666666664 10.154666666666666-41.471999999999994 0-4.522666666666666-0.38399999999999995-8.959999999999999-1.152-13.226666666666667-33.834666666666664-181.29066666666665-212.39466666666664-313.1306666666667-425.5146666666667-313.1306666666667-238.71999999999997 0-430.72 167.04-430.72 372.48 1.2799999999999998 107.56266666666666 50.56 203.30666666666664 127.40266666666668 267.05066666666664l-16.682666666666666 55.50933333333333c-2.1759999999999997 6.784-3.456 14.634666666666668-3.456 22.741333333333333 0 42.410666666666664 34.38933333333333 76.8 76.8 76.8 12.458666666666666 0 24.191999999999997-2.944 34.602666666666664-8.234666666666666l101.33333333333333-52.906666666666666c32.81066666666666 7.722666666666666 70.52799999999999 12.159999999999998 109.22666666666666 12.159999999999998 0.08533333333333333 0 0.17066666666666666 0 0.21333333333333332 0h28.16c13.098666666666666-0.7679999999999999 25.130666666666663-4.693333333333333 35.54133333333333-11.050666666666666 54.22933333333333 73.55733333333333 140.672 120.53333333333333 238.07999999999998 120.53333333333333 1.664 0 3.3706666666666667 0 5.034666666666666-0.042666666666666665 21.077333333333332-0.08533333333333333 41.855999999999995-2.1759999999999997 61.99466666666667-6.101333333333333l49.10933333333333 26.581333333333333c9.941333333333333 5.034666666666666 21.717333333333332 8.021333333333333 34.176 8.021333333333333 42.410666666666664 0 76.8-34.38933333333333 76.8-76.8 0-8.106666666666666-1.2799999999999998-15.957333333333333-3.584-23.296zM430.72 752.64c-0.17066666666666666 0-0.38399999999999995 0-0.5973333333333333 0-40.831999999999994 0-80.29866666666666-5.8453333333333335-117.58933333333331-16.72533333333333l-3.456 0.7253333333333334-131.2 67.19999999999999 35.199999999999996-113.27999999999999h-3.1999999999999997c-86.10133333333332-52.05333333333333-143.40266666666668-144.17066666666665-145.92-249.89866666666666 0-172.50133333333332 165.76-312.66133333333335 366.72-312.66133333333335 5.717333333333333-0.3413333333333333 12.415999999999999-0.512 19.157333333333334-0.512 163.32799999999997 0 300.58666666666664 111.40266666666668 340.0106666666667 262.4l-14.805333333333332 2.432c-183.04 0-327.03999999999996 112-327.03999999999996 285.44 0.512 26.709333333333333 5.1626666666666665 52.181333333333335 13.312 75.98933333333332zM872.96 812.8v0l21.759999999999998 67.84-81.28-40.959999999999994h-3.84c-21.119999999999997 6.101333333333333-45.397333333333336 9.6-70.48533333333333 9.6-0.17066666666666666 0-0.38399999999999995 0-0.5546666666666666 0-5.888 0.5973333333333333-12.757333333333332 0.9386666666666665-19.712 0.9386666666666665-107.09333333333332 0-195.2853333333333-80.93866666666666-206.71999999999997-184.95999999999998 10.367999999999999-106.96533333333333 99.072-189.1413333333333 206.976-189.1413333333333 5.973333333333334 0 11.861333333333334 0.256 17.706666666666663 0.7253333333333334 4.309333333333333-0.512 10.197333333333333-0.7253333333333334 16.170666666666666-0.7253333333333334 107.904 0 196.60799999999998 82.17599999999999 206.976 187.34933333333333-1.7066666666666666 63.82933333333333-35.79733333333333 118.44266666666665-86.18666666666667 148.90666666666667z"}},{"type":"element","name":"path","attributes":{"d":"M839.68 604.16c0 15.914666666666665-13.184 28.8-29.439999999999998 28.8s-29.439999999999998-12.885333333333332-29.439999999999998-28.8c0-15.914666666666665 13.184-28.8 29.439999999999998-28.8s29.439999999999998 12.885333333333332 29.439999999999998 28.8z"}}]}');
const weixin = (props2, context) => {
  const p2 = __spreadValues(__spreadValues({}, props2), context.attrs);
  return createVNode(bkIcon, mergeProps(p2, {
    "data": data,
    "name": "weixin"
  }), null);
};
weixin.displayName = "weixin";
weixin.inheritAttrs = false;
var BkIcon = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AngleDoubleDownLine: angleDoubleDownLine,
  AngleDoubleLeftLine: angleDoubleLeftLine,
  AngleDoubleLeft: angleDoubleLeft,
  AngleDoubleRightLine: angleDoubleRightLine,
  AngleDoubleRight: angleDoubleRight,
  AngleDoubleUpLine: angleDoubleUpLine,
  AngleDownFill: angleDownFill,
  AngleDownLine: angleDownLine,
  AngleDown: angleDown,
  AngleLeft: angleLeft,
  AngleRight: angleRight,
  AngleUpFill: angleUpFill,
  AngleUp: angleUp,
  ArchiveFill: archiveFill,
  ArrowsLeft: arrowsLeft,
  ArrowsRight: arrowsRight,
  AudioFill: audioFill,
  Bk: bk,
  Circle: circle,
  CloseLine: closeLine,
  Close: close$1,
  Code: code,
  CogShape: cogShape,
  CollapseLeft: collapseLeft,
  Copy: copy,
  DataShape: dataShape,
  Del: del,
  DocFill: docFill,
  Done: done,
  DownShape: downShape,
  DownSmall: downSmall,
  EditLine: editLine,
  Ellipsis: ellipsis$1,
  EnlargeLine: enlargeLine,
  Error: error,
  ExcelFill: excelFill,
  ExclamationCircleShape: exclamationCircleShape,
  Eye: eye,
  FilliscreenLine: filliscreenLine,
  FolderOpen: folderOpen,
  FolderShapeOpen: folderShapeOpen,
  FolderShape: folderShape,
  Folder: folder,
  Funnel: funnel,
  HelpDocumentFill: helpDocumentFill,
  HelpFill: helpFill,
  Help: help,
  ImageFill: imageFill,
  ImgError: imgError,
  ImgPlacehoulder: imgPlacehoulder,
  InfoLine: infoLine,
  Info: info,
  LeftShape: leftShape,
  LeftTurnLine: leftTurnLine,
  NarrowLine: narrowLine,
  Original: original,
  PdfFill: pdfFill,
  PlayShape: playShape,
  Plus: plus,
  PptFill: pptFill,
  Qq: qq,
  RightShape: rightShape,
  RightTurnLine: rightTurnLine,
  Search: search,
  Share: share,
  Spinner: spinner,
  Success: success,
  SwitcherLoading: switcherLoading,
  TextFile: textFile,
  TextFill: textFill,
  Transfer: transfer,
  TreeApplicationShape: treeApplicationShape,
  UnfullScreen: unfullScreen,
  Unvisible: unvisible,
  UpShape: upShape,
  Upload: upload,
  VideoFill: videoFill,
  Warn: warn,
  Weixin: weixin
}, Symbol.toStringTag, { value: "Module" }));
var Component$F = defineComponent({
  name: "Alert",
  props: {
    theme: TagThemeType().def(TagThemeEnum.INFO),
    size: PropTypes.string,
    title: PropTypes.string,
    closable: PropTypes.bool.def(false),
    closeText: PropTypes.string,
    showIcon: PropTypes.bool.def(true)
  },
  emits: ["close"],
  setup(_props, context) {
    const state = reactive({
      visible: true
    });
    const handleClose = () => {
      state.visible = false;
      context.emit("close");
    };
    return {
      state,
      handleClose
    };
  },
  render() {
    var _a, _b;
    if (!this.state.visible) {
      return null;
    }
    const renderCloseText = Boolean(this.closeText);
    const closeButtonClasses = classes({
      "lesscode-bk-alert-close": true,
      "close-text": renderCloseText,
      "lesscode-bk-alert-close-icon": !renderCloseText
    });
    const typeClass = classes({
      "lesscode-bk-alert": true,
      [`lesscode-bk-alert-${this.theme}`]: true
    });
    return createVNode("div", {
      "class": typeClass
    }, [createVNode("div", {
      "class": "lesscode-bk-alert-wraper"
    }, [this.showIcon && createVNode(infoLine, {
      "class": "lesscode-bk-alert-icon-info"
    }, null), createVNode("div", {
      "class": "lesscode-bk-alert-content"
    }, [createVNode("div", {
      "class": "lesscode-bk-alert-title"
    }, [this.$slots.title ? this.$slots.title() : this.title]), createVNode("div", {
      "class": "lesscode-bk-alert-description"
    }, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)])]), this.closable && createVNode("span", {
      "class": closeButtonClasses,
      "onClick": this.handleClose
    }, [this.closeText ? this.closeText : createVNode(closeLine, null, null)])])]);
  }
});
const BkAlert = withInstall(Component$F);
var Component$E = defineComponent({
  name: "AnimateNumber",
  props: {
    value: PropTypes.number.def(0),
    digits: PropTypes.number.def(0)
  },
  setup(props2) {
    let rafId = -1;
    const tweeningValue = ref(0);
    const formatValue = computed(() => Number(tweeningValue.value).toFixed(props2.digits));
    const tween = (startValue, endValue) => {
      if (Number.isNaN(+endValue))
        return 0;
      const dis = Math.abs(endValue - startValue);
      const isPositive = endValue - startValue > 0 ? 1 : -1;
      const ticDis = Math.ceil(dis / 30 * 10 ** props2.digits) / 10 ** props2.digits;
      const ticTimes = Math.ceil(dis / ticDis);
      const gapTime = 25 / ticTimes;
      let tickGap = 1;
      const animate = () => {
        if (tickGap < gapTime) {
          rafId = requestAnimationFrame(animate);
          tickGap = tickGap + 1;
          return;
        }
        tweeningValue.value += ticDis * isPositive;
        const isUnDone = isPositive === 1 ? tweeningValue.value < endValue : tweeningValue.value > endValue;
        if (isUnDone) {
          rafId = requestAnimationFrame(animate);
          tickGap = 1;
        } else {
          tweeningValue.value = endValue;
        }
      };
      animate();
    };
    watch(() => props2.value, (newValue, oldValue) => {
      tween(oldValue, newValue);
    });
    onMounted(() => {
      tween(0, props2.value);
    });
    onBeforeUnmount(() => {
      cancelAnimationFrame(rafId);
    });
    return () => createVNode("span", null, [formatValue.value]);
  }
});
const BkAnimateNumber = withInstall(Component$E);
const on$1 = (() => {
  if (document.addEventListener) {
    return (element, event, handler) => {
      if (element && event && handler) {
        element.addEventListener(event, handler, true);
      }
    };
  }
  return (element, event, handler) => {
    if (element && event && handler) {
      element.attachEvent(`on${event}`, handler);
    }
  };
})();
const off$1 = (() => {
  if (document.removeEventListener) {
    return (element, event, handler) => {
      if (element && event) {
        element.removeEventListener(event, handler, true);
      }
    };
  }
  return (element, event, handler) => {
    if (element && event) {
      element.detachEvent(`on${event}`, handler);
    }
  };
})();
var Component$D = defineComponent({
  name: "Affix",
  props: {
    offsetTop: PropTypes.number.def(0),
    offsetBottom: PropTypes.number,
    target: PropTypes.string.def(""),
    zIndex: PropTypes.number.def(1e3)
  },
  emits: ["change"],
  setup(props2, {
    emit,
    slots
  }) {
    const point = ref(null);
    const root = ref(null);
    const targetEl = ref();
    const styles = ref({});
    const {
      proxy
    } = getCurrentInstance();
    const affixWidth = ref(0);
    const offsetStyles = computed(() => __spreadProps(__spreadValues({}, styles.value), {
      "z-index": props2.zIndex
    }));
    onMounted(() => {
      affixWidth.value = proxy.$el.offsetWidth;
      targetEl.value = props2.target ? document.querySelector(props2.target) : window;
      on$1(targetEl.value, "scroll", listenScroll);
      on$1(targetEl.value, "resize", listenScroll);
      nextTick(() => {
        handleScroll2();
      });
    });
    const affix2 = ref(false);
    const pointClass = computed(() => classes({
      "lesscode-bk-affix": affix2.value
    }));
    const offsetType = computed(() => props2.offsetBottom >= 0 ? "bottom" : "top");
    const setTargetLoop = () => {
      if (offsetType.value === "top") {
        styles.value = {
          top: `${targetEl.value.getBoundingClientRect().top + props2.offsetTop}px`
        };
      } else {
        styles.value = {
          bottom: `${window.innerHeight - targetEl.value.getBoundingClientRect().bottom + props2.offsetBottom}px`
        };
      }
    };
    const listenScroll = lodash.exports.throttle(() => {
      handleScroll2();
    }, 100);
    const getOffset = (element) => {
      const rect = element.value.getBoundingClientRect();
      const rect2 = targetEl.value === window ? {
        top: 0,
        left: 0
      } : targetEl.value.getBoundingClientRect();
      const clientTop = targetEl.value.clientTop || 0;
      const clientLeft = targetEl.value.clientLeft || 0;
      return {
        top: rect.top - rect2.top - clientTop,
        left: rect.left - rect2.left - clientLeft
      };
    };
    const handleScroll2 = () => {
      const rect = targetEl.value === window ? {
        top: 0,
        left: 0,
        bottom: window.innerHeight
      } : targetEl.value.getBoundingClientRect();
      const elOffset = getOffset(root);
      const windowHeight = targetEl.value === window ? targetEl.value.innerHeight : targetEl.value.clientHeight;
      const elHeight = point.value.offsetHeight;
      if (elOffset.top < props2.offsetTop && offsetType.value === "top" && !affix2.value) {
        affix2.value = true;
        styles.value = {
          position: "fixed",
          top: `${rect.top + props2.offsetTop}px`,
          left: `${rect.left + elOffset.left}px`,
          width: `${affixWidth.value}px`
        };
        if (targetEl.value !== window) {
          on$1(window, "scroll", setTargetLoop);
        }
        emit("change", true);
      } else if (elOffset.top > props2.offsetTop && offsetType.value === "top" && affix2.value) {
        affix2.value = false;
        styles.value = null;
        emit("change", false);
      }
      if (elOffset.top + props2.offsetBottom + elHeight > windowHeight && offsetType.value === "bottom" && !affix2.value) {
        affix2.value = true;
        styles.value = {
          bottom: `${window.innerHeight - rect.bottom + props2.offsetBottom}px`,
          left: `${rect.left + elOffset.left}px`,
          width: `${affixWidth.value}px`
        };
        if (targetEl.value !== window) {
          on$1(window, "scroll", setTargetLoop);
        }
        emit("change", true);
      } else if (elOffset.top + props2.offsetBottom + elHeight < windowHeight && offsetType.value === "bottom" && affix2.value) {
        affix2.value = false;
        styles.value = null;
        emit("change", false);
      }
    };
    onBeforeUnmount(() => {
      off$1(targetEl.value, "scroll", listenScroll);
      off$1(targetEl.value, "resize", listenScroll);
      off$1(window, "scroll", setTargetLoop);
    });
    return () => {
      var _a;
      return createVNode("div", {
        "ref": root
      }, [createVNode("div", {
        "ref": point,
        "class": pointClass.value,
        "style": offsetStyles.value
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
    };
  }
});
const BkAffix = withInstall(Component$D);
var Component$C = defineComponent({
  name: "Backtop",
  props: {
    visibilityHeight: PropTypes.number.def(200),
    target: PropTypes.string.def(""),
    right: PropTypes.number.def(40),
    bottom: PropTypes.number.def(40),
    extCls: PropTypes.string.def("")
  },
  setup(props2, {
    slots
  }) {
    const container2 = ref(null);
    const el = ref(null);
    const visible = ref(false);
    const zIndex = ref(bkZIndexManager.getModalNextIndex());
    const styleBottom = `${props2.bottom}px`;
    const styleRight = `${props2.right}px`;
    const scrollHandler = lodash.exports.throttle(() => {
      visible.value = el.value.scrollTop >= props2.visibilityHeight;
    }, 30);
    const scrollTop2 = () => {
      el.value.scrollTo({
        top: 0,
        behavior: "smooth"
      });
    };
    watch(() => visible, () => {
      zIndex.value = bkZIndexManager.getModalNextIndex();
    });
    onMounted(() => {
      container2.value = document;
      el.value = document.documentElement;
      if (props2.target) {
        el.value = document.querySelector(props2.target);
        if (!el.value) {
          throw new Error("target does not exist");
        }
        container2.value = el.value;
      }
      container2.value.addEventListener("scroll", scrollHandler);
    });
    onBeforeUnmount(() => {
      container2.value.removeEventListener("scroll", scrollHandler);
    });
    return () => createVNode(Transition, {
      "name": "lesscode-bk-fade"
    }, {
      default: () => {
        var _a, _b;
        return [visible.value ? createVNode("div", {
          "class": `lesscode-bk-backtop ${props2.extCls}`,
          "style": {
            right: styleRight,
            bottom: styleBottom,
            zIndex: zIndex.value
          },
          "onClick": scrollTop2
        }, [(_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(angleUp, {
          "class": "lesscode-bk-backtop-icon"
        }, null)]) : ""];
      }
    });
  }
});
const BkBacktop = withInstall(Component$C);
var Component$B = defineComponent({
  name: "Badge",
  props: {
    theme: PropTypes.string.def("primary"),
    count: PropTypes.oneOfType([String, Number]).def(1),
    position: PropTypes.string.def("top-right"),
    radius: PropTypes.string,
    valLength: PropTypes.number.def(3),
    overflowCount: PropTypes.number.def(99),
    dot: PropTypes.bool.def(false),
    visible: PropTypes.bool.def(false),
    extCls: PropTypes.string
  },
  emits: ["hover", "leave"],
  setup(props2, {
    emit
  }) {
    const numberCount = computed(() => {
      if (typeof props2.count === "string") {
        let valueText = props2.count;
        valueText += "";
        const output = [];
        let count = 0;
        valueText.split("").forEach((char) => {
          if (count < Number(props2.valLength)) {
            count += /[\u4e00-\u9fa5]/.test(char) ? 2 : 1;
            output.push(char);
          }
        });
        return output.join("");
      }
      return props2.count > props2.overflowCount ? `${props2.overflowCount}+` : props2.count;
    });
    const radiusStyle = computed(() => {
      const isRadius = props2.radius !== void 0 && /^\d+(%|px|em|rem|vh|vw)?$/.test(props2.radius);
      const radiusValue = isRadius && /^\d+$/.test(props2.radius) && `${props2.radius}px` || props2.radius;
      return {
        borderRadius: radiusValue
      };
    });
    const handleHover = () => {
      emit("hover");
    };
    const handleLeave = () => {
      emit("leave");
    };
    return {
      numberCount,
      handleHover,
      handleLeave,
      radiusStyle
    };
  },
  render() {
    var _a, _b, _c, _d, _e, _f;
    const wrapperClasses = classes({
      "lesscode-bk-badge-main": true
    }, this.$props.extCls);
    const badgeClass = classes({
      [`lesscode-bk-badge lesscode-bk-${this.$props.theme}`]: !!this.$props.theme,
      ["pinned "]: this.$slots.default,
      ["dot"]: this.$props.dot,
      [`${this.$props.position}`]: this.$slots.default,
      ["lesscode-bk-badge-icon is-icon"]: this.$slots.icon
    }, "");
    const number = !this.$props.dot ? createVNode("span", null, [this.numberCount]) : "";
    return createVNode("div", {
      "class": wrapperClasses
    }, [(_c = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)) != null ? _c : "", !this.$props.visible ? createVNode("span", {
      "class": badgeClass,
      "style": this.radiusStyle,
      "onMouseenter": this.handleHover,
      "onMouseleave": this.handleLeave
    }, [(_f = (_e = (_d = this.$slots).icon) == null ? void 0 : _e.call(_d)) != null ? _f : number]) : ""]);
  }
});
const BkBadge = withInstall(Component$B);
var Component$A = defineComponent({
  name: "Breadcrumb",
  props: {
    extCls: PropTypes.string,
    separator: PropTypes.string.def("/"),
    separatorClass: PropTypes.string,
    replace: PropTypes.bool,
    backRouter: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).def("")
  },
  setup(props2, {
    slots
  }) {
    const {
      proxy,
      appContext
    } = getCurrentInstance();
    provide("breadcrumb", props2);
    onMounted(() => {
      const items = proxy.$el.querySelectorAll(".lesscode-bk-breadcrumb-item");
      if (items.length) {
        items[items.length - 1].setAttribute("aria-current", "page");
      }
    });
    const classCtx = classes({
      "lesscode-bk-breadcrumb": true
    }, `${props2.extCls || ""}`);
    const goBack = () => {
      const {
        backRouter,
        replace
      } = props2;
      const {
        $router
      } = appContext.config.globalProperties;
      if (!$router)
        return;
      replace ? $router.replace(backRouter) : $router.push(backRouter);
    };
    return () => {
      var _a;
      return createVNode("div", {
        "class": classCtx,
        "aria-label": "Breadcrumb",
        "role": "navigation"
      }, [!slots.prefix && props2.backRouter ? createVNode("div", {
        "class": "lesscode-bk-breadcrumb-goback"
      }, [createVNode(arrowsLeft, {
        "onClick": goBack
      }, null)]) : "", slots.prefix ? createVNode("div", {
        "class": "lesscode-bk-breadcrumb-goback"
      }, [slots.prefix()]) : "", (_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var BreadcrumbItem = defineComponent({
  name: "BreadcrumbItem",
  props: {
    extCls: PropTypes.string,
    to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).def(""),
    replace: PropTypes.bool
  },
  emits: ["click"],
  setup(props2, {
    emit,
    slots
  }) {
    const {
      appContext
    } = getCurrentInstance();
    const parent = inject("breadcrumb");
    const router = appContext.config.globalProperties.$router;
    const handleClick = (e) => {
      emit("click", e);
      const {
        to,
        replace
      } = props2;
      if (!to || !router)
        return;
      replace ? router.replace(to) : router.push(to);
    };
    const classCtx = classes({
      "lesscode-bk-breadcrumb-item": true
    }, `${props2.extCls || ""}`);
    const renderSeparator = () => {
      if (slots.separator) {
        return slots.separator();
      }
      if (parent.separatorClass) {
        return createVNode("i", {
          "class": `lesscode-bk-breadcrumb-separator ${parent.separatorClass}`
        }, null);
      }
      if (parent.separator) {
        return createVNode("span", {
          "class": "lesscode-bk-breadcrumb-separator",
          "role": "presentation"
        }, [parent == null ? void 0 : parent.separator]);
      }
      return null;
    };
    return () => {
      var _a;
      return createVNode("span", {
        "class": classCtx
      }, [createVNode("span", {
        "ref": "link",
        "class": `lesscode-bk-breadcrumb-item-inner ${props2.to ? "is-link" : ""}`,
        "role": "link",
        "onClick": handleClick
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), renderSeparator()]);
    };
  }
});
const BkBreadcrumb = withInstallProps(Component$A, { Item: BreadcrumbItem });
let BkLoadingMode;
(function(BkLoadingMode2) {
  BkLoadingMode2["Default"] = "default";
  BkLoadingMode2["Spin"] = "spin";
})(BkLoadingMode || (BkLoadingMode = {}));
let BkLoadingSize;
(function(BkLoadingSize2) {
  BkLoadingSize2["Normal"] = "";
  BkLoadingSize2["Mini"] = "mini";
  BkLoadingSize2["Small"] = "small";
  BkLoadingSize2["Large"] = "large";
})(BkLoadingSize || (BkLoadingSize = {}));
let defaultIndicator;
function setDefaultIndicator(Indicator) {
  defaultIndicator = typeof Indicator === "function" ? Indicator : () => createVNode(Indicator, null, null);
}
const loadingTypes = {
  indicator: {
    type: Function
  },
  loading: PropTypes.bool.def(true),
  inline: PropTypes.bool.def(true),
  theme: {
    type: String
  },
  title: PropTypes.string.def(""),
  size: {
    type: String,
    default: BkLoadingSize.Normal
  },
  mode: {
    type: String,
    default: "default"
  },
  opacity: PropTypes.number.def(0.9),
  color: PropTypes.string.def("white"),
  zIndex: PropTypes.number.def(1),
  isDirective: PropTypes.bool.def(false)
};
var Component$z = defineComponent({
  name: "Loading",
  props: loadingTypes,
  setup(props2, ctx) {
    const dotIndicator = createVNode("div", {
      "class": "lesscode-bk-normal-indicator"
    }, [[1, 2, 3, 4].map((i2) => createVNode("span", {
      "class": `dot dot-${i2}`
    }, null))]);
    const spinIndicator = createVNode("div", {
      "class": "lesscode-bk-spin-indicator"
    }, [[1, 2, 3, 4, 5, 6, 7, 8].map((i2) => createVNode("span", {
      "class": `oval oval-${i2}`
    }, null))]);
    const zIndexStyle = computed(() => ({
      zIndex: props2.zIndex
    }));
    const maskStyle = computed(() => __spreadValues({
      opacity: props2.opacity,
      backgroundColor: props2.color
    }, zIndexStyle.value));
    const loadingWrapperCls = computed(() => classes({
      "lesscode-bk-loading-wrapper": props2.loading,
      "lesscode-bk-nested-loading": !!ctx.slots.default,
      "lesscode-bk-directive-loading": props2.isDirective
    }));
    const containerCls = computed(() => classes({
      [`lesscode-bk-loading-size-${props2.size}`]: !!props2.size,
      [`lesscode-bk-loading-${props2.theme}`]: !!props2.theme
    }, "lesscode-bk-loading-indicator"));
    const hasTitle = computed(() => !!props2.title);
    const indicator = computed(() => {
      const isSpinMode = props2.mode === BkLoadingMode.Spin;
      if (typeof props2.indicator === "function") {
        return createVNode(props2.indicator, null, null);
      }
      if (typeof defaultIndicator === "function") {
        return createVNode(defaultIndicator, null, null);
      }
      return isSpinMode ? spinIndicator : dotIndicator;
    });
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": loadingWrapperCls.value
      }, [(_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a), props2.loading && [(ctx.slots.default || props2.isDirective) && createVNode("div", {
        "class": "lesscode-bk-loading-mask",
        "style": maskStyle.value
      }, null), createVNode("div", {
        "class": containerCls.value,
        "style": zIndexStyle.value
      }, [indicator.value, hasTitle.value && createVNode("div", {
        "class": "lesscode-bk-loading-title"
      }, [props2.title])])]]);
    };
  }
});
const INSTANCE_KEY = Symbol("vBkLoading");
const createInstance$1 = (el, binding) => {
  var _a, _b, _c, _d, _e;
  const getBindingProp = (key2) => {
    var _a2, _b2;
    return (_b2 = (_a2 = binding.value) == null ? void 0 : _a2[key2]) != null ? _b2 : void 0;
  };
  const options = reactive({
    indicator: getBindingProp("indicator"),
    loading: (_a = getBindingProp("loading")) != null ? _a : false,
    inline: (_b = getBindingProp("inline")) != null ? _b : false,
    theme: getBindingProp("theme"),
    title: (_c = getBindingProp("title")) != null ? _c : "",
    size: (_d = getBindingProp("size")) != null ? _d : "",
    mode: getBindingProp("mode"),
    opacity: getBindingProp("opacity"),
    color: (_e = getBindingProp("color")) != null ? _e : "white",
    zIndex: getBindingProp("zIndex"),
    isDirective: true
  });
  const div = document.createElement("div");
  Object.assign(div.style, {
    position: "absolute",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  });
  Object.assign(el.style, {
    position: "relative"
  });
  const instance = createApp({
    render: () => h$1(Component$z, options)
  });
  el[INSTANCE_KEY] = {
    options,
    instance,
    vm: instance.mount(div)
  };
  el.appendChild(div);
};
const updateOptions = (newOptions, originalOptions) => {
  Object.keys(newOptions).forEach((key2) => {
    if (newOptions[key2] !== originalOptions[key2]) {
      originalOptions[key2] = newOptions[key2];
    }
  });
};
const vBkloading = {
  mounted(el, binding) {
    if (binding.value) {
      createInstance$1(el, binding);
    }
  },
  updated(el, binding) {
    var _a, _b, _c;
    const instance = el[INSTANCE_KEY];
    const { value } = binding;
    updateOptions(value, instance.options);
    if ((_c = (_b = (_a = instance == null ? void 0 : instance.vm) == null ? void 0 : _a.$el) == null ? void 0 : _b.parentNode) == null ? void 0 : _c.style) {
      instance.vm.$el.parentNode.style.display = value.loading ? "" : "none";
    }
  },
  unmounted(el) {
    var _a, _b, _c;
    const instance = el[INSTANCE_KEY];
    el == null ? void 0 : el.removeChild((_b = (_a = instance == null ? void 0 : instance.vm) == null ? void 0 : _a.$el) == null ? void 0 : _b.parentNode);
    (_c = instance == null ? void 0 : instance.instance) == null ? void 0 : _c.unmount();
    el[INSTANCE_KEY] = null;
  }
};
const BkLoading = withInstallProps(Component$z, {
  setDefaultIndicator,
  BkLoadingMode,
  BkLoadingSize
}, true, {
  name: "loading",
  directive: vBkloading
});
const btnSizes = ["", "small", "large"];
const buttonProps = {
  theme: PropTypes.theme(),
  hoverTheme: PropTypes.theme(),
  size: {
    type: String,
    default: btnSizes[0]
  },
  title: PropTypes.string,
  icon: PropTypes.string,
  iconRight: PropTypes.string,
  disabled: PropTypes.bool,
  loading: PropTypes.bool,
  loadingMode: {
    type: String,
    default: "default"
  },
  outline: PropTypes.bool,
  text: PropTypes.bool,
  selected: PropTypes.bool,
  nativeType: {
    type: String,
    default: "button"
  }
};
var Component$y = defineComponent({
  name: "Button",
  props: buttonProps,
  emits: ["click", "mouseover"],
  setup(props2, {
    slots,
    emit
  }) {
    var _a;
    const isHover = ref(false);
    const showSlot = (_a = slots.default) != null ? _a : false;
    const btnClsPrefix = "lesscode-bk-button";
    const isText = computed(() => props2.text && !props2.hoverTheme);
    const btnCls = computed(() => {
      const hoverTheme = props2.hoverTheme ? `${btnClsPrefix}-hover-${props2.hoverTheme}` : "";
      const btnThemeCls = props2.theme ? `${btnClsPrefix}-${props2.theme}` : "";
      const themeCls = props2.hoverTheme ? "" : btnThemeCls;
      return classes({
        "is-disabled": props2.disabled,
        "is-outline": props2.outline,
        "is-text": isText.value,
        "is-loading": props2.loading,
        "is-selected": props2.selected,
        [`${btnClsPrefix}-${props2.size}`]: props2.size && btnSizes.includes(props2.size),
        "no-slot": !showSlot
      }, `${themeCls} ${btnClsPrefix} ${hoverTheme}`);
    });
    const loadingTheme = computed(() => {
      if (props2.text || props2.outline || props2.hoverTheme) {
        if (isHover.value && !props2.text)
          return "white";
        if (props2.text && props2.disabled)
          return;
        return props2.hoverTheme || props2.theme;
      }
      return !props2.theme ? void 0 : "white";
    });
    const loadingSize = computed(() => isText.value || props2.size === BkLoadingSize.Small ? BkLoadingSize.Mini : BkLoadingSize.Small);
    const handleClick = (e) => {
      if (props2.loading)
        return;
      emit("click", e);
    };
    const handleMouseOver = (e) => {
      isHover.value = true;
      emit("mouseover", e);
    };
    const handleMouseout = () => {
      isHover.value = false;
    };
    return () => {
      var _a2;
      return createVNode("button", {
        "title": props2.title,
        "disabled": props2.disabled,
        "class": btnCls.value,
        "type": props2.nativeType,
        "onClick": handleClick,
        "onMouseover": handleMouseOver,
        "onMouseleave": handleMouseout
      }, [props2.loading && createVNode(BkLoading, mergeProps({
        "loading": true,
        "class": `${btnClsPrefix}-loading`,
        "mode": props2.loadingMode,
        "size": loadingSize.value
      }, loadingTheme.value ? {
        theme: loadingTheme.value
      } : {}), null), slots.default && createVNode("span", {
        "class": `${btnClsPrefix}-text`
      }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]);
    };
  }
});
var ButtonGroup = defineComponent({
  name: "ButtonGroup",
  props: {
    size: PropTypes.size()
  },
  setup(props2, ctx) {
    const btnGroupCls = computed(() => classes({
      [`lesscode-bk-button-group-${props2.size}`]: !!props2.size
    }, "lesscode-bk-button-group"));
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": btnGroupCls.value
      }, [(_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
const BkButton = withInstallProps(Component$y, { ButtonGroup });
var CollapseTransition = defineComponent({
  name: "CollapseTransition",
  setup(_props, {
    slots
  }) {
    const on2 = {
      onBeforeEnter(el) {
        if (!el.dataset)
          el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.style.maxHeight = "0";
        el.style.paddingTop = "0";
        el.style.paddingBottom = "0";
      },
      onEnter(el) {
        el.dataset.oldOverflow = el.style.overflow;
        if (el.scrollHeight !== 0) {
          el.style.maxHeight = `${el.scrollHeight}px`;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        } else {
          el.style.maxHeight = "0";
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
        el.style.overflow = "hidden";
      },
      onAfterEnter(el) {
        el.style.maxHeight = "";
        el.style.overflow = el.dataset.oldOverflow;
      },
      onBeforeLeave(el) {
        if (!el.dataset)
          el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.dataset.oldOverflow = el.style.overflow;
        el.style.maxHeight = `${el.scrollHeight}px`;
        el.style.overflow = "hidden";
      },
      onLeave(el) {
        if (el.scrollHeight !== 0) {
          el.style.maxHeight = "0";
          el.style.paddingTop = "0";
          el.style.paddingBottom = "0";
        }
      },
      onAfterLeave(el) {
        el.style.maxHeight = "";
        el.style.overflow = el.dataset.oldOverflow;
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      }
    };
    return {
      on: on2,
      slots
    };
  },
  render() {
    const name = resolveClassName("collapse-transition");
    return createVNode(Transition, mergeProps({
      "name": name
    }, this.on), {
      default: () => [this.slots.default ? this.slots.default() : null]
    });
  }
});
CollapseTransition.install = (Vue) => {
  Vue.component(CollapseTransition.name, CollapseTransition);
};
const inputType = {
  type: PropTypes.string.def("text"),
  clearable: PropTypes.bool,
  disabled: PropTypes.bool,
  readonly: PropTypes.bool,
  placeholder: PropTypes.string.def(""),
  prefixIcon: PropTypes.string,
  suffixIcon: PropTypes.string,
  suffix: PropTypes.string,
  prefix: PropTypes.string,
  step: PropTypes.integer,
  max: PropTypes.integer,
  min: PropTypes.integer,
  maxlength: PropTypes.integer,
  behavior: InputBehaviorType(),
  showWordLimit: PropTypes.bool,
  showControl: PropTypes.bool.def(true),
  showClearOnlyHover: PropTypes.bool.def(true),
  precision: PropTypes.number.def(0).validate((val) => val >= 0 && val < 20),
  modelValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  size: PropTypes.size(),
  rows: PropTypes.number,
  selectReadonly: PropTypes.bool.def(false),
  withValidate: PropTypes.bool.def(true)
};
let EVENTS$2;
(function(EVENTS2) {
  EVENTS2["UPDATE"] = "update:modelValue";
  EVENTS2["FOCUS"] = "focus";
  EVENTS2["BLUR"] = "blur";
  EVENTS2["CHANGE"] = "change";
  EVENTS2["CLEAR"] = "clear";
  EVENTS2["INPUT"] = "input";
  EVENTS2["KEYPRESS"] = "keypress";
  EVENTS2["KEYDOWN"] = "keydown";
  EVENTS2["KEYUP"] = "keyup";
  EVENTS2["ENTER"] = "enter";
  EVENTS2["PASTE"] = "paste";
  EVENTS2["COMPOSITIONSTART"] = "compositionstart";
  EVENTS2["COMPOSITIONUPDATE"] = "compositionupdate";
  EVENTS2["COMPOSITIONEND"] = "compositionend";
})(EVENTS$2 || (EVENTS$2 = {}));
function EventFunction(_value, _evt) {
  return true;
}
function CompositionEventFunction(evt) {
  return evt;
}
const inputEmitEventsType = {
  [EVENTS$2.UPDATE]: EventFunction,
  [EVENTS$2.FOCUS]: (evt) => evt,
  [EVENTS$2.BLUR]: (evt) => evt,
  [EVENTS$2.CHANGE]: EventFunction,
  [EVENTS$2.CLEAR]: () => true,
  [EVENTS$2.INPUT]: EventFunction,
  [EVENTS$2.KEYPRESS]: EventFunction,
  [EVENTS$2.KEYDOWN]: EventFunction,
  [EVENTS$2.KEYUP]: EventFunction,
  [EVENTS$2.ENTER]: EventFunction,
  [EVENTS$2.PASTE]: EventFunction,
  [EVENTS$2.COMPOSITIONSTART]: CompositionEventFunction,
  [EVENTS$2.COMPOSITIONUPDATE]: CompositionEventFunction,
  [EVENTS$2.COMPOSITIONEND]: CompositionEventFunction
};
var Component$x = defineComponent({
  name: "Input",
  inheritAttrs: false,
  props: inputType,
  emits: inputEmitEventsType,
  setup(props2, ctx) {
    const formItem = useFormItem();
    const t2 = useLocale("input");
    const isFocused = ref(false);
    const isCNInput = ref(false);
    const isTextArea = computed(() => props2.type === "textarea");
    const inputClsPrefix = computed(() => isTextArea.value ? resolveClassName("textarea") : resolveClassName("input"));
    const _a = ctx.attrs, {
      class: cls,
      style: style2
    } = _a, inputAttrs = __objRest(_a, [
      "class",
      "style"
    ]);
    const inputRef = ref();
    const inputCls = computed(() => classes({
      [`${inputClsPrefix.value}--${props2.size}`]: !!props2.size,
      "is-focused": isFocused.value,
      "is-readonly": props2.readonly && !props2.selectReadonly,
      "is-disabled": props2.disabled,
      "is-simplicity": props2.behavior === "simplicity",
      [`${cls}`]: !!cls
    }, inputClsPrefix.value));
    const suffixIconMap = {
      search: () => createVNode(search, null, null),
      password: () => createVNode(eye, {
        "onClick": handleVisibleChange
      }, null)
    };
    const suffixCls = getCls("suffix-icon");
    const suffixIcon = computed(() => {
      const icon = suffixIconMap[props2.type];
      if (pwdVisible.value) {
        return createVNode(unvisible, {
          "onClick": handleVisibleChange,
          "class": suffixCls
        }, null);
      }
      return icon ? createVNode(icon, {
        "class": suffixCls
      }, null) : null;
    });
    const isNumberInput = computed(() => props2.type === "number");
    const ceilMaxLength = computed(() => Math.floor(props2.maxlength));
    const pwdVisible = ref(false);
    const clearCls = computed(() => classes({
      "show-clear-only-hover": props2.showClearOnlyHover,
      [`${inputClsPrefix.value}--clear-icon`]: true
    }, suffixCls));
    const incControlCls = computed(() => classes({
      "is-disabled": props2.disabled || props2.modelValue >= props2.max
    }));
    const decControlCls = computed(() => classes({
      "is-disabled": props2.disabled || props2.modelValue <= props2.min
    }));
    watch(() => props2.modelValue, () => {
      var _a2;
      if (props2.withValidate) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change");
      }
    });
    ctx.expose({
      focus() {
        inputRef.value.focus();
      },
      clear
    });
    function clear() {
      if (props2.disabled)
        return;
      const resetVal = isNumberInput.value ? props2.min : "";
      ctx.emit(EVENTS$2.UPDATE, resetVal);
      ctx.emit(EVENTS$2.CHANGE, resetVal);
      ctx.emit(EVENTS$2.CLEAR);
    }
    function handleFocus(e) {
      isFocused.value = true;
      ctx.emit(EVENTS$2.FOCUS, e);
    }
    function handleBlur(e) {
      var _a2;
      isFocused.value = false;
      ctx.emit(EVENTS$2.BLUR, e);
      if (isNumberInput.value && Number.isInteger(parseInt(e.target.value, 10)) && (e.target.value > props2.max || e.target.value < props2.min)) {
        const val = e.target.value > props2.max ? props2.max : props2.min;
        ctx.emit(EVENTS$2.UPDATE, val);
        ctx.emit(EVENTS$2.CHANGE, val);
      }
      if (props2.withValidate) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur");
      }
    }
    function eventHandler(eventName) {
      return (e) => {
        e.stopPropagation();
        if (eventName === EVENTS$2.KEYDOWN && (e.code === "Enter" || e.key === "Enter" || e.keyCode === 13)) {
          ctx.emit(EVENTS$2.ENTER, e.target.value, e);
        }
        if (isCNInput.value && [EVENTS$2.INPUT, EVENTS$2.CHANGE].some((e2) => eventName === e2))
          return;
        if (eventName === EVENTS$2.INPUT) {
          ctx.emit(EVENTS$2.UPDATE, e.target.value);
        }
        ctx.emit(eventName, e.target.value, e);
      };
    }
    const [handleKeyup, handleKeydown, handleKeyPress, handlePaste, handleChange, handleInput] = [EVENTS$2.KEYUP, EVENTS$2.KEYDOWN, EVENTS$2.KEYPRESS, EVENTS$2.PASTE, EVENTS$2.CHANGE, EVENTS$2.INPUT].map(eventHandler);
    function handleCompositionStart() {
      isCNInput.value = true;
    }
    function handleCompositionEnd(e) {
      isCNInput.value = false;
      handleInput(e);
    }
    function handleNumber(step, INC = true) {
      var _a2;
      const numStep = parseInt(String(step), 10);
      const precision = Number.isInteger(props2.precision) ? props2.precision : 0;
      const val = parseFloat(((_a2 = props2.modelValue) != null ? _a2 : 0).toString());
      const factor = Number.isInteger(numStep) ? numStep : 1;
      let newVal = val + (INC ? factor : -1 * factor);
      if (Number.isInteger(props2.max)) {
        newVal = Math.min(newVal, props2.max);
      }
      if (Number.isInteger(props2.min)) {
        newVal = Math.max(newVal, props2.min);
      }
      return +newVal.toFixed(precision);
    }
    function handleInc() {
      if (props2.disabled)
        return;
      const newVal = handleNumber(props2.step);
      ctx.emit(EVENTS$2.UPDATE, newVal);
      ctx.emit(EVENTS$2.CHANGE, newVal);
    }
    function handleDec() {
      if (props2.disabled)
        return;
      const newVal = handleNumber(props2.step, false);
      ctx.emit(EVENTS$2.UPDATE, newVal);
      ctx.emit(EVENTS$2.CHANGE, newVal);
    }
    function getCls(name) {
      return `${inputClsPrefix.value}--${name}`;
    }
    function handleVisibleChange() {
      pwdVisible.value = !pwdVisible.value;
    }
    const bindProps = computed(() => {
      const val = typeof props2.modelValue === "undefined" || props2.modelValue === null ? {} : {
        value: props2.modelValue
      };
      return __spreadProps(__spreadValues({}, val), {
        maxlength: props2.maxlength,
        placeholder: props2.placeholder || t2.value.placeholder,
        readonly: props2.readonly,
        disabled: props2.disabled
      });
    });
    const eventListener = {
      onInput: handleInput,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onPaste: handlePaste,
      onChange: handleChange,
      onKeypress: handleKeyPress,
      onKeydown: handleKeydown,
      onKeyup: handleKeyup,
      onCompositionstart: handleCompositionStart,
      onCompositionend: handleCompositionEnd
    };
    return () => {
      var _a2, _b, _c, _d, _e, _f, _g;
      return createVNode("div", {
        "class": inputCls.value,
        "style": style2
      }, [(_c = (_b = (_a2 = ctx.slots) == null ? void 0 : _a2.prefix) == null ? void 0 : _b.call(_a2)) != null ? _c : props2.prefix && createVNode("div", {
        "class": getCls("prefix-area")
      }, [createVNode("span", {
        "class": getCls("prefix-area--text")
      }, [props2.prefix])]), isTextArea.value ? createVNode("textarea", mergeProps({
        "ref": inputRef,
        "spellcheck": false
      }, inputAttrs, eventListener, bindProps.value, {
        "rows": props2.rows
      }), null) : createVNode("input", mergeProps({
        "spellcheck": false
      }, inputAttrs, {
        "ref": inputRef,
        "class": `${inputClsPrefix.value}--text`,
        "type": pwdVisible.value && props2.type === "password" ? "text" : props2.type,
        "step": props2.step,
        "max": props2.max,
        "min": props2.min
      }, eventListener, bindProps.value), null), !isTextArea.value && props2.clearable && !!props2.modelValue && createVNode("span", {
        "class": clearCls.value,
        "onClick": clear
      }, [createVNode(close$1, null, null)]), suffixIcon.value, typeof props2.maxlength === "number" && (props2.showWordLimit || isTextArea.value) && createVNode("p", {
        "class": getCls("max-length")
      }, [((_d = props2.modelValue) != null ? _d : "").toString().length, createTextVNode("/"), createVNode("span", null, [ceilMaxLength.value])]), isNumberInput.value && props2.showControl && createVNode("div", {
        "class": getCls("number-control")
      }, [createVNode(downSmall, {
        "class": incControlCls.value,
        "onClick": handleInc
      }, null), createVNode(downSmall, {
        "class": decControlCls.value,
        "onClick": handleDec
      }, null)]), (_g = (_f = (_e = ctx.slots) == null ? void 0 : _e.suffix) == null ? void 0 : _f.call(_e)) != null ? _g : props2.suffix && createVNode("div", {
        "class": getCls("suffix-area")
      }, [createVNode("span", {
        "class": getCls("suffix-area--text")
      }, [props2.suffix])])]);
    };
  }
});
const BkInput = withInstall(Component$x);
var Component$w = defineComponent({
  name: "Card",
  props: {
    title: PropTypes.string,
    showHeader: PropTypes.bool.def(true),
    showFooter: PropTypes.bool.def(false),
    collapseStatus: PropTypes.bool.def(true),
    border: PropTypes.bool.def(true),
    disableHeaderStyle: PropTypes.bool.def(false),
    position: PropTypes.string.def("left"),
    isEdit: PropTypes.bool.def(false),
    isCollapse: PropTypes.bool.def(false)
  },
  emits: ["update:collapseStatus", "edit"],
  setup(props2, {
    emit
  }) {
    const collapseActive = ref(true);
    const showInput = ref(false);
    const renderTitle = ref("");
    const handleCollapse = () => {
      if (!props2.isCollapse) {
        return;
      }
      collapseActive.value = !collapseActive.value;
      emit("update:collapseStatus", collapseActive.value);
    };
    const clickEdit = () => {
      showInput.value = !showInput.value;
    };
    const saveEdit = () => {
      showInput.value = !showInput.value;
      emit("edit", renderTitle);
    };
    watch(() => props2.collapseStatus, (val) => {
      props2.isCollapse && (collapseActive.value = val);
    }, {
      immediate: true
    });
    watch(() => props2.title, (val) => {
      renderTitle.value = val;
    }, {
      immediate: true
    });
    return {
      collapseActive,
      showInput,
      renderTitle,
      handleCollapse,
      saveEdit,
      clickEdit
    };
  },
  render() {
    var _a, _b, _c, _d, _e, _f;
    const wrapperName = "lesscode-bk-card";
    const cardClass = classes({
      [`${wrapperName}`]: true,
      [`${wrapperName}-border-none`]: !this.$props.border
    }, "");
    const headClass = classes({
      [`${wrapperName}-head`]: true,
      [`${wrapperName}-head-${this.$props.position}`]: this.$props.isCollapse && this.$props.position,
      ["no-line-height"]: this.$props.disableHeaderStyle,
      ["collapse"]: !this.collapseActive
    }, "");
    const defaultHeader = createVNode("div", {
      "class": "title",
      "title": this.renderTitle
    }, [this.showInput ? createVNode(BkInput, {
      "class": `${wrapperName}-input`,
      "modelValue": this.renderTitle,
      "onUpdate:modelValue": ($event) => this.renderTitle = $event,
      "onBlur": this.saveEdit
    }, null) : this.renderTitle]);
    const defaultIcon = createVNode("span", {
      "class": `${wrapperName}-icon`,
      "onClick": this.handleCollapse
    }, [this.collapseActive ? createVNode(angleDown, null, null) : createVNode(angleRight, null, null)]);
    return createVNode("div", {
      "class": cardClass
    }, [this.$props.showHeader ? createVNode("div", {
      "class": headClass
    }, [this.$props.isCollapse && ((_c = (_b = (_a = this.$slots).icon) == null ? void 0 : _b.call(_a)) != null ? _c : defaultIcon), (_f = (_e = (_d = this.$slots).header) == null ? void 0 : _e.call(_d)) != null ? _f : defaultHeader, this.$props.isEdit && !this.showInput && createVNode(editLine, {
      "class": `${wrapperName}-edit`,
      "onClick": this.clickEdit
    }, null)]) : "", createVNode(CollapseTransition, null, {
      default: () => {
        var _a2, _b2, _c2, _d2, _e2, _f2;
        return [withDirectives(createVNode("div", null, [createVNode("div", {
          "class": `${wrapperName}-body`
        }, [(_c2 = (_b2 = (_a2 = this.$slots).default) == null ? void 0 : _b2.call(_a2)) != null ? _c2 : "Content"]), this.$props.showFooter ? createVNode("div", {
          "class": `${wrapperName}-footer`
        }, [(_f2 = (_e2 = (_d2 = this.$slots).footer) == null ? void 0 : _e2.call(_d2)) != null ? _f2 : "Footer"]) : ""]), [[vShow, this.collapseActive]])];
      }
    })]);
  }
});
const BkCard = withInstall(Component$w);
const checkboxGroupKey = Symbol("CheckboxGroup");
function useFocus$1() {
  const isFocus = ref(false);
  const blur = () => {
    isFocus.value = false;
  };
  const focus = () => {
    isFocus.value = true;
  };
  return [
    isFocus,
    {
      blur,
      focus
    }
  ];
}
const useCheckbox = () => {
  const currentInstance = getCurrentInstance();
  const {
    props: props2,
    emit
  } = currentInstance;
  const checkboxGroup = inject(checkboxGroupKey, EMPTY_OBJ);
  const isGroup = !isEmptyObj(checkboxGroup);
  const inputRef = ref();
  const isChecked = ref(props2.checked);
  const isDisabled = computed(() => {
    if (isGroup && checkboxGroup.props.disabled) {
      return true;
    }
    return props2.disabled;
  });
  const triggerChange = () => {
    const nextValue = isChecked.value ? props2.trueLabel : props2.falseLabel;
    emit("update:modelValue", nextValue);
    emit("change", nextValue);
    if (isGroup) {
      checkboxGroup.handleChange();
    }
    nextTick(() => {
      if (inputRef.value.checked !== isChecked.value) {
        inputRef.value.checked = isChecked.value;
      }
    });
  };
  if (isGroup) {
    watch(() => checkboxGroup.props.modelValue, (modelValue) => {
      isChecked.value = modelValue.includes(props2.label);
    }, {
      deep: true
    });
  } else {
    watch(() => props2.modelValue, (modelValue) => {
      if (modelValue === "") {
        return;
      }
      isChecked.value = modelValue === props2.trueLabel;
    }, {
      immediate: true
    });
  }
  watch(() => props2.checked, () => {
    isChecked.value = props2.checked;
    if (props2.immediateEmitChange !== false) {
      triggerChange();
    }
  });
  const setChecked = (value = true) => {
    isChecked.value = value;
  };
  const handleChange = (event) => {
    if (isDisabled.value) {
      return;
    }
    const $targetInput = event.target;
    isChecked.value = $targetInput.checked;
    triggerChange();
  };
  onMounted(() => {
    if (isGroup) {
      checkboxGroup.register(currentInstance.proxy);
    }
  });
  onBeforeUnmount(() => {
    if (isGroup) {
      checkboxGroup.unregister(currentInstance.proxy);
    }
  });
  return {
    inputRef,
    isChecked,
    isDisabled,
    setChecked,
    handleChange
  };
};
const checkboxProps = {
  modelValue: PropTypes.oneOfType([String, Number, Boolean]),
  label: PropTypes.oneOfType([String, Number, Boolean]),
  trueLabel: PropTypes.oneOfType([String, Number, Boolean]).def(true),
  falseLabel: PropTypes.oneOfType([String, Number, Boolean]).def(false),
  disabled: PropTypes.bool.def(false),
  checked: PropTypes.bool.def(false),
  indeterminate: PropTypes.bool,
  beforeChange: PropTypes.func,
  size: PropTypes.size().def(SizeEnum.LARGE),
  immediateEmitChange: PropTypes.bool.def(true)
};
var Component$v = defineComponent({
  name: "Checkbox",
  props: checkboxProps,
  emits: ["update:modelValue", "change"],
  setup(props2) {
    const [isFocus, {
      blur: handleBlur,
      focus: handleFocus
    }] = useFocus$1();
    const {
      inputRef,
      isChecked,
      isDisabled,
      setChecked,
      handleChange
    } = useCheckbox();
    return {
      inputRef,
      isFocus,
      isChecked,
      isDisabled,
      setChecked,
      handleBlur,
      handleFocus,
      handleChange,
      size: props2.size
    };
  },
  render() {
    const checkboxClass = classes({
      "lesscode-bk-checkbox": true,
      "is-focused": this.isFocus,
      "is-checked": this.isChecked,
      "is-disabled": this.isDisabled,
      "is-indeterminated": this.indeterminate
    });
    const renderLabel = () => {
      if (!this.label && !this.$slots.default) {
        return null;
      }
      return createVNode("span", {
        "class": "lesscode-bk-checkbox-label"
      }, [this.$slots.default ? this.$slots.default() : this.label]);
    };
    return createVNode("label", {
      "class": checkboxClass
    }, [createVNode("span", {
      "class": [resolveClassName("checkbox-input"), this.size]
    }, [createVNode("input", {
      "ref": "inputRef",
      "role": "checkbox",
      "type": "checkbox",
      "class": "lesscode-bk-checkbox-original",
      "disabled": this.isDisabled,
      "checked": this.isChecked,
      "onChange": this.handleChange
    }, null)]), renderLabel()]);
  }
});
const checkboxGroupProps = {
  name: PropTypes.string.def(""),
  modelValue: PropTypes.array,
  disabled: PropTypes.bool,
  withValidate: PropTypes.bool.def(true)
};
var BkCheckboxGroup = defineComponent({
  name: "CheckboxGroup",
  props: checkboxGroupProps,
  emits: ["change", "update:modelValue"],
  setup(props2, context) {
    const formItem = useFormItem();
    const checkboxInstanceList = [];
    const register = (checkboxContext) => {
      checkboxInstanceList.push(checkboxContext);
    };
    const unregister = (checkboxContext) => {
      const index2 = checkboxInstanceList.indexOf(checkboxContext);
      if (index2 > -1) {
        checkboxInstanceList.splice(index2, 1);
      }
    };
    const handleChange = () => {
      const nextValue = checkboxInstanceList.reduce((result, checkboxInstance) => {
        if (checkboxInstance.isChecked) {
          result.push(checkboxInstance.label);
        }
        return result;
      }, []);
      context.emit("update:modelValue", nextValue);
      context.emit("change", nextValue);
    };
    provide(checkboxGroupKey, {
      name: "CheckboxGroup",
      props: props2,
      register,
      unregister,
      handleChange
    });
    watch(() => props2.modelValue, () => {
      var _a;
      if (props2.withValidate) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
      }
    });
    onMounted(() => {
      const modelValue = props2.modelValue || [];
      checkboxInstanceList.forEach((checkboxInstance) => {
        if (modelValue.includes(checkboxInstance.label)) {
          checkboxInstance.setChecked(true);
        }
      });
    });
    return {};
  },
  render() {
    var _a;
    return createVNode("div", {
      "class": "lesscode-bk-checkbox-group"
    }, [(_a = this.$slots) == null ? void 0 : _a.default()]);
  }
});
const BkCheckbox = withInstallProps(Component$v, { Group: BkCheckboxGroup });
const propsCollapse = {
  list: PropTypes.arrayOf(PropTypes.any).def([]),
  idFiled: PropTypes.string.def("$index"),
  titleField: PropTypes.string.def("name"),
  contentField: PropTypes.string.def("content"),
  modelValue: PropTypes.oneOfType([
    PropTypes.arrayOf(PropTypes.number).def([]),
    PropTypes.arrayOf(PropTypes.string).def([]),
    PropTypes.number.def(-1)
  ]),
  accordion: PropTypes.bool.def(false),
  hasHeaderBorder: PropTypes.bool.def(false),
  hasHeaderHover: PropTypes.bool.def(true),
  headerIcon: PropTypes.string.def(""),
  useCardTheme: PropTypes.bool.def(false),
  headerIconAlign: PropTypes.string.def("left")
};
const CollapsePanelEventProps = {
  itemClick: {
    type: Function
  }
};
const propsCollapsePanel = __spreadValues({
  name: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def(""),
  title: PropTypes.any,
  content: PropTypes.string,
  disabled: PropTypes.bool.def(false),
  isFormList: PropTypes.bool.def(false),
  renderDirective: renderDirectiveType(),
  modelValue: PropTypes.bool.def(false),
  alone: PropTypes.bool.def(false),
  icon: PropTypes.string.def("angle-right")
}, CollapsePanelEventProps);
function _isSlot$8(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
var CollapsePanel = defineComponent({
  name: "CollapsePanel",
  props: propsCollapsePanel,
  emits: ["change", "update:modelValue", "after-leave", "before-enter"],
  setup(props2, {
    emit,
    slots
  }) {
    let localActiveItems = null;
    let handleItemClick = null;
    const isActive = ref(props2.modelValue);
    watch(() => props2.modelValue, (newVal) => {
      isActive.value = newVal;
    });
    if (!props2.alone) {
      localActiveItems = inject("localActiveItems");
      handleItemClick = inject("handleItemClick");
      watch(localActiveItems, (newVal) => {
        if (newVal == null ? void 0 : newVal.length) {
          isActive.value = newVal.includes(props2.name);
        }
      }, {
        immediate: true
      });
    }
    function toCamelCase(str) {
      const words = str.split("-");
      const camelCaseWords = words.map((word2) => word2.charAt(0).toUpperCase() + word2.slice(1));
      return camelCaseWords.join("");
    }
    function clickItem() {
      const {
        disabled,
        name,
        itemClick
      } = props2;
      if (disabled)
        return;
      const data2 = {
        name
      };
      isActive.value = !isActive.value;
      emit("update:modelValue", isActive.value);
      emit("change", data2);
      if (typeof itemClick === "function") {
        itemClick(data2);
      } else if (typeof handleItemClick === "function") {
        handleItemClick({
          name
        });
      }
    }
    function getContent() {
      if (props2.content) {
        return props2.content;
      }
      if (typeof slots.content === "function") {
        return slots.content(h$1);
      }
      return slots.content;
    }
    function renderPanel() {
      if (props2.renderDirective === "if" && !isActive.value) {
        return "";
      }
      return withDirectives(createVNode("div", {
        "class": `lesscode-bk-collapse-content ${isActive.value && "active" || ""}`
      }, [getContent()]), [[vShow, isActive.value]]);
    }
    function renderHeader(icon) {
      if (slots.header) {
        if (typeof slots.header === "function") {
          return slots.header(h$1);
        }
        return slots.header;
      }
      let title;
      if (slots.default) {
        if (typeof slots.default === "function") {
          title = slots.default(h$1);
        } else {
          title = slots.default;
        }
      } else {
        title = props2.title;
      }
      return createVNode(Fragment, null, [createVNode("div", {
        "class": "lesscode-bk-collapse-header"
      }, [createVNode("span", {
        "class": "lesscode-bk-collapse-title"
      }, [title]), icon])]);
    }
    return {
      isActive,
      collapseIcon: BkIcon[`${toCamelCase(props2.icon)}`],
      clickItem,
      renderPanel,
      renderHeader
    };
  },
  render() {
    let _slot;
    return createVNode("div", {
      "class": `lesscode-bk-collapse-item ${this.disabled ? "is-disabled" : ""} ${this.isActive ? "lesscode-bk-collapse-item-active" : ""}`
    }, [createVNode("div", {
      "onClick": () => this.clickItem()
    }, [this.renderHeader(createVNode(this.collapseIcon, {
      "class": `lesscode-bk-collapse-icon ${this.isActive && "rotate-icon" || ""}`
    }, null))]), createVNode(CollapseTransition, null, _isSlot$8(_slot = this.renderPanel()) ? _slot : {
      default: () => [_slot]
    })]);
  }
});
var Collapse = defineComponent({
  name: "Collapse",
  props: propsCollapse,
  emits: ["item-click", "update:modelValue", "after-leave", "before-enter"],
  setup(props2, {
    emit,
    slots
  }) {
    const localActiveItems = ref([]);
    watch(() => [props2.modelValue], () => {
      const value = props2.modelValue;
      if (Array.isArray(value)) {
        localActiveItems.value = [...value];
      } else if (typeof value !== "undefined") {
        localActiveItems.value = [value];
      } else {
        localActiveItems.value = [];
      }
    }, {
      immediate: true
    });
    const handleItemClick = (item) => {
      const {
        name
      } = item;
      if (props2.accordion) {
        const activeItemIndex = localActiveItems.value.findIndex((local) => local === name);
        if (activeItemIndex >= 0) {
          localActiveItems.value.splice(activeItemIndex, 1);
        } else {
          localActiveItems.value = [name];
        }
      } else {
        const activeItemIndex = localActiveItems.value.findIndex((local) => local === name);
        if (activeItemIndex >= 0) {
          localActiveItems.value.splice(activeItemIndex, 1);
        } else {
          localActiveItems.value.push(name);
        }
      }
      emit("item-click", item);
      emit("update:modelValue", localActiveItems.value);
    };
    provide("localActiveItems", localActiveItems);
    provide("handleItemClick", handleItemClick);
    let className = "lesscode-bk-collapse-wrapper";
    if (props2.hasHeaderBorder) {
      className += " lesscode-bk-collapse-header-border";
    }
    if (props2.hasHeaderHover) {
      className += " lesscode-bk-collapse-header-hover";
    }
    if (props2.useCardTheme) {
      className += " lesscode-bk-collapse-card";
    }
    if (props2.headerIconAlign === "left") {
      className += " lesscode-bk-collapse-icon-left";
    } else {
      className += " lesscode-bk-collapse-icon-right";
    }
    if (!Array.isArray(props2.list) || !props2.list.length) {
      return () => createVNode("div", {
        class: className
      }, [renderSlot(slots, "default", {
        props: {
          isList: true
        }
      })]);
    }
    const collapseData = computed(() => (props2.list || []).map((item, index2) => {
      if (typeof item === "string" || typeof item === "number" || typeof item === "boolean") {
        return {
          $index: index2,
          name: item
        };
      }
      return __spreadValues({
        $index: index2
      }, item);
    }));
    const renderItems = () => collapseData.value.map((item, index2) => {
      var _a, _b, _c;
      const name = item[props2.idFiled] || index2;
      let title = item[props2.titleField];
      const icon = props2.headerIcon || "angle-right";
      if (slots.title) {
        if (typeof slots.title === "function") {
          title = slots.title(item, index2);
        } else {
          title = slots.title;
        }
      }
      if (slots.default) {
        title = (_a = slots.default) == null ? void 0 : _a.call(slots, item, index2);
      }
      return createVNode(CollapsePanel, {
        "key": index2,
        "item-click": handleItemClick,
        "disabled": item.disabled,
        "name": name,
        "icon": icon,
        "isFormList": true,
        "title": title,
        "content": (_c = (_b = slots.content) == null ? void 0 : _b.call(slots, item, index2)) != null ? _c : item[props2.contentField]
      }, null);
    });
    return () => createVNode("div", {
      "class": className
    }, [renderItems()]);
  }
});
const BkCollapse = withInstallProps(Collapse, { CollapsePanel });
const propsMixin$1 = {
  isShow: PropTypes.bool.def(false),
  width: PropTypes.oneOfType([String, Number]).def("50%"),
  height: PropTypes.oneOfType([String, Number]).def("50%"),
  extCls: PropTypes.string || PropTypes.array,
  scrollable: PropTypes.bool.def(true),
  showMask: PropTypes.bool.def(true),
  closeIcon: PropTypes.bool.def(true),
  escClose: PropTypes.bool.def(true),
  fullscreen: PropTypes.bool.def(false),
  size: j("size", {}),
  draggable: PropTypes.bool.def(true),
  quickClose: PropTypes.bool.def(true),
  transfer: PropTypes.oneOfType([Boolean, String, HTMLElement]).def(false),
  zIndex: PropTypes.oneOfType([String, Number]).def("inherit"),
  maxHeight: PropTypes.string,
  direction: PropTypes.string,
  title: PropTypes.string.def(""),
  animateType: PropTypes.string.def("slide"),
  renderDirective: renderDirectiveType(),
  beforeClose: PropTypes.custom(() => true),
  dialogType: dialogTypeUnion(),
  multiInstance: PropTypes.bool.def(true),
  infoType: PropTypes.theme()
};
var Component$u = defineComponent({
  name: "Modal",
  props: __spreadValues({}, propsMixin$1),
  emits: ["quick-close", "quickClose", "hidden", "shown", "close"],
  data() {
    return {
      visible: false,
      closeTimer: null,
      bkPopIndexManager: null
    };
  },
  computed: {
    dialogWidth() {
      return /^\d+$/.test(`${this.width}`) ? `${this.width}px` : this.width;
    },
    dialogHeight() {
      return /^\d+$/.test(`${this.height}`) ? `${this.height}px` : this.height;
    },
    compStyle() {
      return {
        width: this.dialogWidth,
        height: this.dialogHeight,
        minHeigth: `${200}px`,
        display: this.visible ? "inherit" : "none",
        zIndex: this.zIndex || "inherit"
      };
    },
    fullscreenStyle() {
      return {
        width: `${100}%`,
        height: `${100}%`
      };
    }
  },
  watch: {
    isShow: {
      handler(val) {
        if (val) {
          this.closeTimer && clearTimeout(this.closeTimer);
          this.closeTimer = null;
          this.visible = val;
        } else {
          this.closeTimer = setTimeout(() => {
            this.$emit("hidden");
            this.visible = val;
          }, 250);
        }
      },
      immediate: true
    },
    visible: {
      handler(val) {
        var _a, _b;
        if (val) {
          this.$nextTick(() => {
            this.bkPopIndexManager.onMaskClick((_e) => {
              this.handleClickOutSide();
            }, this.$el);
            const hideMaskStyle = {
              "background-color": "rgba(0,0,0,0)"
            };
            const appendStyle = this.showMask ? {} : hideMaskStyle;
            this.bkPopIndexManager.show(this.$el, this.showMask, appendStyle, !!this.transfer, this.zIndex);
            this.$emit("shown");
          });
        } else {
          (_a = this.bkPopIndexManager) == null ? void 0 : _a.hide(this.$el, !!this.transfer);
          (_b = this.bkPopIndexManager) == null ? void 0 : _b.destroy();
        }
      },
      immediate: true
    }
  },
  created() {
  },
  mounted() {
    var _a;
    const popConfig = __spreadValues(__spreadValues({}, this.$props), {
      transfer: this.transfer === "parent" ? (_a = this.$el) == null ? void 0 : _a.parentElement : this.transfer
    });
    this.bkPopIndexManager = new BKPopIndexManager(popConfig);
  },
  beforeUnmount() {
    var _a, _b;
    if (this.visible) {
      (_a = this.bkPopIndexManager) == null ? void 0 : _a.hide(this.$el);
      (_b = this.bkPopIndexManager) == null ? void 0 : _b.destroy();
    }
  },
  methods: {
    handleClickOutSide() {
      if (this.quickClose) {
        this.$emit("close");
        this.$emit("quick-close", this.$el);
        this.$emit("quickClose", this.$el);
      }
    }
  },
  render() {
    const maxHeight = this.maxHeight ? {
      maxHeight: this.maxHeight
    } : {};
    const bodyClass = `${resolveClassName("modal-body")} ${this.animateType === "slide" ? this.direction : ""}`;
    return createVNode("div", {
      "class": [resolveClassName("modal-wrapper"), this.extCls, this.size, this.fullscreen ? "fullscreen" : ""],
      "style": [this.compStyle, this.fullscreen ? this.fullscreenStyle : ""]
    }, [createVNode(Transition, {
      "name": this.animateType
    }, {
      default: () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        return [this.isShow ? createVNode("div", {
          "class": bodyClass
        }, [createVNode("div", {
          "class": resolveClassName("modal-header")
        }, [(_c = (_b = (_a = this.$slots).header) == null ? void 0 : _b.call(_a)) != null ? _c : ""]), createVNode("div", {
          "class": resolveClassName("modal-content"),
          "style": [this.dialogType === "show" ? "padding-bottom: 20px" : "", __spreadValues({}, maxHeight)]
        }, [(_f = (_e = (_d = this.$slots).default) == null ? void 0 : _e.call(_d)) != null ? _f : ""]), this.dialogType === "show" ? "" : createVNode("div", {
          "class": resolveClassName("modal-footer")
        }, [(_i = (_h = (_g = this.$slots).footer) == null ? void 0 : _h.call(_g)) != null ? _i : ""]), createVNode("div", {
          "class": [resolveClassName("modal-close"), this.closeIcon ? "" : "close-icon"]
        }, [(_l = (_k = (_j = this.$slots).close) == null ? void 0 : _k.call(_j)) != null ? _l : ""])]) : ""];
      }
    })]);
  }
});
const BkModal = withInstallProps(Component$u, { propsMixin: propsMixin$1 }, true);
const props$1 = __spreadProps(__spreadValues({}, propsMixin$1), {
  width: PropTypes.oneOfType([String, Number]).def(""),
  height: PropTypes.oneOfType([String, Number]).def(""),
  confirmText: PropTypes.string,
  cancelText: PropTypes.string,
  prevText: PropTypes.string,
  nextText: PropTypes.string,
  current: PropTypes.number.def(1),
  totalStep: PropTypes.number,
  title: PropTypes.string.def("title"),
  headerAlign: alignType().def(AlignEnum.LEFT),
  footerAlign: alignType().def(AlignEnum.RIGHT),
  theme: PropTypes.theme().def(ThemeEnum.PRIMARY),
  dialogType: dialogTypeUnion(),
  isLoading: PropTypes.bool.def(false)
});
function _isSlot$7(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
var Dialog = defineComponent({
  name: "Dialog",
  components: {
    BkModal,
    BkButton
  },
  props: props$1,
  emits: ["closed", "update:isShow", "confirm", "prev", "next", "value-change"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("dialog");
    const localConfirmText = computed(() => {
      if (props2.confirmText === void 0) {
        return t2.value.ok;
      }
      return props2.confirmText;
    });
    const localCancelText = computed(() => {
      if (props2.cancelText === void 0) {
        return t2.value.cancel;
      }
      return props2.cancelText;
    });
    const localPrevText = computed(() => {
      if (props2.prevText === void 0) {
        return t2.value.prev;
      }
      return props2.prevText;
    });
    const localNextText = computed(() => {
      if (props2.nextText === void 0) {
        return t2.value.next;
      }
      return props2.nextText;
    });
    const data2 = reactive({
      positionX: 0,
      positionY: 0,
      moveStyle: {
        top: "",
        left: ""
      }
    });
    const isModalShow = ref(props2.isShow);
    onMounted(() => {
      if (props2.escClose) {
        addEventListener("keydown", escCloseHandler);
      }
    });
    onBeforeUnmount(() => {
      if (props2.escClose) {
        removeEventListener("keydown", escCloseHandler);
      }
    });
    watch(() => props2.isShow, (val) => {
      if (!val) {
        setTimeout(() => {
          data2.moveStyle = {
            top: "50%",
            left: "50%"
          };
          data2.positionX = 0;
          data2.positionY = 0;
          isModalShow.value = false;
        }, 250);
      } else {
        isModalShow.value = true;
      }
      emit("value-change", val);
    });
    const handleClose = () => {
      emit("update:isShow", false);
      emit("closed");
      isModalShow.value = false;
    };
    const handleConfirm = () => {
      emit("update:isShow", false);
      emit("confirm");
    };
    const hasFooter = computed(() => ["process", "operation", "confirm"].includes(props2.dialogType));
    const escCloseHandler = (e) => {
      if (props2.isShow && props2.closeIcon) {
        if (e.keyCode === 27) {
          handleClose();
        }
      }
    };
    const handlePrevStep = () => {
      emit("prev");
    };
    const handleNextStep = () => {
      emit("next");
    };
    const moveHandler = (e) => {
      if (props2.fullscreen) {
        return false;
      }
      if (!props2.draggable) {
        return false;
      }
      const odiv = e.target;
      const parentHeight = e.currentTarget.parentNode.parentNode.offsetHeight;
      const parentWidth = e.currentTarget.parentNode.parentNode.offsetWidth;
      let disX;
      let disY;
      if (data2.positionX !== 0 && data2.positionY !== 0) {
        disX = e.clientX - data2.positionX;
        disY = e.clientY - data2.positionY;
      } else {
        disX = e.clientX - odiv.offsetLeft;
        disY = e.clientY - odiv.offsetTop;
      }
      document.onmousemove = (e2) => {
        const boxLeft = window.innerWidth - parentWidth;
        const boxTop = window.innerHeight - parentHeight;
        let left2 = e2.clientX - disX;
        let top2 = e2.clientY - disY;
        if (boxLeft / 2 - left2 <= 0) {
          left2 = boxLeft / 2;
        } else if (boxLeft / 2 + left2 <= 0) {
          left2 = -boxLeft / 2;
        }
        if (boxTop / 2 - top2 <= 0) {
          top2 = boxTop / 2;
        } else if (boxTop / 2 + top2 <= 0) {
          top2 = -boxTop / 2;
        }
        data2.positionX = left2;
        data2.positionY = top2;
        data2.moveStyle.left = `calc(50% + ${left2}px)`;
        data2.moveStyle.top = `calc(50% + ${top2}px)`;
      };
      document.onmouseup = () => {
        document.onmousemove = null;
        document.onmouseup = null;
      };
    };
    return {
      data: data2,
      handleClose,
      handleConfirm,
      escCloseHandler,
      moveHandler,
      handlePrevStep,
      handleNextStep,
      hasFooter,
      isModalShow,
      localConfirmText,
      localCancelText,
      localPrevText,
      localNextText
    };
  },
  render() {
    const renderIcon = () => {
      const iconMap = {
        loading: createVNode(spinner, {
          "class": [resolveClassName("info-icon"), "primary"]
        }, null),
        warning: createVNode(warn, {
          "class": [resolveClassName("info-icon"), "warning"]
        }, null),
        success: createVNode(success, {
          "class": [resolveClassName("info-icon"), "success"]
        }, null),
        danger: createVNode(close$1, {
          "class": [resolveClassName("info-icon"), "danger"]
        }, null)
      };
      return iconMap[this.infoType];
    };
    const dialogSlot = {
      header: () => {
        var _a, _b, _c, _d, _e, _f;
        return [createVNode("div", {
          "class": [resolveClassName("dialog-tool"), this.fullscreen || !this.draggable ? "" : "move", this.draggable ? "content-dragging" : ""],
          "onMousedown": this.moveHandler
        }, [(_c = (_b = (_a = this.$slots).tools) == null ? void 0 : _b.call(_a)) != null ? _c : ""]), createVNode("div", {
          "class": resolveClassName("dialog-header")
        }, [createVNode("div", {
          "class": resolveClassName("header-icon")
        }, [this.infoType ? renderIcon() : createVNode("slot", {
          "name": "info-icon"
        }, null)]), createVNode("span", {
          "class": resolveClassName("dialog-title"),
          "style": `text-align: ${this.headerAlign}`
        }, [(_f = (_e = (_d = this.$slots).header) == null ? void 0 : _e.call(_d)) != null ? _f : this.title])])];
      },
      default: () => {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)) != null ? _c : "default";
      },
      footer: () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        return createVNode("div", {
          "class": resolveClassName("dialog-footer"),
          "style": `text-align: ${this.footerAlign}`
        }, [this.dialogType === "process" ? (_c = (_b = (_a = this.$slots).footer) == null ? void 0 : _b.call(_a)) != null ? _c : createVNode(Fragment, null, [this.current === 1 ? "" : createVNode(BkButton, {
          "class": resolveClassName("dialog-perv"),
          "onClick": this.handlePrevStep
        }, {
          default: () => [this.localPrevText]
        }), this.current === this.totalStep ? "" : createVNode(BkButton, {
          "class": resolveClassName("dialog-next"),
          "onClick": this.handleNextStep
        }, {
          default: () => [this.localNextText]
        }), this.current === this.totalStep ? createVNode(BkButton, {
          "onClick": this.handleConfirm,
          "theme": this.theme,
          "loading": this.isLoading
        }, {
          default: () => [this.localConfirmText]
        }) : "", createVNode(BkButton, {
          "class": resolveClassName("dialog-cancel"),
          "onClick": this.handleClose,
          "disabled": this.isLoading
        }, {
          default: () => [this.localCancelText]
        })]) : "", this.dialogType === "operation" ? (_f = (_e = (_d = this.$slots).footer) == null ? void 0 : _e.call(_d)) != null ? _f : createVNode(Fragment, null, [createVNode(BkButton, {
          "onClick": this.handleConfirm,
          "theme": this.theme,
          "loading": this.isLoading
        }, {
          default: () => [this.localConfirmText]
        }), createVNode(BkButton, {
          "class": resolveClassName("dialog-cancel"),
          "onClick": this.handleClose,
          "disabled": this.isLoading
        }, {
          default: () => [this.localCancelText]
        })]) : "", this.dialogType === "confirm" ? (_i = (_h = (_g = this.$slots).footer) == null ? void 0 : _h.call(_g)) != null ? _i : createVNode(Fragment, null, [createVNode(BkButton, {
          "onClick": this.handleConfirm,
          "theme": this.theme,
          "loading": this.isLoading
        }, {
          default: () => [this.localConfirmText]
        })]) : ""]);
      },
      close: () => createVNode(error, {
        "onClick": this.handleClose
      }, null)
    };
    const className = `${resolveClassName("dialog-wrapper ")} ${this.scrollable ? "scroll-able" : ""} ${this.multiInstance ? "multi-instance" : ""} ${this.hasFooter ? "has-footer" : "no-footer"}`;
    return createVNode(BkModal, mergeProps(this.$props, {
      "class": className,
      "onClose": this.handleClose,
      "isShow": this.isModalShow,
      "style": this.data.moveStyle
    }), _isSlot$7(dialogSlot) ? dialogSlot : {
      default: () => [dialogSlot]
    });
  }
});
const BkDialog = withInstall(Dialog);
var permissions = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOm5vbmU7fQoJLnN0MXtmaWxsOiNDNEM2Q0M7fQoJLnN0MntmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qze2ZpbGw6dXJsKCPnn6nlvaJfNF8pO30KCS5zdDR7ZmlsbDojOTc5QkE1O30KCS5zdDV7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9Cgkuc3Q2e2ZpbGw6I0Y4RjlGQTt9Cgkuc3Q3e2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfMV8pO30KCS5zdDh7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF82Xyk7fQoJLnN0OXtmaWxsOiNEQ0RFRTA7fQo8L3N0eWxlPgo8ZyBpZD0i6aG16Z2iLTEiPgoJPGcgaWQ9IkV4Y2VwdGlvbl94MkZf5byC5bi45o+Q56S6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODcwLjAwMDAwMCwgLTIzODEuMDAwMDAwKSI+CgkJPGcgaWQ9IuaXoOadg+mZkOexuyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzU3LjAwMDAwMCwgMjI4Ny4wMDAwMDApIj4KCQkJPGcgaWQ9Iue8lue7hC0xMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDczLjAwMDAwMCkiPgoJCQkJPGcgaWQ9IuaXoOadg+mZkOexuy3mj5Llm74iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUxMy4wMDAwMDAsIDIxLjAwMDAwMCkiPgoJCQkJCTxnIGlkPSLmsqHmnInmnYPpmZAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyOC4wMDAwMDAsIDQyLjAwMDAwMCkiPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2iXzFfIiBjbGFzcz0ic3QwIiB3aWR0aD0iMjI0IiBoZWlnaHQ9IjE4MyIvPgoJCQkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaIiIGNsYXNzPSJzdDEiIGN4PSIxMzIiIGN5PSIxMSIgcj0iMSIvPgoJCQkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaJfMV8iIGNsYXNzPSJzdDEiIGN4PSIxNzMiIGN5PSI5NCIgcj0iMiIvPgoJCQkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaJfMl8iIGNsYXNzPSJzdDEiIGN4PSI1OSIgY3k9IjY2IiByPSIyIi8+CgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjExNi4zNTg3IiB5MT0iMTI5LjQwNzUiIHgyPSIxMTkuMzMxNCIgeTI9IjE1Ny42OTA2Ij4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQkZDRkQiLz4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAuOTk4OCIgc3R5bGU9InN0b3AtY29sb3I6I0YyRjRGNyIvPgoJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQk8cGF0aCBpZD0iRmlsbC0xIiBjbGFzcz0ic3QyIiBkPSJNNjAuNSwxMzYuMWMxNi4yLTMuNSw0MC42LTQuNyw1Ni41LTMuOWMxNS44LDAuOCwzMy4xLDMuMSwzMy4xLDMuMXM0LjUtMS45LDQuMS0xLjIKCQkJCQkJCWMtMC4zLDAuOC0yLjQsMS45LTEsMi4zYzEuNCwwLjQsMTUuNSwxLjksMjEuNCwzLjFzOC42LDIuMyw4LjYsMi4zczMuOC02LjYsMTIuMy01LjhjMCwwLjYtMy4xLDEuNC00LjIsMy4xUzE4OCwxNDIsMTg4LDE0MgoJCQkJCQkJczEuOC0xLDQuOSwwLjVzNi4xLDIsNi4xLDIuMnMtMS40LDMuNS0xMi43LDEuMmMtNC42LTEuMi02LjksNS4xLTI5LjMsNi42cy02MC4zLDIuNy02MC4zLDIuN3MxLjcsMi4zLDUuMiwzLjEKCQkJCQkJCWMwLDAtMi40LDIuMy03LjIsMS42Yy00LjgtMC44LTEwLTQuNy0xMC00LjdzLTEyLjctMC44LTE3LjYtMS42cy0xMC4zLTIuNy0xNC4xLTMuMWMtMy44LTAuNC0yMS0yLjMtMTQuNS02LjYKCQkJCQkJCUMzOC41LDE0My45LDQ0LjMsMTM5LjYsNjAuNSwxMzYuMXoiLz4KCgkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol80XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNTYuMTY2NyIgeTE9Ii0yLjUxNDMiIHgyPSIxNTYuMTY2NyIgeTI9Ii0xLjUxNDMiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoOTYgMCAwIDcwIC0xNDg3OSAyNTIpIj4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMkYzRjUiLz4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNUU4RUIiLz4KCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJPHBhdGggaWQ9IuefqeW9ol8yXyIgY2xhc3M9InN0MyIgZD0iTTcwLDc2aDg2YzIuOCwwLDUsMi4yLDUsNXY2MGMwLDIuOC0yLjIsNS01LDVINzBjLTIuOCwwLTUtMi4yLTUtNVY4MQoJCQkJCQkJQzY1LDc4LjIsNjcuMiw3Niw3MCw3NnoiLz4KCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiCIgY2xhc3M9InN0MSIgZD0iTTU5LjMsMTM4djExLjdINzF2Mi4zSDU5LjNsMCwwSDU3di0xNEg1OS4zeiIvPgoJCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9LTQiIGNsYXNzPSJzdDEiIGQ9Ik0xNjYuNywxMzh2MTEuN0gxNTV2Mi4zaDExLjdsMCwwaDIuM3YtMTRIMTY2Ljd6Ii8+CgkJCQkJCTxnPgoJCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF81XyIgY2xhc3M9InN0NCIgZD0iTTExNi41LDExNi44bDEuNiw3LjljMC4yLDAuOC0wLjQsMS42LTEuMiwxLjhjLTAuMSwwLTAuMiwwLTAuMywwaC03LjIKCQkJCQkJCQljLTAuOCwwLTEuNS0wLjctMS41LTEuNWMwLTAuMSwwLTAuMiwwLTAuM2wxLjYtNy45Yy0zLTEuMy01LTQuMS01LTcuM2MwLTQuNCwzLjgtOCw4LjUtOHM4LjUsMy42LDguNSw4CgkJCQkJCQkJQzEyMS41LDExMi43LDExOS41LDExNS41LDExNi41LDExNi44eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEzNi4wMjk0IiB5MT0iLTYuODAxMSIgeDI9IjEzNi4wMjk0IiB5Mj0iLTYuMjc4OSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxNyAwIDAgMjUgLTIxOTkuNSAyNzcuNSkiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMUUyRTYiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRUVGMEYyIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBhdGggY2xhc3M9InN0NSIgZD0iTTExNywxMjcuNWgtNy42Yy0xLjQsMC0yLjUtMS4xLTIuNS0yLjVsMC0wLjVsMS40LTcuMWMtMy0xLjYtNC45LTQuNi00LjktNy45YzAtNSw0LjMtOSw5LjUtOQoJCQkJCQkJCXM5LjUsNCw5LjUsOWMwLDMuMy0xLjksNi4zLTQuOSw3LjlsMS40LDcuMWMwLjMsMS4yLTAuNiwyLjYtMS45LDNMMTE3LDEyNy41eiBNMTA4LjksMTI0Ljh2MC4yYzAsMC4yLDAuMywwLjUsMC41LDAuNWg3LjMKCQkJCQkJCQljMC4yLTAuMSwwLjQtMC40LDAuNC0wLjZsLTEuOC04LjdsMC43LTAuM2MyLjctMS4yLDQuNC0zLjYsNC40LTYuNGMwLTMuOS0zLjQtNy03LjUtN3MtNy41LDMuMS03LjUsN2MwLDIuOCwxLjcsNS4yLDQuNCw2LjQKCQkJCQkJCQlsMC43LDAuM0wxMDguOSwxMjQuOHoiLz4KCQkJCQkJPC9nPgoJCQkJCQk8cGF0aCBpZD0i55+p5b2iXzNfIiBjbGFzcz0ic3Q2IiBkPSJNNzAsNzZoODZjMi44LDAsNSwyLjIsNSw1bDAsMGMwLDIuOC0yLjIsNS01LDVINzBjLTIuOCwwLTUtMi4yLTUtNWwwLDAKCQkJCQkJCUM2NSw3OC4yLDY3LjIsNzYsNzAsNzZ6Ii8+CgoJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTU1LjAyNjMiIHkxPSItMi42NjY3IiB4Mj0iMTU1LjAyNjMiIHkyPSItMS42NzI3IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDc2IDAgMCA2NiAtMTE2NjkgMTkyKSI+CgkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjNGNEY1Ii8+CgkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTZFOEVCIi8+CgkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMl8iIGNsYXNzPSJzdDciIGQ9Ik0xNDEuNSw1NC42YzAtMTYtMTIuOC0yOS0yOC41LTI5cy0yOC41LDEzLTI4LjUsMjlsMCwwdjI1LjhjMCwwLjktMi4xLDEuNi00LjgsMS42CgkJCQkJCQljLTIuNSwwLTQuNi0wLjctNC43LTEuNXYtMC4xVjU0LjZDNzUsMzMuMyw5MiwxNiwxMTMsMTZzMzgsMTcuMywzOCwzOC42bDAsMHYyNS44YzAsMC45LTIuMSwxLjYtNC44LDEuNnMtNC44LTAuNy00LjgtMS42CgkJCQkJCQlsMCwwVjU0LjZIMTQxLjV6Ii8+CgoJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfNl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTUzLjc5MDMiIHkxPSItMy4yMzg1IiB4Mj0iMTUzLjc5MDMiIHkyPSItMi4yNTkyIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDYyIDAgMCA1NCAtOTQyMiAyMDEpIj4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFN0U5RUIiLz4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFN0U5RUIiLz4KCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF8zXyIgY2xhc3M9InN0OCIgZD0iTTgyLDU0LjVDODIuMywzOC4yLDk2LDI1LDExMywyNWMxNy4xLDAsMzEsMTMuNCwzMSwzMGgtMy4xYzAtMTQuOS0xMi41LTI3LTI3LjktMjcKCQkJCQkJCVM4NS4xLDQwLjEsODUuMSw1NXYyNEg4MlY1NVY1NC41eiBNMTQ0LDU1djI0aC0zLjFWNTVIMTQ0eiIvPgoJCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzRfIiBjbGFzcz0ic3Q5IiBkPSJNODAsNzhjMi43LDAsNC45LTAuOCw1LTEuOVY3NnY0YzAsMS4xLTIuMiwyLTUsMmMtMi43LDAtNC45LTAuOC01LTEuOVY4MHYtNAoJCQkJCQkJQzc1LDc3LjEsNzcuMiw3OCw4MCw3OHoiLz4KCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiOWkh+S7vS0zIiBjbGFzcz0ic3Q5IiBkPSJNMTQ2LDc4YzIuNywwLDQuOS0wLjgsNS0xLjlWNzZ2NGMwLDEuMS0yLjIsMi01LDJjLTIuNywwLTQuOS0wLjgtNS0xLjlWODB2LTQKCQkJCQkJCUMxNDEsNzcuMSwxNDMuMiw3OCwxNDYsNzh6Ii8+CgkJCQkJPC9nPgoJCQkJPC9nPgoJCQk8L2c+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=";
var notFound = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCPnn6nlvaJfOV8pO30KCS5zdDJ7ZmlsbDp1cmwoI+efqeW9ol8xMF8pO30KCS5zdDN7ZmlsbDojRjBGMkY1O3N0cm9rZTp1cmwoI+efqeW9ol8xMV8pO30KCS5zdDR7ZmlsbDojOTc5QkE1O3N0cm9rZTp1cmwoI+efqeW9ol8xMl8pO30KCS5zdDV7ZmlsbDojOTc5QkE1O3N0cm9rZTp1cmwoI+efqeW9ouWkh+S7vS05XzFfKTt9Cgkuc3Q2e2ZpbGw6Izk3OUJBNTtzdHJva2U6dXJsKCPlvaLnirbnu5PlkIhfNl8pO30KCS5zdDd7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF84Xyk7fQoJLnN0OHtmaWxsOnVybCgj5b2i54q257uT5ZCI5aSH5Lu9LTNfMV8pO30KCS5zdDl7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF85Xyk7fQoJLnN0MTB7ZmlsbDojRTFFM0U2O30KCS5zdDExe2ZpbGw6I0YwRjJGNTt9Cgkuc3QxMntmaWxsOiNGNEY0RjQ7fQoJLnN0MTN7ZmlsbDp1cmwoI+i3r+W+hC01XzFfKTt9Cgkuc3QxNHtmaWxsOnVybCgj5b2i54q257uT5ZCIXzEwXyk7fQoJLnN0MTV7ZmlsbDp1cmwoI+W9oueKtue7k+WQiOWkh+S7vS00XzFfKTt9Cgkuc3QxNntmaWxsOiNDN0M5Q0M7fQoJLnN0MTd7ZmlsbDojRTVFN0U5O30KCS5zdDE4e2ZpbGw6I0VDRUVGMDt9Cgkuc3QxOXtmaWxsOiNDNEM2Q0M7fQoJLnN0MjB7ZmlsbDojRURFRUYzO30KCS5zdDIxe2ZpbGw6IzM0MzQzNDtmaWxsLW9wYWNpdHk6My4wMDAwMDBlLTAyO30KPC9zdHlsZT4KPGcgaWQ9IkV4Y2VwdGlvbl94MkZf5byC5bi45o+Q56S6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODcwLjAwMDAwMCwgLTEzMzUuMDAwMDAwKSI+Cgk8ZyBpZD0iX3gzNF8wNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzU3LjAwMDAwMCwgMTIxNi4wMDAwMDApIj4KCQk8ZyBpZD0iX3gzNF8wNC3mj5Llm74iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUxMy4wMDAwMDAsIDExOS4wMDAwMDApIj4KCQkJPGcgaWQ9Iue8lue7hC0xMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAuMDAwMDAwLCAxMS4wMzY2NDgpIj4KCQkJCTxnIGlkPSJfeDM0XzA05Li75L2TIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5NC4zMjQwMjIsIDQyLjUzODc3MSkiPgoJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjE0MS4zOTEyIiB5MT0iNTUuNjg2OSIgeDI9IjE1Mi4zMzA3IiB5Mj0iMTE3LjcyNzciPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjhGQ0ZEIi8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMkY0RjciLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxwYXRoIGlkPSJGaWxsLTEiIGNsYXNzPSJzdDAiIGQ9Ik00NS4zLDcyLjljMjkuMy02LjYsNzEuNS05LjYsMTAwLjItOC4xczUyLjQsNi41LDU0LjEsNS4zYzUuNy0zLjgsMTcuOS01LjUsMTcuMy00CgkJCQkJCXMtOC41LDYuMS02LDYuOGMyLjUsMC43LDI4LDMuNywzOC42LDUuOWMxMC42LDIuMiwxNy40LDQuNCwxOS43LDQuNGMyLjMsMCw1LjktMy4xLDIxLjMtMS42YzAuMywwLjYtMy40LDAuOC02LjgsMi41CgkJCQkJCXMtNS45LDEuNi01LjksMnMxLjktMC42LDUuOSwyYzQsMi41LDExLDMuNCwxMSw0cy04LjksMy42LTIzLjgtMS4xYy0zLjgtMS4yLTEyLjYsOS4yLTUzLjEsMTIuMXMtMTA5LjEsNS4yLTEwOS4xLDUuMgoJCQkJCQlzNC4xLDUuMywxMC4xLDYuOGMwLjMsMC41LTIuNCwyLjUtMTQsMC4zcy0xNy45LTcuMS0xNy45LTcuMXMtMjMuMS0xLjUtMzEuOC0yLjlzLTE4LjctNS4yLTI1LjYtNS45Uy04LjUsOTUsMy4zLDg2LjkKCQkJCQkJQzMuMyw4Ni45LDE2LDc5LjUsNDUuMyw3Mi45eiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfOV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMzA0Ljg0NjciIHkxPSIxMDEuMjQ5MiIgeDI9IjMwNC44NDY3IiB5Mj0iMTAwLjI1NDYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoOTMuMzkwNyAwIDAgLTkzLjQ2MjcgLTI4MzM1Ljk0NTMgOTQ2My4wMjczKSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFQ0VFRjAiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0Q3RDlEQiIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHBhdGggaWQ9IuefqeW9ol8xXyIgY2xhc3M9InN0MSIgZD0iTTg5LjIsMGg4OS40YzEuMSwwLDIsMC45LDIsMnY4OS41YzAsMS4xLTAuOSwyLTIsMkg4OS4yYy0xLjEsMC0yLTAuOS0yLTJWMgoJCQkJCQlDODcuMiwwLjksODguMSwwLDg5LjIsMHoiLz4KCgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzEwXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIzMDMuODkxNSIgeTE9IjEwMS42NTMyIiB4Mj0iMzAzLjg5MTUiIHkyPSIxMDAuNjUzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDgxLjcxNjkgMCAwIC04MS43Nzk5IC0yNDY5OS4yMjQ2IDgzMTguOTkwMikiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjVGN0ZBIi8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFQkVERjAiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMl8iIGNsYXNzPSJzdDIiIGQ9Ik05NCw1LjhoNzkuN2MwLjYsMCwxLDAuNCwxLDF2NzkuOGMwLDAuNi0wLjQsMS0xLDFIOTRjLTAuNiwwLTEtMC40LTEtMVY2LjgKCQkJCQkJQzkzLDYuMyw5My41LDUuOCw5NCw1Ljh6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8xMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjk5LjQxODYiIHkxPSIxMDMuNTA1MiIgeDI9IjI5OS40MTg2IiB5Mj0iMTAyLjU1OTkiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNTEuNTMyMyAwIDAgLTUxLjU3MjggLTE1Mjk1Ljg3NyA1MzYwLjk3MzYpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTJFNiIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjdGOUZDIi8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i55+p5b2iXzNfIiBjbGFzcz0ic3QzIiBkPSJNMTA5LjEsMjAuOWg0OS41YzAuNiwwLDEsMC40LDEsMXY0OS42YzAsMC42LTAuNCwxLTEsMWgtNDkuNWMtMC42LDAtMS0wLjQtMS0xVjIxLjkKCQkJCQkJQzEwOC4xLDIxLjQsMTA4LjYsMjAuOSwxMDkuMSwyMC45eiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfMTJfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjE5NS40ODc5IiB5MT0iMTE5LjIyMzciIHgyPSIxOTUuNDg3OSIgeTI9IjExOC4yNTY2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDUuMzc3NyAwIDAgLTEyLjY4MjggLTkyOC4zNzU1IDE1NDYuODUxNikiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTFFMkU2Ii8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMEYyRjUiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxyZWN0IGlkPSLnn6nlvaJfNF8iIHg9IjEyMC4yIiB5PSIzNC41IiBjbGFzcz0ic3Q0IiB3aWR0aD0iNS40IiBoZWlnaHQ9IjEyLjciLz4KCgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2i5aSH5Lu9LTlfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTk1LjQ5MDEiIHkxPSIxMTkuMjIzNyIgeDI9IjE5NS40OTAxIiB5Mj0iMTE4LjI1NjYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNS4zNzc3IDAgMCAtMTIuNjgyOCAtOTA2LjQ4NzEgMTU0Ni44NTE2KSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMUUyRTYiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0YwRjJGNSIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS05IiB4PSIxNDIuMSIgeT0iMzQuNSIgY2xhc3M9InN0NSIgd2lkdGg9IjUuNCIgaGVpZ2h0PSIxMi43Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF82XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNDcuNTY2IiB5MT0iMTI1LjQ1MTQiIHgyPSIyNDcuNTY2IiB5Mj0iMTI0LjQ4NDQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoOS43NTU0IDAgMCAtOS43NjIxIC0yMjgxLjIwNTEgMTI3Ni45MDYpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTJFNiIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjBGMkY1Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIIiBjbGFzcz0ic3Q2IiBkPSJNMTI5LDU2LjdMMTI5LDU2LjdjMC4xLTIuNiwyLjMtNC43LDQuOS00LjdjMi42LDAsNC43LDIsNC45LDQuN3YwLjJ2NC45SDEyOXYtMC41di00LjQKCQkJCQkJVjU2Ljd6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF84XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIzMDIuOTc2MSIgeTE9IjEwMS4yMzc1IiB4Mj0iMzAyLjk3NjEiIHkyPSIxMDAuMzAxNiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg3Mi45NjE1IDAgMCAtOTMuNDYyNyAtMjE4NzkuNzQ0MSA5NDYzLjAyNzMpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VCRURGMDtzdG9wLW9wYWNpdHk6MC45OTE3Ii8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMUUzRTYiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDciIGQ9Ik0yNDQuOCwwaDIuOXY1OC40aDE0LjZ2MTcuNWgtMTQuNnYxNy41aC0yMC40Vjc1LjloLTM3LjlWNTguNEwyMjcuMywwSDI0NC44egoJCQkJCQkgTTIyNy4zLDI4LjJsLTE4LjgsMzAuM2gxOC44VjI4LjJ6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiOWkh+S7vS0zXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjMwMi45NzU2IiB5MT0iMTAxLjIzNzUiIHgyPSIzMDIuOTc1NiIgeTI9IjEwMC4zMDE2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDcyLjk2MTUgMCAwIC05My40NjI3IC0yMjA2My42MDc0IDk0NjMuMDI3MykiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUJFREYwO3N0b3Atb3BhY2l0eTowLjk5MTciLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTNFNiIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiOWkh+S7vS0zIiBjbGFzcz0ic3Q4IiBkPSJNNjAuOSwwaDIuOXY1OC40aDE0LjZ2MTcuNUg2My44djE3LjVINDMuNFY3NS45SDUuNVY1OC40TDQzLjQsMEg2MC45egoJCQkJCQkgTTQzLjQsMjguMkwyNC42LDU4LjRoMTguOFYyOC4yeiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfOV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjk5LjA0NjYiIHkxPSIxMDcuMjgyNyIgeDI9IjI5OS4wNTM1IiB5Mj0iMTA3LjAxMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg1MC4wMDM1IDAgMCAtMjguNjA1MyAtMTQ4NTcuNzUyOSAzMjE2LjczOTUpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZCRkNGRCIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjBGMkY1Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzJfIiBjbGFzcz0ic3Q5IiBkPSJNOTkuNiwxMzcuM2MxMS43LDAsMjEuMiw1LjYsMjEuMiwxMi40YzAsNi45LTkuNSwxMi40LTIxLjIsMTIuNAoJCQkJCQljLTQuNCwwLTguNS0wLjgtMTEuOS0yLjFsLTcsNS45bC0xLjktMi4ybDYtNS4xYy0zLjktMi4zLTYuNC01LjQtNi40LTguOWMwLTAuMiwwLTAuNSwwLTAuN2wtNS44LDUuMWwtMS45LTIuMmwxNS40LTEzLjQKCQkJCQkJbDEuMSwxLjJDOTAuNywxMzguMSw5NSwxMzcuMyw5OS42LDEzNy4zeiIvPgoJCQkJCTxyZWN0IGlkPSLnn6nlvaJfNV8iIHg9IjIyNS44IiB5PSI4Ny42IiBjbGFzcz0ic3QxMCIgd2lkdGg9IjIzLjMiIGhlaWdodD0iNS44Ii8+CgkJCQkJPHJlY3QgaWQ9IuefqeW9ol82XyIgeD0iMjI3LjMiIHk9Ijg2LjIiIGNsYXNzPSJzdDExIiB3aWR0aD0iMjAuNCIgaGVpZ2h0PSIxLjUiLz4KCQkJCQk8cmVjdCBpZD0i55+p5b2iXzdfIiB4PSI0MS45IiB5PSI4Ny42IiBjbGFzcz0ic3QxMCIgd2lkdGg9IjIzLjMiIGhlaWdodD0iNS44Ii8+CgkJCQkJPHJlY3QgaWQ9IuefqeW9ol84XyIgeD0iNDMuNCIgeT0iODYuMiIgY2xhc3M9InN0MTEiIHdpZHRoPSIyMC40IiBoZWlnaHQ9IjEuNSIvPgoJCQkJCTxwYXRoIGlkPSLot6/lvoQtNCIgY2xhc3M9InN0MTEiIGQ9Ik0wLDAiLz4KCQkJCQk8cGF0aCBpZD0i6Lev5b6ELTgiIGNsYXNzPSJzdDEyIiBkPSJNMTE1LjYsMTM0LjljMi40LTIuMiw5LjctMy40LDIxLjktMy40YzYuNCwwLDExLDAuNywzOS45LDUuN2MyLjksMC41LDUuMywwLjksNy43LDEuMwoJCQkJCQljMjUuOCw0LjMsNDAuOCw1LjcsNDguNiwzLjNsLTAuNC0xLjRjLTcuNSwyLjItMjIuNSwwLjktNDgtMy40Yy0yLjMtMC40LTQuOC0wLjgtNy42LTEuM2MtMjkuMS01LjEtMzMuNi01LjgtNDAuMi01LjgKCQkJCQkJYy0xMi42LDAtMjAuMSwxLjItMjIuOSwzLjhMMTE1LjYsMTM0Ljl6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9Iui3r+W+hC01XzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjMwNy4xMTA1IiB5MT0iMTAzLjQ4MSIgeDI9IjMwNy4xMTA1IiB5Mj0iMTAyLjQ5MjIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTQxLjI1IDAgMCAtNTIuMDk2MiAtNDMyMDEuNzIyNyA1NDgxLjM2MTMpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0RDREVFNSIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojOTc5QkE1Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i6Lev5b6ELTUiIGNsYXNzPSJzdDEzIiBkPSJNMjI1LjgsODkuOGgtMjBjLTYuOSwwLTEwLjcsMy4xLTgsNy41YzIuNyw0LjYsMTEuOSw5LjcsMjcuMSwxNC40CgkJCQkJCWMxNS41LDQuOCwyNC45LDE1LjUsMjEsMjIuNWMtNC41LDguMS0yNC40LDguOS01Ni4zLTAuOGMtNDguNC0xNC42LTc1LjgtMTYuMS04Mi42LTQuMWwxLjMsMC43YzYuMi0xMS4xLDMzLjItOS43LDgwLjksNC43CgkJCQkJCWMzMi41LDkuOCw1Myw5LjEsNTgsMC4xYzQuNS04LTUuNi0xOS41LTIxLjktMjQuNmMtMTQuOC00LjYtMjMuOC05LjYtMjYuMi0xMy43Yy0xLjgtMy4xLDAuOC01LjMsNi44LTUuM2gyMHYtMS40SDIyNS44eiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfMTBfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjI5NC4xODM1IiB5MT0iMTAxLjQ1NzgiIHgyPSIyOTQuNzA3NCIgeTI9IjEwMS40MDIyIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDM3Ljc5OTMgNy4zNDc0IDcuNjMzNyAtMzkuMjcyIC0xMTgwMy44MjUyIDE5NTkuNDUyKSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFN0U5RUI7c3RvcC1vcGFjaXR5OjAuOTM2NSIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQ0RDRkQxIi8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzNfIiBjbGFzcz0ic3QxNCIgZD0iTTExMS43LDEyNS4yYzQsNC45LDQuNywxMS4zLDIuNCwxMy41bC0wLjEsMC4xbC01LjUsNS42YzAuNiwyLjksMC41LDUuMy0xLjEsNi43CgkJCQkJCWwwLDBsMCwwbC04LjIsOC43bC0yMS44LTMwLjZsOC4zLTQuOHYwLjFjMS43LTAuOSw0LjEtMC42LDYuNywwLjRsNi44LTQuMmwwLjEtMC4xQzEwMiwxMTguNywxMDcuOCwxMjAuMywxMTEuNywxMjUuMnoiLz4KCgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9LTRfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjk1LjQwNTQiIHkxPSI4Mi4zMTk3IiB4Mj0iMjk2LjEyODciIHkyPSI4Mi4yOTk0IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDIzLjgyNDMgMjkuNDIwNiAxNS44NjE0IC0xMi44NDQzIC04MjU1Ljg0MzggLTc1MDQuODQ1NykiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUJFREVGIi8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNEOERBREMiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIjlpIfku70tNCIgY2xhc3M9InN0MTUiIGQ9Ik0xMDMuMywxMzIuNGM1LjksNy4yLDcuMiwxNS40LDQsMTguOWwwLDBsLTguMSw4LjVMNzYsMTI5LjlsOS40LTUuNWwwLDAKCQkJCQkJQzg5LjUsMTIyLjEsOTcuNSwxMjUuMiwxMDMuMywxMzIuNHoiLz4KCgkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaLlpIfku70tMiIgdHJhbnNmb3JtPSJtYXRyaXgoMC43NzcxIC0wLjYyOTMgMC42MjkzIDAuNzc3MSAtNzEuNzU3MyA4Ny4zODA5KSIgY2xhc3M9InN0MTYiIGN4PSI4Ny41IiBjeT0iMTQ1IiByeD0iOS41IiByeT0iMTkiLz4KCgkJCQkJCTxnIGlkPSLnvJbnu4QtNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODUuMjg4NzA1LCAxNTUuNjk1NDY1KSByb3RhdGUoNi4wMDAwMDApIHRyYW5zbGF0ZSgtODUuMjg4NzA1LCAtMTU1LjY5NTQ2NSkgdHJhbnNsYXRlKDc5LjE0MzQ1MywgMTQ2Ljc1NjkxNykiPgoJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTkiIGNsYXNzPSJzdDE3IiBwb2ludHM9IjEyLjIsMS4xIDEyLjIsNi4xIDEuMiwxNy41IDEuMiwxMi41IAkJCQkJCSIvPgoJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTEwIiBjbGFzcz0ic3QxMSIgcG9pbnRzPSIxMi4yLDEuMSAxMS4zLDAgMC4zLDExLjEgMS4yLDEyLjUgCQkJCQkJIi8+CgkJCQkJCTxwb2x5Z29uIGlkPSLot6/lvoQtMTEiIGNsYXNzPSJzdDE4IiBwb2ludHM9IjAuMywxMS4xIDEuMiwxMi41IDEuMiwxNy41IDAuMywxNi4xIAkJCQkJCSIvPgoJCQkJCTwvZz4KCgkJCQkJCTxnIGlkPSLnvJbnu4QtNeWkh+S7vSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzYuODI2Mjc3LCAxNDMuODg1MTA1KSByb3RhdGUoNi4wMDAwMDApIHRyYW5zbGF0ZSgtNzYuODI2Mjc3LCAtMTQzLjg4NTEwNSkgdHJhbnNsYXRlKDcwLjY4MTAyNSwgMTM0Ljk0NjU1OCkiPgoJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTlfMV8iIGNsYXNzPSJzdDE3IiBwb2ludHM9IjEyLjIsMS4xIDEyLjIsNi4xIDEuMiwxNy41IDEuMiwxMi41IAkJCQkJCSIvPgoJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTEwXzFfIiBjbGFzcz0ic3QxMSIgcG9pbnRzPSIxMi4yLDEuMSAxMS4zLDAgMC4zLDExLjEgMS4yLDEyLjUgCQkJCQkJIi8+CgkJCQkJCTxwb2x5Z29uIGlkPSLot6/lvoQtMTFfMV8iIGNsYXNzPSJzdDE4IiBwb2ludHM9IjAuMywxMS4xIDEuMiwxMi41IDEuMiwxNy41IDAuMywxNi4xIAkJCQkJCSIvPgoJCQkJCTwvZz4KCgkJCQkJCTxnIGlkPSLnvJbnu4QtNV8xXyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODQuNjQzMzQ5LCAxNTYuMjAzMTgzKSByb3RhdGUoNi4wMDAwMDApIHRyYW5zbGF0ZSgtODQuNjQzMzQ5LCAtMTU2LjIwMzE4MykgdHJhbnNsYXRlKDc4LjEzNjYxMiwgMTQ2LjYyOTc5NikiPgoJCQkJCTwvZz4KCgkJCQkJCTxnIGlkPSLnvJbnu4QtNeWkh+S7vV8xXyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzYuMjU3OTg1LCAxNDQuMjkxOTQyKSByb3RhdGUoNi4wMDAwMDApIHRyYW5zbGF0ZSgtNzYuMjU3OTg1LCAtMTQ0LjI5MTk0MikgdHJhbnNsYXRlKDY5Ljc1MTI0OCwgMTM0LjcxODU1NSkiPgoJCQkJCTwvZz4KCQkJCTwvZz4KCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9oiIgY2xhc3M9InN0MTkiIGN4PSIxLjciIGN5PSI4MCIgcj0iMS43Ii8+CgkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzRfIiBjbGFzcz0ic3QyMCIgZD0iTTEyMy43LDYyLjlsLTEuMiwxLjhjLTU4LjQsMTQuNi05Ny4zLDM0LjgtOTUuMiw1MS44YzEuMiwxMCwxNi41LDE3LjYsNDEsMjIuMgoJCQkJCWM3LjktOC42LDE4LjMtMTcuOSwzMC43LTI3LjV2MS45Qzg3LjQsMTIyLjIsNzcuNiwxMzEsNzAsMTM5YzkuMiwxLjYsMTkuNywyLjksMzEuMiwzLjdjMS41LDAuNywzLjQsMS4zLDUuNSwxLjgKCQkJCQljLTE0LjEtMC44LTI2LjktMi4yLTM3LjgtNC4yQzU1LDE1NS4xLDQ5LDE2Ny41LDUzLDE3NS40YzguNiwxNi45LDYxLjIsOC44LDEyNi44LTE3LjZjMC41LDAuMywxLDAuNiwxLjYsMQoJCQkJCWMtNjYuOCwyNy0xMjAuNSwzNS4yLTEyOS42LDE3LjNjLTQuMi04LjMsMS43LTIxLjEsMTUuNC0zNi4yYy0yNC43LTQuOC00MC0xMi43LTQxLjMtMjMuMkMyMy42LDk4LjUsNjMuNyw3Ny43LDEyMy43LDYyLjl6CgkJCQkJIE0zMTMuMywxMTguNGg1LjFjLTYuOCwyLjEtMTMuOSw0LjEtMjEuNCw2Yy0xLjQtMC4yLTIuOC0wLjQtMy45LTAuNUMzMDAuMiwxMjIuMSwzMDYuOSwxMjAuMywzMTMuMywxMTguNHogTTI4My4xLDEwNS44djEuNwoJCQkJCWMtMi45LDEuOC01LjgsMy41LTguOCw1LjN2LTEuN0MyNzcuMywxMDkuMywyODAuMiwxMDcuNiwyODMuMSwxMDUuOHogTTM3OC41LDkuNmM0LjcsOS4yLTMuMSwyNC0yMC4yLDQxLjMKCQkJCQljMTguOSw0LjksMzAuNCwxMiwzMS42LDIxYzEuMywxMC40LTExLjQsMjEuNi0zMy43LDMyLjJ2LTEuNmMyMS40LTEwLjEsMzMuNC0yMC44LDMyLjMtMzAuNGMtMS4xLTguNi0xMi41LTE1LjQtMzEuMy0yMC4xCgkJCQkJbC0wLjMsMC4zYy00LjUsNC41LTkuNiw5LjEtMTUuMywxMy45di0xLjljNS00LjMsOS42LTguNCwxMy43LTEyLjRsMC4zLTAuM2MtNC4zLTEtOS0xLjktMTQtMi43di0xLjVjNS40LDAuOSwxMC41LDEuOSwxNS4xLDMKCQkJCQljMTcuMS0xNy4xLDI1LTMxLjUsMjAuNi00MC4zYy0xMC0xOS43LTc5LjktNS40LTE2MC40LDMyLjJoLTMuNEMyOTUuOSwzLjQsMzY3LjgtMTEuNSwzNzguNSw5LjZ6IE0xMzYuOSw4NC41djEuOAoJCQkJCWMtNS44LDMuNy0xMS40LDcuNC0xNi43LDExLjFsMi0zLjFDMTI3LDkwLjksMTMxLjksODcuNywxMzYuOSw4NC41eiBNMzIxLjEsODAuNHYxLjhjLTQuMiwzLTguNSw2LjEtMTMsOS4ybDItMy4xCgkJCQkJQzMxMy45LDg1LjYsMzE3LjUsODMsMzIxLjEsODAuNHogTTE4MC44LDU4Ljl2MS43Yy04LjEsNC4zLTE1LjksOC43LTIzLjQsMTMuMVY3MkMxNjQuOSw2Ny42LDE3Mi43LDYzLjIsMTgwLjgsNTguOXoKCQkJCQkgTTE4MC44LDUxLjZ2MS41Yy04LDEuMi0xNS44LDIuNi0yMy40LDR2LTEuNUMxNjUsNTQuMSwxNzIuOCw1Mi44LDE4MC44LDUxLjZ6IE0zMTkuNSw0NC45bC0wLjksMS40CgkJCQkJYy0xMy40LTEuMS0yOC4zLTEuNS00NC4zLTEuM3YtMC41YzAtMC4zLTAuMS0wLjctMC4yLTAuOUMyOTAuNSw0My4zLDMwNS44LDQzLjcsMzE5LjUsNDQuOXoiLz4KCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfNV8iIGNsYXNzPSJzdDIxIiBkPSJNMzc4LjUsOS42YzQuNyw5LjItMy4xLDI0LTIwLjIsNDEuM2MxOC45LDQuOSwzMC40LDEyLDMxLjYsMjEKCQkJCQljMi45LDI0LTY4LjYsNTIuOC0xNjIuNCw2Ni4xYy04Ni45LDQyLjktMTY0LjYsNTkuOS0xNzUuOCwzOGMtNC4yLTguMywxLjctMjEuMSwxNS40LTM2LjJjLTI0LjctNC44LTQwLTEyLjctNDEuMy0yMy4yCgkJCQkJYy0xLjctMTMuOCwyMS4xLTI5LjEsNTguNS00Mi4ybDAuMywxLjRjLTM2LjYsMTIuOC01OSwyNy42LTU3LjQsNDAuNmMxLjIsMTAsMTYuNSwxNy42LDQxLDIyLjJjNi44LTcuMywxNS40LTE1LjIsMjUuNS0yMy40CgkJCQkJbDAuMywxLjJsMC44LTAuMmMtOS44LDcuOS0xOC4yLDE1LjUtMjQuOSwyMi42YzM0LjQsNi4xLDg2LjIsNi42LDE0My4zLTAuNGM0LjctMC42LDkuMy0xLjIsMTMuOC0xLjhjMi43LTEuNCw1LjUtMi43LDguMy00LjEKCQkJCQljNTEuOC0yNi40LDk1LTU2LjEsMTE5LjktODAuNmwwLjMtMC4zYy0yLjctMC42LTUuNS0xLjItOC40LTEuOGwtMC40LTEuNWMzLjUsMC42LDYuOCwxLjQsMTAsMi4xYzE3LjEtMTcuMSwyNS0zMS41LDIwLjYtNDAuMwoJCQkJCWMtNC4yLTguMy0xOS4yLTEwLjYtNDEuMS03LjZsLTAuMy0xLjRDMzU4LjUtMS44LDM3NCwwLjcsMzc4LjUsOS42eiBNMjIyLjksMTM4LjdsLTAuNCwwLjFjLTMsMC40LTYsMC44LTksMS4yCgkJCQkJYy01Ny43LDcuMS0xMTAsNi43LTE0NC43LDAuMkM1NSwxNTUuMSw0OSwxNjcuNSw1MywxNzUuNEM2My40LDE5NS45LDEzOC40LDE3OS43LDIyMi45LDEzOC43eiBNMzU3LjEsNTJsLTAuMywwLjMKCQkJCQljLTI1LDI0LjgtNjguNSw1NC44LTEyMC44LDgxLjRjLTEuNCwwLjctMi45LDEuNS00LjMsMi4yYzkwLjYtMTMuNSwxNTkuNS00MS41LDE1Ni43LTYzLjlDMzg3LjQsNjMuNSwzNzUuOSw1Ni43LDM1Ny4xLDUyeiIvPgoJCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzFfIiBjbGFzcz0ic3QxOSIgY3g9IjEzNS4yIiBjeT0iMTQ0LjIiIHI9IjIuMiIvPgoJCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTQiIGNsYXNzPSJzdDE5IiBjeD0iMzU3IiBjeT0iNTAuOSIgcj0iMy45Ii8+CgkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaLlpIfku70iIGNsYXNzPSJzdDE5IiBjeD0iNDMuNiIgY3k9IjkzLjkiIHI9IjIuMiIvPgoJCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzJfIiBjbGFzcz0ic3QxOSIgY3g9IjM3Mi4xIiBjeT0iMy40IiByPSIyLjIiLz4KCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol8zXyIgY2xhc3M9InN0MTkiIGN4PSI3My4yIiBjeT0iNTAuOSIgcj0iMS43Ii8+CgkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaJfNF8iIGNsYXNzPSJzdDE5IiBjeD0iMjkzLjMiIGN5PSIxNjkuNCIgcj0iMS43Ii8+CgkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaJfNV8iIGNsYXNzPSJzdDE5IiBjeD0iMzk4LjMiIGN5PSIxNS4yIiByPSIxLjciLz4KCQkJPC9nPgoJCTwvZz4KCTwvZz4KPC9nPgo8L3N2Zz4K";
var maintain = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6I0M0QzZDQzt9Cgkuc3Qye2ZpbGw6dXJsKCPnn6nlvaItMl8xXyk7fQoJLnN0M3tmaWxsOnVybCgj55+p5b2iXzZfKTt9Cgkuc3Q0e2ZpbGw6I0RDREVFMDt9Cgkuc3Q1e2ZpbGw6I0QxRDNENjt9Cgkuc3Q2e2ZpbGw6dXJsKCPnn6nlvaItM18xXyk7fQoJLnN0N3tmaWxsOiNFNUU3RUM7fQoJLnN0OHtmaWxsOnVybCgj5LiJ6KeS5b2iXzFfKTt9Cgkuc3Q5e2ZpbGw6Izk3OUJBNTt9Cjwvc3R5bGU+CjxnIGlkPSLpobXpnaItMSI+Cgk8ZyBpZD0iRXhjZXB0aW9uX3gyRl/lvILluLjmj5DnpLoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04NjkuMDAwMDAwLCAtMjkxOC4wMDAwMDApIj4KCQk8ZyBpZD0i5byC5bi45aSx6LSl57G7IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNTcuMDAwMDAwLCAyODIzLjAwMDAwMCkiPgoJCQk8ZyBpZD0i5byC5bi45aSx6LSl57G7LeaPkuWbviIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTEyLjAwMDAwMCwgOTUuMDAwMDAwKSI+CgkJCQk8ZyBpZD0i57yW57uELTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyMy4wMDAwMDAsIDMzLjAwMDAwMCkiPgoJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEyNi41Njk5IiB5MT0iMTM0Ljk4ODkiIHgyPSIxMzAuMTYzOCIgeTI9IjE2OS4xODI3Ij4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZCRkNGRCIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjJGNEY3Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0iRmlsbC0xIiBjbGFzcz0ic3QwIiBkPSJNNjAsMTQzYzE5LjMtNC4yLDQ4LjQtNS43LDY3LjMtNC43czM5LjQsMy44LDM5LjQsMy44czUuMy0yLjQsNC45LTEuNAoJCQkJCQljLTAuNCwwLjktMi45LDIuNC0xLjIsMi44YzEuNiwwLjUsMTguNSwyLjQsMjUuNCwzLjhjNywxLjQsMTAuMywyLjgsMTAuMywyLjhzNC42LTgsMTQuNy03LjFjMCwwLjgtMy43LDEuNy01LDMuOAoJCQkJCQljLTEuMiwyLjEtNCwzLjMtNCwzLjNzMi4yLTEuMiw1LjksMC42czcuMywyLjQsNy4zLDIuN3MtMS42LDQuMi0xNS4yLDEuNGMtNS41LTEuNC04LjIsNi4xLTM0LjksOHMtNzEuOCwzLjMtNzEuOCwzLjMKCQkJCQkJczIuMSwyLjgsNi4yLDMuOGMwLDAtMi45LDIuOC04LjYsMS45Yy01LjctMC45LTExLjktNS43LTExLjktNS43cy0xNS4yLTAuOS0yMC45LTEuOXMtMTIuMy0zLjMtMTYuOC0zLjhzLTI1LTIuOC0xNy4yLTgKCQkJCQkJQzMzLjgsMTUyLjQsNDAuNywxNDcuMyw2MCwxNDN6Ii8+CgkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiCIgY2xhc3M9InN0MSIgZD0iTTYwLjgsMTQ3djkuMkg3MHYxLjhINTl2LTExSDYwLjh6Ii8+CgkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiOWkh+S7vSIgY2xhc3M9InN0MSIgZD0iTTY2LDMxLjhoLTkuMlY0MUg1NXYtOS4ybDAsMFYzMGgxMVYzMS44eiIvPgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIjlpIfku70tMiIgY2xhc3M9InN0MSIgZD0iTTE1Ny4yLDQxdi05LjJIMTQ4VjMwaDkuMmwwLDBoMS44djExSDE1Ny4yeiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaItMl8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNjUuNzcyNyIgeTE9Ii0xLjU1OTciIHgyPSIxNjUuNzcyNyIgeTI9Ii0wLjYyMzgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoODggMCAwIDExMiAtMTQ0ODAgMjE0KSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFQkVERjA7c3RvcC1vcGFjaXR5OjAuOTkxNyIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTFFM0U2Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i55+p5b2iLTIiIGNsYXNzPSJzdDIiIGQ9Ik02NSwzOGg4NmMwLjYsMCwxLDAuNCwxLDF2MTEwYzAsMC42LTAuNCwxLTEsMUg2NWMtMC42LDAtMS0wLjQtMS0xVjM5CgkJCQkJCUM2NCwzOC40LDY0LjQsMzgsNjUsMzh6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol82XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNjQuODAxNCIgeTE9Ii0xLjgxNDQiIHgyPSIxNjQuODAxNCIgeTI9Ii0wLjgyNTkiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNzMgMCAwIDk3IC0xMTkyMyAyMjEpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZGRkZGRiIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjJGNEY3Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cmVjdCBpZD0i55+p5b2iXzFfIiB4PSI3MSIgeT0iNDUiIGNsYXNzPSJzdDMiIHdpZHRoPSI3MyIgaGVpZ2h0PSI5NyIvPgoJCQkJCTxyZWN0IGlkPSLnn6nlvaJfMl8iIHg9Ijg2IiB5PSI0OSIgY2xhc3M9InN0NCIgd2lkdGg9IjQzIiBoZWlnaHQ9IjIiLz4KCQkJCQk8cmVjdCBpZD0i55+p5b2iXzNfIiB4PSI3MSIgeT0iMTQwIiBjbGFzcz0ic3Q1IiB3aWR0aD0iNzMiIGhlaWdodD0iMiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaItM18xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNjAuODI1NiIgeTE9Ii0xMS43MzMzIiB4Mj0iMTYwLjgyNTYiIHkyPSItMTAuNzQxMiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg0MyAwIDAgMTUgLTY4MDggMjEwKSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFREVGRjIiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U4RUFFRCIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHJlY3QgaWQ9IuefqeW9oi0zIiB4PSI4NiIgeT0iMzQiIGNsYXNzPSJzdDYiIHdpZHRoPSI0MyIgaGVpZ2h0PSIxNSIvPgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDUiIGQ9Ik0xNTIsMTA1djQ0YzAsMC42LTAuNCwxLTEsMWgtMjQuNkwxNTIsMTA1eiIvPgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMl8iIGNsYXNzPSJzdDciIGQ9Ik0xNDQsMTE5LjJWMTQwaC0xMkwxNDQsMTE5LjJ6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuS4ieinkuW9ol8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNjMuOTE0MyIgeTE9Ii0zLjA4MTIiIHgyPSIxNjMuOTE0MyIgeTI9Ii0yLjE0NTMiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNjMuMTc5OSAwIDAgNTYuOTAzMyAtMTAxOTguMTcxOSAyNzcuMDk0NSkiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTZFOEVCO3N0b3Atb3BhY2l0eTowLjk5MTciLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0Q0RDZEOSIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHBhdGggaWQ9IuS4ieinkuW9oiIgY2xhc3M9InN0OCIgZD0iTTE1OS43LDEwMi4xbDEuNSwyLjZsMCwwbDI4LjEsNTAuM2MwLjUsMSwwLjIsMi4yLTAuOCwyLjdjLTAuMywwLjItMC42LDAuMy0xLDAuM2gtNTkuMgoJCQkJCQljLTEuMSwwLTItMC45LTItMmMwLTAuMywwLjEtMC43LDAuMy0xbDI5LjYtNTIuOWMwLjUtMSwxLjgtMS4zLDIuNy0wLjhDMTU5LjMsMTAxLjUsMTU5LjYsMTAxLjgsMTU5LjcsMTAyLjF6Ii8+CgkJCQkJPHBhdGggaWQ9Il94MjFfIiBjbGFzcz0ic3Q5IiBkPSJNMTYwLjcsMTI0bC0wLjYsMTYuNGgtNC4ybC0wLjYtMTYuNEMxNTUuMywxMjQsMTYwLjcsMTI0LDE2MC43LDEyNHogTTE1NSwxNDUuOAoJCQkJCQljMC0wLjksMC4zLTEuNiwwLjktMi4yczEuMy0wLjgsMi4xLTAuOGMwLjksMCwxLjYsMC4zLDIuMSwwLjhjMC42LDAuNiwwLjgsMS4zLDAuOCwyLjFzLTAuMywxLjYtMC44LDIuMQoJCQkJCQljLTAuNiwwLjYtMS4yLDAuOS0yLDAuOWMtMSwwLTEuNy0wLjMtMi4zLTAuOUMxNTUuMywxNDcuMywxNTUsMTQ2LjYsMTU1LDE0NS44eiIvPgoJCQkJCTxnIGlkPSLnvJbnu4QtMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAxLjAwMDAwMCwgNzQuMDAwMDAwKSI+CgkJCQkJCTxyZWN0IGlkPSLnn6nlvaJfNF8iIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9IiB4PSI3LjYiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTIiIHg9IjE1LjEiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTMiIHg9IjIyLjciIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTQiIHg9IjMwLjIiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCTwvZz4KCQkJCQk8ZyBpZD0i57yW57uELTNfMV8iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyNC4wMDAwMDAsIDkxLjAwMDAwMCkiPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2iXzVfIiB4PSI3LjgiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjkiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTUiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjkiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9XzFfIiB4PSIxNS42IiBjbGFzcz0ic3QxIiB3aWR0aD0iMy45IiBoZWlnaHQ9IjEiLz4KCQkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS0yXzFfIiB4PSIyMy41IiBjbGFzcz0ic3QxIiB3aWR0aD0iMy45IiBoZWlnaHQ9IjEiLz4KCQkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS0zXzFfIiB4PSIzMS4zIiBjbGFzcz0ic3QxIiB3aWR0aD0iMy45IiBoZWlnaHQ9IjEiLz4KCQkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS00XzFfIiB4PSIzOS4xIiBjbGFzcz0ic3QxIiB3aWR0aD0iMy45IiBoZWlnaHQ9IjEiLz4KCQkJCQk8L2c+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==";
var Building = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCPmpK3lnIblvaLlpIfku70tNV8yXyk7fQoJLnN0MntmaWxsOnVybCgj55+p5b2iXzE5Xyk7fQoJLnN0M3tmaWxsOnVybCgj55+p5b2i5aSH5Lu9LTIxXzFfKTt9Cgkuc3Q0e2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfNl8pO30KCS5zdDV7ZmlsbDojRUFFQ0VGO30KCS5zdDZ7ZmlsbDp1cmwoI+efqeW9ol8yMF8pO30KCS5zdDd7ZmlsbDojRjRGNEY1O30KCS5zdDh7ZmlsbDojRjlGOUZBO30KCS5zdDl7ZmlsbDojOTc5Nzk3O30KCS5zdDEwe2ZpbGw6I0U4RUFFQzt9Cgkuc3QxMXtmaWxsOiNGN0Y4RkE7fQoJLnN0MTJ7ZmlsbDp1cmwoI+efqeW9ol8yMV8pO30KCS5zdDEze2ZpbGw6dXJsKCPnn6nlvaLlpIfku70tMjJfMV8pO30KCS5zdDE0e2ZpbGw6dXJsKCPot6/lvoQtMjNfMV8pO30KCS5zdDE1e2ZpbGw6dXJsKCPnn6nlvaJfMjJfKTt9Cgkuc3QxNntmaWxsOiNEQ0RERTA7fQoJLnN0MTd7ZmlsbDp1cmwoI+i3r+W+hC0xOV8xXyk7fQoJLnN0MTh7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF85Xyk7fQoJLnN0MTl7ZmlsbDojQ0RDRUQxO30KCS5zdDIwe2ZpbGw6bm9uZTtzdHJva2U6dXJsKCPot6/lvoQtMjFfMV8pO30KCS5zdDIxe2ZpbGw6I0M2QzdDQjt9Cgkuc3QyMntmaWxsOiNEMUQyRDY7c3Ryb2tlOiNFQUVERjA7c3Ryb2tlLXdpZHRoOjI7fQoJLnN0MjN7ZmlsbDojRjlGQUZDO30KCS5zdDI0e2ZpbGw6dXJsKCPnn6nlvaJfMjNfKTt9Cgkuc3QyNXtmaWxsOiNGMUYzRjU7fQoJLnN0MjZ7ZmlsbDojRTZFOEVCO30KCS5zdDI3e2ZpbGw6I0QxRDJENjt9Cgkuc3QyOHtmaWxsOnVybCgj5qSt5ZyG5b2i5aSH5Lu9LThfMV8pO30KCS5zdDI5e2ZpbGw6I0VFRUZGMzt9Cgkuc3QzMHtmaWxsOiNENEQ2REE7fQoJLnN0MzF7ZmlsbDojRThFQUVEO3N0cm9rZTojRDlEQkRFO30KCS5zdDMye2ZpbGw6I0Q4RDhEODtzdHJva2U6I0NGRDBEMzt9Cgkuc3QzM3tmaWxsOiNERERFRTA7fQoJLnN0MzR7ZmlsbDojRUVGMEYyO30KCS5zdDM1e2ZpbGw6bm9uZTtzdHJva2U6dXJsKCPnn6nlvaJfMjRfKTtzdHJva2Utd2lkdGg6Mjt9Cgkuc3QzNntmaWxsOm5vbmU7c3Ryb2tlOnVybCgj55+p5b2iXzI1Xyk7c3Ryb2tlLXdpZHRoOjAuNzt9Cgkuc3QzN3tmaWxsOnVybCgj55+p5b2iXzI2Xyk7fQoJLnN0Mzh7ZmlsbDp1cmwoI+efqeW9ol8yN18pO30KCS5zdDM5e2ZpbGw6dXJsKCPnn6nlvaJfMjhfKTt9Cgkuc3Q0MHtmaWxsOiM5NTk2OTk7ZmlsbC1vcGFjaXR5OjAuMTI7fQoJLnN0NDF7ZmlsbDojQzRDNkNDO30KPC9zdHlsZT4KPGcgaWQ9Iumhtemdoi0xIj4KCTxnIGlkPSJFeGNlcHRpb25feDJGX+W8guW4uOaPkOekuiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg3MC4wMDAwMDAsIC0xODgyLjAwMDAwMCkiPgoJCTxnIGlkPSLlip/og73lu7rorr7nsbsiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM1Ny4wMDAwMDAsIDE3NTEuMDAwMDAwKSI+CgkJCTxnIGlkPSLnvJbnu4QtMTEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLCA3My4wMDAwMDApIj4KCQkJCTxnIGlkPSLlip/og73lu7rorr7nsbst5o+S5Zu+IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MTMuMDAwMDAwLCA1OC4wMDAwMDApIj4KCQkJCQk8ZyBpZD0i5Zu+5qGIIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1OC4wMDAwMDAsIDE3LjAwMDAwMCkiPgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IkZpbGwtMV8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMDYuMzkyNyIgeTE9IjE1OC41MjkiIHgyPSIyMDkuODg5IiB5Mj0iMTkxLjc5NDgiPgoJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZCRkNGRCIvPgoJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0YyRjRGNyIvPgoJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQk8cGF0aCBpZD0iRmlsbC0xIiBjbGFzcz0ic3QwIiBkPSJNMTQzLjQsMTY2LjRjMTguNi00LjIsNDUuNS02LjEsNjMuNy01LjFjMTguMiwwLjksMzMuMyw0LjEsMzQuNCwzLjQKCQkJCQkJCWMzLjYtMi40LDExLjQtMy41LDExLTIuNnMtNS40LDMuOS0zLjgsNC4zczE3LjgsMi4zLDI0LjYsMy43YzYuNywxLjQsMTEuMSwyLjgsMTIuNSwyLjhjMS41LDAsMy44LTIsMTMuNS0xCgkJCQkJCQljMC4yLDAuNC0yLjIsMC41LTQuMywxLjZjLTIuMiwxLjEtMy43LDEtMy43LDEuM3MxLjItMC40LDMuNywxLjNjMi41LDEuNiw3LDIuMSw3LDIuNmMwLDAuNC01LjcsMi4zLTE1LjEtMC43CgkJCQkJCQljLTIuNC0wLjgtOCw1LjgtMzMuOCw3LjdzLTY5LjQsMy4zLTY5LjQsMy4zczIuNiwzLjQsNi40LDQuM2MwLjIsMC4zLTEuNSwxLjYtOC45LDAuMmMtNy40LTEuNC0xMS40LTQuNS0xMS40LTQuNQoJCQkJCQkJcy0xNC43LTAuOS0yMC4yLTEuOWMtNS42LTAuOS0xMS45LTMuMy0xNi4zLTMuN3MtMjQuMi0yLjgtMTYuNy04QzExNi43LDE3NS4zLDEyNC43LDE3MC42LDE0My40LDE2Ni40eiIvPgoJCQkJCQk8ZyBpZD0i57yW57uELTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM3LjAwMDAwMCwgMC4wMDAwMDApIj4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaLlpIfku70tNV8yXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxOTcuNDMyOCIgeTE9Ii05Ljk3MjYiIHgyPSIxOTcuNDMyOCIgeTI9Ii04Ljk3MjYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTQuMzExNCAwIDAgMTcuNjQ4NSAtMjgxMi4yOTAzIDI1OC43NTkxKSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VBRUNFRSIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNDRENGRDEiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cGF0aCBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTUiIGNsYXNzPSJzdDEiIGQ9Ik0xMy4yLDEwMC40YzMuMSwwLDcuMi02LjUsNy4yLTEwLjVzLTMuMi03LjItNy4yLTcuMlM2LjEsODYsNi4xLDg5LjkKCQkJCQkJCQlDNi4xLDkzLjksMTAuMSwxMDAuNCwxMy4yLDEwMC40eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8xOV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTE1MS4zNjY0IiB5MT0iLTIuMjE1NiIgeDI9Ii0xNTEuMzY2NCIgeTI9Ii0xLjIxNTgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMS4xMDA5IDAgMCA3OS40MTgyIDE3Ny42ODkzIDE4NS45NTkzKSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0RDREVFNSIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCMkI1QkUiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cmVjdCBpZD0i55+p5b2iXzFfIiB4PSIxMC41IiB5PSIxMCIgY2xhc3M9InN0MiIgd2lkdGg9IjEuMSIgaGVpZ2h0PSI3OS40Ii8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2i5aSH5Lu9LTIxXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9Ii0xNTEuMzY4OSIgeTE9Ii0yLjIxNTYiIHgyPSItMTUxLjM2ODkiIHkyPSItMS4yMTU4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEuMTAwOSAwIDAgNzkuNDE4MiAxODAuOTkyIDE4NS45NTkzKSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0RDREVFNSIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCMkI1QkUiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTIxIiB4PSIxMy44IiB5PSIxMCIgY2xhc3M9InN0MyIgd2lkdGg9IjEuMSIgaGVpZ2h0PSI3OS40Ii8+CgoJCQkJCQkJCTxnIGlkPSLnvJbnu4QtMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjIuOTQxNzI1LCA3My44NDE3OTMpIHJvdGF0ZSgtMzkuMDAwMDAwKSB0cmFuc2xhdGUoLTYyLjk0MTcyNSwgLTczLjg0MTc5MykgdHJhbnNsYXRlKDUwLjQ0MTcyNSwgLTEwLjY1ODIwNykiPgoJCQkJCQkJCTxnIGlkPSLnvJbnu4QtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDM4LjUxMzU0OCkiPgoKCQkJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCIXzZfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjkzLjY5OTEiIHkxPSIzMy4xMTMzIiB4Mj0iOTMuNjk5MSIgeTI9IjM0LjA5MjQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMjQuNTE2MyAtNy41NzQ3MzJlLTA1IDcuMjY0MTQ3ZS0wNSAxMjkuNTQ1NiAtMjI3OC45OTU4IC00MjYzLjUyMzkpIj4KCQkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNEU2RTkiLz4KCQkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNDQkNFRDYiLz4KCQkJCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiCIgY2xhc3M9InN0NCIgZD0iTTI0LjUsMGwwLDEwMi43bDAsMTRsMCwxMi44SDBMMCwwTDI0LjUsMHogTTEyLjMsMTIzLjFsLTEwLDUuM2gyMC4xTDEyLjMsMTIzLjF6CgkJCQkJCQkJCQkgTTIzLjMsMTE3LjNsLTkuOCw1LjFsOS44LDUuMUwyMy4zLDExNy4zeiBNMS4yLDExNy4zbDAsMTAuM2w5LjgtNS4xTDEuMiwxMTcuM3ogTTIyLDExNi43SDIuNWw5LjcsNS4xTDIyLDExNi43egoJCQkJCQkJCQkJIE0xMi4zLDExMC40bC05LjcsNS4xSDIyTDEyLjMsMTEwLjR6IE0xLjIsMTA0LjZsMCwxMC4zbDkuOC01LjFMMS4yLDEwNC42eiBNMjMuMywxMDQuNmwtOS44LDUuMWw5LjgsNS4xTDIzLjMsMTA0LjZ6CgkJCQkJCQkJCQkgTTIyLjMsMTAzLjlsLTIwLjEsMGwxMCw1LjNMMjIuMywxMDMuOXogTTEyLjMsOTcuNWwtMTAsNS4zbDIwLjEsMEwxMi4zLDk3LjV6IE0xLjIsOTEuNmwwLDEwLjNsOS44LTUuMUwxLjIsOTEuNnoKCQkJCQkJCQkJCSBNMjMuMyw5MS42bC05LjgsNS4xbDkuOCw1LjFMMjMuMyw5MS42eiBNMjIsOTFMMi41LDkxbDkuNyw1LjFMMjIsOTF6IE0xMi4zLDg0LjhsLTkuNyw1LjFsMTkuNSwwTDEyLjMsODQuOHogTTEuMiw3OQoJCQkJCQkJCQkJbDAsMTAuM2w5LjgtNS4xTDEuMiw3OXogTTIzLjMsNzlsLTkuOCw1LjFsOS44LDUuMUwyMy4zLDc5eiBNMjIuMyw3OC4ySDIuMmwxMCw1LjNMMjIuMyw3OC4yeiBNMTIuMyw3MS44TDIuMiw3N2wyMC4xLDAKCQkJCQkJCQkJCUwxMi4zLDcxLjh6IE0xLjIsNjZsMCwxMC4zbDkuOC01LjFMMS4yLDY2eiBNMjMuMyw2NmwtOS44LDUuMWw5LjgsNS4xTDIzLjMsNjZ6IE0yMiw2NS40bC0xOS41LDBsOS43LDUuMUwyMiw2NS40egoJCQkJCQkJCQkJIE0xMi4zLDU5LjFsLTkuNyw1LjFsMTkuNSwwTDEyLjMsNTkuMXogTTEuMiw1My4zbDAsMTAuM2w5LjgtNS4xTDEuMiw1My4zeiBNMjMuMyw1My4zbC05LjgsNS4xbDkuOCw1LjFMMjMuMyw1My4zegoJCQkJCQkJCQkJIE0yMi4zLDUyLjVsLTIwLjEsMGwxMCw1LjNMMjIuMyw1Mi41eiBNMTIuMyw0Ni4xbC0xMCw1LjNsMjAuMSwwTDEyLjMsNDYuMXogTTIzLjMsNDAuM2wtOS44LDUuMWw5LjgsNS4xTDIzLjMsNDAuM3oKCQkJCQkJCQkJCSBNMS4yLDQwLjNsMCwxMC4zbDkuOC01LjFMMS4yLDQwLjN6IE0yMiwzOS43bC0xOS41LDBsOS43LDUuMUwyMiwzOS43eiBNMTIuMywzMy40bC05LjcsNS4xbDE5LjUsMEwxMi4zLDMzLjR6IE0xLjIsMjcuNgoJCQkJCQkJCQkJbDAsMTAuM2w5LjgtNS4xTDEuMiwyNy42eiBNMjMuMywyNy42bC05LjgsNS4xbDkuOCw1LjFMMjMuMywyNy42eiBNMjIuMywyNi44bC0yMC4xLDBsMTAsNS4zTDIyLjMsMjYuOHogTTEyLjMsMjAuNAoJCQkJCQkJCQkJbC0xMCw1LjNsMjAuMSwwTDEyLjMsMjAuNHogTTEuMiwxNC42bDAsMTAuM2w5LjgtNS4xTDEuMiwxNC42eiBNMjMuMywxNC42bC05LjgsNS4xbDkuOCw1LjFMMjMuMywxNC42eiBNMjIsMTRMMi41LDE0CgkJCQkJCQkJCQlsOS43LDUuMUwyMiwxNHogTTEyLjMsNy43bC05LjcsNS4xbDE5LjUsMEwxMi4zLDcuN3ogTTEuMiwxLjlsMCwxMC4zTDExLDcuMUwxLjIsMS45eiBNMjMuMywxLjlMMTMuNSw3bDkuOCw1LjFMMjMuMywxLjl6CgkJCQkJCQkJCQkgTTIyLjMsMS4ybC0yMC4xLDBsMTAsNS4zTDIyLjMsMS4yeiIvPgoJCQkJCQkJCTwvZz4KCgkJCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaIiIHRyYW5zZm9ybT0ibWF0cml4KC0wLjc3NzEgLTAuNjI5MyAwLjYyOTMgLTAuNzc3MSAxOS4xNDkxIDE0LjkyMDEpIiBjbGFzcz0ic3Q1IiBjeD0iMTIuMiIgY3k9IjQuMSIgcng9IjQuMSIgcnk9IjQuMSIvPgoKCQkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfMjBfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjExNS45NzExIiB5MT0iMzIuMTc3NCIgeDI9IjExNS45NzExIiB5Mj0iMzMuMTc3NCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxOS44NDY1IDMuNjY3NjMxZS0wNSAtOC42NDUwMzZlLTA2IDMxLjUxMTEgLTIyODMuMTA0NyAtMTAwMC4wNzA5KSI+CgkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFQkVERjAiLz4KCQkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U0RTZFOSIvPgoJCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQkJPHBvbHlnb24gaWQ9IuefqeW9ol8yXyIgY2xhc3M9InN0NiIgcG9pbnRzPSI3LDUuOCAxNy41LDUuOCAyMi4yLDM3LjMgMi4zLDM3LjMgCQkJCQkJCQkiLz4KCQkJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTE3IiBjbGFzcz0ic3Q3IiBwb2ludHM9IjAsMzguNSAyLjMsMzcuMyAyMi4yLDM3LjMgMjQuNSwzOC41IAkJCQkJCQkJIi8+CgkJCQkJCQkJPHBvbHlnb24gaWQ9Iui3r+W+hC0xOCIgY2xhc3M9InN0OCIgcG9pbnRzPSI4LjIsNS44IDguMiw0LjYgMTYuMyw0LjYgMTYuMyw1LjggCQkJCQkJCQkiLz4KCQkJCQkJCTwvZz4KCQkJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDkiIGQ9Ik0xMi43LDk5LjN2Ny4ydjAuMWMtMC4yLDAtMC40LTAuMS0wLjYtMC4xYy0xLjUsMC0yLjgsMS4zLTIuOCwzczEuMiwzLDIuOCwzCgkJCQkJCQkJYzEuMywwLDIuNS0xLDIuNy0yLjRoMS4xYy0wLjMsMi0xLjksMy42LTMuOCwzLjZjLTIuMSwwLTMuOS0xLjktMy45LTQuMmMwLTIuMSwxLjQtMy44LDMuMy00LjF2LTZMMTIuNyw5OS4zTDEyLjcsOTkuM3oiLz4KCQkJCQkJCTxwYXRoIGlkPSLmpK3lnIblvaJfMV8iIGNsYXNzPSJzdDEwIiBkPSJNMTIuMSwxMDAuNGMzLjEsMCw3LjItNi41LDcuMi0xMC41cy0zLjItNy4yLTcuMi03LjJTNSw4Niw1LDg5LjkKCQkJCQkJCQlDNSw5My45LDksMTAwLjQsMTIuMSwxMDAuNHoiLz4KCQkJCQkJCTxyZWN0IGlkPSLnn6nlvaJfM18iIHg9IjEyMi44IiB5PSIxMjEuNCIgY2xhc3M9InN0MTEiIHdpZHRoPSIxMDIuNCIgaGVpZ2h0PSIyLjIiLz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfMjFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEwMC4wMTg3IiB5MT0iLTEuMTk2NiIgeDI9IjEwMC4wMTg3IiB5Mj0iLTAuMjE2NiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgzLjQzMDEgMC43MjkxIC0xNC42NDAzIDY4Ljg3NzQgLTE2Ny45MTYxIDY1LjM3MjIpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUFFREYwIi8+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U3RTdFQiIvPgoJCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfNF8iIGNsYXNzPSJzdDEyIiBkPSJNMTkxLjMsNTQuMWwzLjQsMC43bC0xNC42LDY4LjVjLTAuNywwLjEtMS4zLDAuMS0xLjksMGMtMC41LTAuMS0xLjEtMC40LTEuNS0wLjcKCQkJCQkJCQlMMTkxLjMsNTQuMXoiLz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaLlpIfku70tMjJfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTI2LjUyOTciIHkxPSI1Ljk2NiIgeDI9IjEyNi41Mjk3IiB5Mj0iNi45NDYyIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEuNjQ2NyAzLjA5NzEgLTQyLjI3MjQgMjIuNDc2NiAyODEuMjI3MSAtNDIzLjY4NzkpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUZGMkY1Ii8+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U3RTdFQiIvPgoJCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaLlpIfku70tMjIiIGNsYXNzPSJzdDEzIiBkPSJNMjM3LjQsMTAwLjNsMS42LDMuMWwtMzkuNSwyMC43Yy0wLjQsMC0xLjItMC4xLTIuNC0wLjNjLTEuMi0wLjItMS45LTAuNi0yLTEKCQkJCQkJCQlMMjM3LjQsMTAwLjN6Ii8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i6Lev5b6ELTIzXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEwMC41MTkxIiB5MT0iLTUzLjE4NjciIHgyPSIxMDAuNTE5MSIgeTI9Ii01Mi4xODY3IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDMuMzAyNiAwIDAgMy4zMDkxIC05OC42MjQzIDI3OC42MTQ2KSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0U3RThFQiIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNDQUNERDEiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cGF0aCBpZD0i6Lev5b6ELTIzIiBjbGFzcz0ic3QxNCIgZD0iTTIzMy40LDEwMi42bC0xLjcsMC43YzAsMC40LDAuMiwwLjksMC42LDEuNWMwLjQsMC41LDAuOCwwLjksMS4zLDEuMWwxLjQtMC42CgkJCQkJCQkJTDIzMy40LDEwMi42eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8yMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjIxLjUyODEiIHkxPSItOC44NjUzIiB4Mj0iMjIxLjUyODEiIHkyPSItNy44NjUzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDgzLjY2NjcgMCAwIDE5Ljg1NDUgLTE4MzUxLjE3NTggMzEyLjgxNjEpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTNFNUU4Ii8+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMC45NzEzIiBzdHlsZT0ic3RvcC1jb2xvcjojQ0RDRUQxIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol81XyIgeD0iMTQxLjUiIHk9IjEzNi44IiBjbGFzcz0ic3QxNSIgd2lkdGg9IjgzLjciIGhlaWdodD0iMTkuOSIvPgoJCQkJCQkJPHBhdGggaWQ9Iui3r+W+hC0yMCIgY2xhc3M9InN0MTYiIGQ9Ik0xNDAuNCwxNTYuN2gxMC4yYy0wLjEtMy4xLDItNS4yLDYuNC02LjNzMjcuMS0zLjcsNjguMi03Ljl2LTMuMXYtOS4yaC04NC44CgkJCQkJCQkJTDE0MC40LDE1Ni43TDE0MC40LDE1Ni43eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9Iui3r+W+hC0xOV8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMjMuMDY1NCIgeTE9Ii01LjMxNzkiIHgyPSIyMjMuMDY1NCIgeTI9Ii00LjMyNjQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTIxLjA5NjUgMCAwIDMzLjA5MDkgLTI2ODQ3Ljc0MjIgMjk5LjU3NTEpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxLjE4NzcxMWUtMDIiIHN0eWxlPSJzdG9wLWNvbG9yOiNGM0YzRjUiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTFFM0U2Ii8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBhdGggaWQ9Iui3r+W+hC0xOSIgY2xhc3M9InN0MTciIGQ9Ik0yMjUuMiwxMjMuNkgxMDQuMXYzMy4xSDE0NGMxLTQuMSwyLjgtNi42LDUuNC03LjVjMi42LTAuOSwyNy45LTMuMiw3NS45LTYuOQoJCQkJCQkJCUwyMjUuMiwxMjMuNkwyMjUuMiwxMjMuNnoiLz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfOV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjE2LjI4NzQiIHkxPSItNS4zMDUyIiB4Mj0iMjE2LjI4NzQiIHkyPSItNC4zMjU1IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQwLjczMTYgMCAwIDMzLjA5MDkgLTg2ODUuMjgxMiAyOTkuNTc1MSkiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNEU3RUIiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRDhEQURDIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF8yXyIgY2xhc3M9InN0MTgiIGQ9Ik0xNDQuOCwxMjMuNnYyNS42YzAsMS0wLjcsMS44LTEuNiwybC0zMC41LDUuNWgtOC42di0zMy4xSDE0NC44eiIvPgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol82XyIgeD0iMTI5LjQiIHk9IjE1Ni43IiBjbGFzcz0ic3QxOSIgd2lkdGg9IjM3LjQiIGhlaWdodD0iMi4yIi8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i6Lev5b6ELTIxXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIyNC4yODg2IiB5MT0iLTEuNjQxOSIgeDI9IjIyNS4wNzM4IiB5Mj0iLTEuNDcwMiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMTkuMDc0NiAwIDAgODkuMzQ1NSAtNDkwNzYuNjYwMiAxODguMTYxNikiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNENUQ4REYiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQjVCOEMxIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBvbHlsaW5lIGlkPSLot6/lvoQtMjEiIGNsYXNzPSJzdDIwIiBwb2ludHM9IjE4LjIsMTIuMiAxOTIuOSw1My43IDIzNy4zLDEwMS41IAkJCQkJCQkiLz4KCQkJCQkJCTxwYXRoIGlkPSLot6/lvoQtMjIiIGNsYXNzPSJzdDIxIiBkPSJNMTg5LjksNTkuOWMwLjQsMC4zLDAuOSwwLjUsMS40LDAuN3MxLDAuMiwxLjYsMC4xbDAuMy0xLjRsLTMtMC44TDE4OS45LDU5Ljl6Ii8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzJfIiBjbGFzcz0ic3QyMiIgY3g9IjE5My4yIiBjeT0iNTQuMSIgcng9IjQuNSIgcnk9IjQuNSIvPgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9oi00IiB4PSIxMjIuOCIgeT0iMTIzLjYiIGNsYXNzPSJzdDIzIiB3aWR0aD0iMTAyLjQiIGhlaWdodD0iMS4xIi8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzIzXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMTAuNDAzNSIgeTE9Ii0zLjY5ODIiIHgyPSIyMTEuMTExMSIgeTI9Ii0zLjY5ODIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMjYuNDIxMSAwIDAgNDEuOTE1MSAtNTMzMS4xMDMgMjkyLjk2MikiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFRkYwRjIiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwLjQ3MjQiIHN0eWxlPSJzdG9wLWNvbG9yOiNGNEY1RjciLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRUVGMEYyIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol83XyIgeD0iMjI0LjEiIHk9IjExNyIgY2xhc3M9InN0MjQiIHdpZHRoPSIyNi40IiBoZWlnaHQ9IjQxLjkiLz4KCQkJCQkJCTxyZWN0IGlkPSLnn6nlvaJfOF8iIHg9IjIyMyIgeT0iMTIxLjQiIGNsYXNzPSJzdDI1IiB3aWR0aD0iMS4xIiBoZWlnaHQ9IjMuMyIvPgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS0yMyIgeD0iMjIzIiB5PSIxMjQuNyIgY2xhc3M9InN0MjYiIHdpZHRoPSIxLjEiIGhlaWdodD0iMTcuNiIvPgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol85XyIgeD0iMjIzIiB5PSIxNDIuMyIgY2xhc3M9InN0MjciIHdpZHRoPSIxLjEiIGhlaWdodD0iMTQuMyIvPgoJCQkJCQkJPGVsbGlwc2UgaWQ9IuakreWchuW9ol8zXyIgY2xhc3M9InN0MjMiIGN4PSIyMzcuMyIgY3k9IjExNyIgcng9IjEzLjIiIHJ5PSIyLjIiLz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaLlpIfku70tOF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMTAuNDAzNSIgeTE9Ii0zOS4zODQzIiB4Mj0iMjExLjExMTEiIHkyPSItMzkuMzg0MyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyNi40MjExIDAgMCA0LjQxMjEgLTUzMzEuMTAzIDMzMi42Njc0KSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VGRjBGMiIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAuNDcyNCIgc3R5bGU9InN0b3AtY29sb3I6I0Y0RjVGNyIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFRUYwRjIiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTgiIGNsYXNzPSJzdDI4IiBjeD0iMjM3LjMiIGN5PSIxNTguOSIgcng9IjEzLjIiIHJ5PSIyLjIiLz4KCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTBfIiBjbGFzcz0ic3QyOSIgZD0iTTIzNi4yLDEwNS45aDMuM3YxMC41Yy0wLjYsMC4zLTEuMSwwLjUtMS43LDAuNXMtMS4xLTAuMi0xLjctMC41TDIzNi4yLDEwNS45CgkJCQkJCQkJTDIzNi4yLDEwNS45eiIvPgoJCQkJCQkJPHBhdGggaWQ9Iui3r+W+hC0yNCIgY2xhc3M9InN0MzAiIGQ9Ik0yMzYuMiwxMDZ2MS43YzAuNCwwLjMsMSwwLjQsMS43LDAuNHMxLjItMC4xLDEuNy0wLjR2LTEuOEwyMzYuMiwxMDZ6Ii8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTkiIGNsYXNzPSJzdDIyIiBjeD0iMjM3LjMiIGN5PSIxMDIuNiIgcng9IjQuNSIgcnk9IjQuNSIvPgoJCQkJCQkJPGcgaWQ9Iue8lue7hC02IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2OS45Mzc1MTYsIDE1OC44NzA1OTQpIj4KCQkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzRfIiBjbGFzcz0ic3QzMSIgY3g9IjExLjEiIGN5PSIxMSIgcng9IjguOCIgcnk9IjguNyIvPgoJCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaLlpIfku70tMTAiIGNsYXNzPSJzdDMxIiBjeD0iMTQxLjkiIGN5PSIxMSIgcng9IjguOCIgcnk9IjguNyIvPgoJCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTFfIiBjbGFzcz0ic3QzMiIgZD0iTTExLjEsMTAuOWg3YzAuNywwLDEuMiwwLjYsMS4yLDEuMmwwLDBjMCwwLjctMC42LDEuMi0xLjIsMS4yaC03CgkJCQkJCQkJCWMtMC43LDAtMS4yLTAuNi0xLjItMS4ybDAsMEM5LjgsMTEuNSwxMC40LDEwLjksMTEuMSwxMC45eiIvPgoJCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTJfIiBjbGFzcz0ic3QzMiIgZD0iTTEzNC45LDEwLjloN2MwLjcsMCwxLjIsMC42LDEuMiwxLjJsMCwwYzAsMC43LTAuNiwxLjItMS4yLDEuMmgtNwoJCQkJCQkJCQljLTAuNywwLTEuMi0wLjYtMS4yLTEuMmwwLDBDMTMzLjcsMTEuNSwxMzQuMywxMC45LDEzNC45LDEwLjl6Ii8+CgkJCQkJCQkJPHBhdGggaWQ9IuefqeW9ol8xM18iIGNsYXNzPSJzdDMzIiBkPSJNMTAuOSw5LjhoMTMxLjNjMC44LDAsMS41LDAuNywxLjUsMS41djAuNWMwLDAuOC0wLjcsMS41LTEuNSwxLjVIMTAuOQoJCQkJCQkJCQljLTAuOCwwLTEuNS0wLjctMS41LTEuNXYtMC41QzkuNCwxMC41LDEwLjEsOS44LDEwLjksOS44eiIvPgoJCQkJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfM18iIGNsYXNzPSJzdDM0IiBkPSJNMTQyLjIsOS44YzAuNywwLDEuMywwLjUsMS41LDEuMkg5LjRjMC4yLTAuNywwLjctMS4yLDEuNS0xLjJIMTQyLjJ6Ii8+CgoJCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8yNF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iODMuODcwMyIgeTE9Ii04Ljc1ODciIHgyPSI4My44NzAzIiB5Mj0iLTcuNzczNCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxNTEuMDIxOSAwIDAgMjAuMDYwNiAtMTI1ODkuNzU3OCAxNzYuOTk5OSkiPgoJCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRDdEOERCIi8+CgkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNEMEQzRDYiLz4KCQkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTRfIiBjbGFzcz0ic3QzNSIgZD0iTTEwLjUsMWgxMzJjNS4yLDAsOS41LDQuMyw5LjUsOS41djEuMWMwLDUuMi00LjMsOS41LTkuNSw5LjVoLTEzMgoJCQkJCQkJCQljLTUuMiwwLTkuNS00LjMtOS41LTkuNXYtMS4xQzEsNS4zLDUuMywxLDEwLjUsMXoiLz4KCgkJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzI1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI4My44MTI5IiB5MT0iLTEwLjM4NDQiIHgyPSI4My44MTI5IiB5Mj0iLTkuNDI0MiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxNDcuOTE4NCAwIDAgMTYuOTQ4NSAtMTIzMjAuOTE3IDE3OC41NTY0KSI+CgkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNDRENFRDEiLz4KCQkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0VFRUZGMSIvPgoJCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQkJPHBhdGggaWQ9IuefqeW9ol8xNV8iIGNsYXNzPSJzdDM2IiBkPSJNMTAuMSwyLjZIMTQzYzQuMSwwLDcuNSwzLjQsNy41LDcuNVYxMmMwLDQuMS0zLjQsNy41LTcuNSw3LjVIMTAuMQoJCQkJCQkJCQljLTQuMSwwLTcuNS0zLjQtNy41LTcuNXYtMS45QzIuNiw1LjksNS45LDIuNiwxMC4xLDIuNnoiLz4KCQkJCQkJCTwvZz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfMjZfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxNi41NTc1IiB5MT0iLTQuMzU0IiB4Mj0iMjE2LjU1NzUiIHkyPSItMy4zNTQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNDEuODMzMyAwIDAgNDAuNDIyNyAtODkzNi40NjY4IDI5MS44NDkyKSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0YwRjFGMiIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNkU4RUIiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cGF0aCBpZD0i55+p5b2iXzE2XyIgY2xhc3M9InN0MzciIGQ9Ik0xMTUuOSwxMTUuOWgyNS44YzEuMSwwLDIsMC45LDIsMnYyOS43YzAsMS0wLjcsMS44LTEuNiwybC0zNy44LDYuOAoJCQkJCQkJCWMtMS4xLDAuMi0yLjEtMC41LTIuMy0xLjZjMC0wLjEsMC0wLjIsMC0wLjRWMTMwQzEwMS45LDEyMi4xLDEwOC4xLDExNS45LDExNS45LDExNS45eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8yN18iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjA0LjI3MzIiIHkxPSItNy45NzgiIHgyPSIyMDQuMjczMiIgeTI9Ii02Ljk3OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxOC43MTQ5IDAgMCAyMi4wNjA2IC0zNzA4LjQwMzEgMjk1LjE2MTUpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTZFOEVCIi8+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0Q3RDlEQyIvPgoJCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTdfIiBjbGFzcz0ic3QzOCIgZD0iTTExNS4yLDExOS4yaDguN2wwLDB2MjAuOWwtMTguNywxLjJ2LTEyLjFDMTA1LjIsMTIzLjYsMTA5LjYsMTE5LjIsMTE1LjIsMTE5LjJ6Ii8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzI4XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxOTcuNDMzMiIgeTE9Ii04LjM5OCIgeDI9IjE5Ny40MzMyIiB5Mj0iLTcuMzk4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDE0LjMxMTQgMCAwIDIwLjk1NzYgLTI2OTIuMjk1MiAyOTUuMTU3OSkiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNkU4RUIiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRDdEOURDIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBhdGggaWQ9IuefqeW9ol8xOF8iIGNsYXNzPSJzdDM5IiBkPSJNMTI2LjEsMTE5LjJoMTMuM2MwLjYsMCwxLDAuNCwxLDFWMTM5bDAsMGwtMTQuMywxLjIKCQkJCQkJCQlDMTI2LjEsMTQwLjIsMTI2LjEsMTE5LjIsMTI2LjEsMTE5LjJ6Ii8+CgkJCQkJCTwvZz4KCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF80XyIgY2xhc3M9InN0NDAiIGQ9Ik0xOTIuMiwxNjkuOGM4Ny41LTcuNywxNTYuOC0zMywxNTQuNy01Ni43Yy0yLjEtMjMuNi03NC43LTM2LjYtMTYyLjItMjkKCQkJCQkJCVMyOCwxMTcuMiwzMCwxNDAuOVMxMDQuNywxNzcuNSwxOTIuMiwxNjkuOHogTTE5Mi4yLDE2OC44Yy04Ni45LDcuNi0xNTkuMS01LjMtMTYxLjEtMjhzNjYuOS00OCwxNTMuOC01NS42CgkJCQkJCQlzMTU5LjEsNS4zLDE2MS4xLDI4QzM0Ny45LDEzNiwyNzksMTYxLjIsMTkyLjIsMTY4Ljh6Ii8+CgkJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfNV8iIGNsYXNzPSJzdDQwIiBkPSJNMjM1LjMsNTEuOWM0NS4xLTE3LjMsNzkuOS0yMS4yLDg4LTcuM2MxMiwyMC44LTQwLjIsNzMuNC0xMTYuNSwxMTcuNQoJCQkJCQkJcy0xNDgsNjMtMTYwLDQyLjFTODcsMTMwLjgsMTYzLjMsODYuN0MxODQuNiw3NC41LDIwNS42LDY0LjEsMjI1LDU2YzAuMSwwLjMsMC4zLDAuNiwwLjQsMC45QzIwNiw2NSwxODUsNzUuMywxNjMuNyw4Ny42CgkJCQkJCQlDODcuOSwxMzEuNSwzNiwxODMuOCw0Ny42LDIwMy44czgyLjgsMS4zLDE1OC43LTQyLjVTMzM0LDY1LjIsMzIyLjQsNDUuMmMtNy43LTEzLjQtNDIuMi05LjQtODYuOCw3LjgKCQkJCQkJCUMyMzUuNSw1Mi42LDIzNS40LDUyLjMsMjM1LjMsNTEuOUwyMzUuMyw1MS45eiIvPgoJCQkJCQk8ZyBpZD0i57yW57uELTkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLCAzOC4wMDAwMDApIj4KCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaJfNV8iIGNsYXNzPSJzdDQxIiBjeD0iMzAzLjEiIGN5PSI1MC4yIiByeD0iMi44IiByeT0iMi44Ii8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzZfIiBjbGFzcz0ic3Q0MSIgY3g9IjMxNi4zIiBjeT0iMS43IiByeD0iMS43IiByeT0iMS43Ii8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzdfIiBjbGFzcz0ic3Q0MSIgY3g9IjEyMS42IiBjeT0iMTM2LjIiIHJ4PSIyLjgiIHJ5PSIyLjgiLz4KCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaJfOF8iIGNsYXNzPSJzdDQxIiBjeD0iMzMiIGN5PSI5MC40IiByeD0iMS4xIiByeT0iMS4xIi8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzlfIiBjbGFzcz0ic3Q0MSIgY3g9IjI5MC41IiBjeT0iMTE0LjciIHJ4PSIxLjEiIHJ5PSIxLjEiLz4KCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaJfMTBfIiBjbGFzcz0ic3Q0MSIgY3g9IjcwLjQiIGN5PSIzNS4zIiByeD0iMi4yIiByeT0iMi4yIi8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTYiIGNsYXNzPSJzdDQxIiBjeD0iMS43IiBjeT0iNjguOSIgcng9IjEuNyIgcnk9IjEuNyIvPgoJCQkJCQkJPGVsbGlwc2UgaWQ9IuakreWchuW9ouWkh+S7vS01XzFfIiBjbGFzcz0ic3Q0MSIgY3g9IjIzMy44IiBjeT0iMTU5LjMiIHJ4PSIxLjciIHJ5PSIxLjciLz4KCQkJCQkJPC9nPgoJCQkJCTwvZz4KCQkJCTwvZz4KCQkJPC9nPgoJCTwvZz4KCTwvZz4KPC9nPgo8L3N2Zz4K";
var empty = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCPot6/lvoQtM18xXyk7fQoJLnN0MntmaWxsOnVybCgj5b2i54q257uT5ZCIXzJfKTt9Cgkuc3Qze2ZpbGw6I0M0QzZDQzt9Cjwvc3R5bGU+CjxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjI0MS40NDI3IiB5MT0iODQuOTYwMSIgeDI9IjI0Ny41MTg0IiB5Mj0iNTAuNTAyOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDI0MCkiPgoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZCRkNGRCIvPgoJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0YwRjJGNSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cGF0aCBpZD0iRmlsbC0xIiBjbGFzcz0ic3QwIiBkPSJNMTg4LDE2NC43YzE2LjMtMy43LDM5LjctNS4zLDU1LjYtNC41czI5LjEsMy42LDMwLDIuOWMzLjItMi4xLDEwLTMsOS42LTIuMgoJYy0wLjMsMC44LTQuNywzLjQtMy4zLDMuOGMxLjQsMC40LDE1LjYsMiwyMS41LDMuM2M1LjksMS4yLDkuNywyLjQsMTEsMi40czMuMy0xLjcsMTEuOC0wLjljMC4yLDAuMy0xLjksMC40LTMuOCwxLjQKCXMtMy4zLDAuOS0zLjMsMS4xczEuMS0wLjMsMy4zLDEuMWMyLjIsMS40LDYuMSwxLjksNi4xLDIuMnMtNC45LDItMTMuMi0wLjZjLTIuMS0wLjctNyw1LjEtMjkuNSw2LjdzLTYwLjUsMi45LTYwLjUsMi45CglzMi4zLDIuOSw1LjYsMy44YzAuMiwwLjMtMS4zLDEuNC03LjgsMC4ycy05LjktMy45LTkuOS0zLjlzLTEyLjgtMC44LTE3LjYtMS42cy0xMC40LTIuOS0xNC4yLTMuM2MtMy44LTAuNC0yMS4xLTIuNC0xNC41LTYuOQoJQzE2NC43LDE3Mi41LDE3MS43LDE2OC40LDE4OCwxNjQuN3oiLz4KPGxpbmVhckdyYWRpZW50IGlkPSLot6/lvoQtM18xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI0MTIuNTYwNiIgeTE9Ii0zLjExMzMiIHgyPSI0MTIuNTYwNiIgeTI9Ii0yLjE3NzMiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTA1LjYgMCAwIDU2LjMyIC00MzMyNi40MDIzIDI3OC40MDAxKSI+Cgk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTZFOEVCO3N0b3Atb3BhY2l0eTowLjk5MTciLz4KCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNENEQ2RDkiLz4KPC9saW5lYXJHcmFkaWVudD4KPHBvbHlnb24gaWQ9Iui3r+W+hC0zIiBjbGFzcz0ic3QxIiBwb2ludHM9IjE4Ny4yLDEzNy42IDIxMC43LDEwMi40IDI2OS4zLDEwMi40IDI5Mi44LDEzNy42IDI5Mi44LDE1OC43IDE4Ny4yLDE1OC43ICIvPgo8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF8yXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI0MTIuNTYwNiIgeTE9Ii01IiB4Mj0iNDEyLjU2MDYiIHkyPSItNC4wMDc5IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEwNS42IDAgMCAzNS4yIC00MzMyNi40MDIzIDMxMy42MDA0KSI+Cgk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRURFRkYyIi8+Cgk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRThFQUVEIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxwYXRoIGlkPSLlvaLnirbnu5PlkIgiIGNsYXNzPSJzdDIiIGQ9Ik0yMTIuNiwxNzIuOGgtMjMuNGMtMS4xLDAtMi0wLjktMi0ydi0zMy4yaDIzLjRjMS4xLDAsMiwwLjksMiwydjcuNGMwLDEuMSwwLjgsMS45LDEuOSwyCgloMC4xaDUwLjhjMS4xLDAsMS45LTAuOCwyLTEuOVYxNDd2LTcuNGMwLTEuMSwwLjktMiwyLTJoMjMuNHYzMy4yYzAsMS4xLTAuOSwyLTIsMmgtMjMuNEgyMTIuNnoiLz4KPHBhdGggaWQ9IuW9oueKtue7k+WQiF8xXyIgY2xhc3M9InN0MyIgZD0iTTE4Mi40LDE2OS42djhoOHYxLjZoLTkuNnYtOS42SDE4Mi40eiIvPgo8cGF0aCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9IiBjbGFzcz0ic3QzIiBkPSJNMjg5LjYsMTc3LjZoOHYtOGgxLjZ2OS42aC05LjZWMTc3LjZ6Ii8+CjxnIGlkPSLnvJbnu4QtNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTEuNjg4ODkwLCAxMS44NzQ5MzYpIHJvdGF0ZSgyMS4wMDAwMDApIHRyYW5zbGF0ZSgtOTEuNjg4ODkwLCAtMTEuODc0OTM2KSB0cmFuc2xhdGUoOTAuODg4ODkwLCAwLjY3NDkzNikiPgoKCQk8cmVjdCBpZD0i55+p5b2iXzFfIiB4PSIxODMuMSIgeT0iMjQuNSIgdHJhbnNmb3JtPSJtYXRyaXgoNS40NDk4OTllLTA2IDEgLTEgNS40NDk4OTllLTA2IDIwOS45Mzc5IC0xNTkuMzkzOCkiIGNsYXNzPSJzdDMiIHdpZHRoPSIzLjIiIGhlaWdodD0iMS42Ii8+CgoJCTxyZWN0IGlkPSLnn6nlvaLlpIfku70tNiIgeD0iMTgzLjEiIHk9IjMwLjkiIHRyYW5zZm9ybT0ibWF0cml4KDUuNDQ5ODk4ZS0wNiAxIC0xIDUuNDQ5ODk4ZS0wNiAyMTYuMzM3OCAtMTUyLjk5MzkpIiBjbGFzcz0ic3QzIiB3aWR0aD0iMy4yIiBoZWlnaHQ9IjEuNiIvPgoKCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTciIHg9IjE4My4xIiB5PSIzNy4zIiB0cmFuc2Zvcm09Im1hdHJpeCg1LjQ0OTg5OGUtMDYgMSAtMSA1LjQ0OTg5OGUtMDYgMjIyLjczNzkgLTE0Ni41OTM5KSIgY2xhc3M9InN0MyIgd2lkdGg9IjMuMiIgaGVpZ2h0PSIxLjYiLz4KCgkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS04IiB4PSIxODMuMSIgeT0iNDMuNyIgdHJhbnNmb3JtPSJtYXRyaXgoNS40NDk4OTllLTA2IDEgLTEgNS40NDk4OTllLTA2IDIyOS4xMzc5IC0xNDAuMTkzOSkiIGNsYXNzPSJzdDMiIHdpZHRoPSIzLjIiIGhlaWdodD0iMS42Ii8+CjwvZz4KPGcgaWQ9Iue8lue7hC0zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNi4wMDAwMDAsIDI3LjIwMDAwMCkgcm90YXRlKC0zMi4wMDAwMDApIHRyYW5zbGF0ZSgtMzYuMDAwMDAwLCAtMjcuMjAwMDAwKSB0cmFuc2xhdGUoMzUuMjAwMDAwLCAxMi44MDAwMDApIj4KCgkJPHJlY3QgaWQ9IuefqeW9ol8yXyIgeD0iOTEuNyIgeT0iMTYxLjEiIHRyYW5zZm9ybT0ibWF0cml4KC0xIDUuNDI2MzM3ZS0wNiAtNS40MjYzMzdlLTA2IC0xIDE4NS4wNzUzIDMyNS40NDM4KSIgY2xhc3M9InN0MyIgd2lkdGg9IjEuNiIgaGVpZ2h0PSIzLjIiLz4KCgkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS0yIiB4PSI5MS43IiB5PSIxNjcuNSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgNS40MjYzMzZlLTA2IC01LjQyNjMzNmUtMDYgLTEgMTg1LjA3NTUgMzM4LjI0MzgpIiBjbGFzcz0ic3QzIiB3aWR0aD0iMS42IiBoZWlnaHQ9IjMuMiIvPgoKCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTMiIHg9IjkxLjciIHk9IjE3My45IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSA1LjQyNjMzNmUtMDYgLTUuNDI2MzM2ZS0wNiAtMSAxODUuMDc1NSAzNTEuMDQzOSkiIGNsYXNzPSJzdDMiIHdpZHRoPSIxLjYiIGhlaWdodD0iMy4yIi8+CgoJCTxyZWN0IGlkPSLnn6nlvaLlpIfku70tNCIgeD0iOTEuNyIgeT0iMTgwLjMiIHRyYW5zZm9ybT0ibWF0cml4KC0xIDUuNDI2MzM2ZS0wNiAtNS40MjYzMzZlLTA2IC0xIDE4NS4wNzU1IDM2My44NDM4KSIgY2xhc3M9InN0MyIgd2lkdGg9IjEuNiIgaGVpZ2h0PSIzLjIiLz4KCgkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS01IiB4PSI5MS43IiB5PSIxODYuNyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgNS40MjYzMzdlLTA2IC01LjQyNjMzN2UtMDYgLTEgMTg1LjA3NTUgMzc2LjY0MzgpIiBjbGFzcz0ic3QzIiB3aWR0aD0iMS42IiBoZWlnaHQ9IjMuMiIvPgo8L2c+CjxjaXJjbGUgaWQ9IuakreWchuW9oiIgY2xhc3M9InN0MyIgY3g9IjI2OC44IiBjeT0iOTQuNCIgcj0iMS42Ii8+CjxjaXJjbGUgaWQ9IuakreWchuW9ouWkh+S7vSIgY2xhc3M9InN0MyIgY3g9IjIyNy4yIiBjeT0iMTIwIiByPSIxLjYiLz4KPC9zdmc+Cg==";
var login = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8yXzFfIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgj5b2i54q257uT5ZCIXzNfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfN18pO30KCS5zdDJ7ZmlsbDojQzRDNkNDO30KCS5zdDN7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF85Xyk7fQoJLnN0NHtmaWxsOnVybCgj5b2i54q257uT5ZCIXzEwXyk7ZmlsbC1vcGFjaXR5OjAuNjt9Cgkuc3Q1e2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfMTFfKTt9Cgkuc3Q2e2ZpbGw6dXJsKCPot6/lvoQtM18xXyk7fQoJLnN0N3tmaWxsOnVybCgj5b2i54q257uT5ZCIXzEyXyk7fQoJLnN0OHtmaWxsOnVybCgj6Lev5b6ELTNfNF8pO30KCS5zdDl7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF8xM18pO30KCS5zdDEwe2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfMTVfKTt9Cgkuc3QxMXtmaWxsOiM5NzlCQTU7fQoJLnN0MTJ7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9Cgkuc3QxM3tmaWxsOnVybCgjU1ZHSURfMl8pO30KCS5zdDE0e2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfMTZfKTt9Cgkuc3QxNXtmaWxsOnVybCgj5b2i54q257uT5ZCI5aSH5Lu9LTJfMl8pO30KCS5zdDE2e2ZpbGw6IzM0MzQzNDtmaWxsLW9wYWNpdHk6MC4xO30KPC9zdHlsZT4KPGcgaWQ9Iumhtemdoi0xIj4KCTxnIGlkPSJFeGNlcHRpb25feDJGX+W8guW4uOaPkOekul94MkZf54Gw55m95a+55q+UIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOTI0LjAwMDAwMCwgLTcwNy4wMDAwMDApIj4KCQk8ZyBpZD0i6ZyA6KaB55m75b2VIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5MjQuMDAwMDAwLCA3MDcuMDAwMDAwKSI+CgoJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfM18iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTAxOS45MDA2IiB5MT0iLTguMzM1NCIgeDI9IjEwMTkuOTAwNiIgeTI9Ii03LjMzNjciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMjAwLjAyNTcgMCAwIDU4LjMwNDcgLTIwMzc1OS41NDY5IDY2My45OTQ0KSI+CgkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjVGNkY3Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjdGOUZDIi8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMzBfIiBjbGFzcz0ic3QwIiBkPSJNMjQ5LjYsMTc4djguN2MwLDIuNSwyLjEsNC42LDQuNiw0LjZzNC41LDEuOSw0LjYsNC40djAuMnYwLjkKCQkJCWMxLjEtMC41LDIuMy0wLjgsMy41LTAuOGM0LjMsMCw3LjgsMy4yLDguNCw3LjNjMS0wLjgsMi4yLTEuMywzLjYtMS4zYzEuMiwwLDIuMywwLjQsMy4yLDFjMi4zLTQuMiw2LjctNywxMS44LTcKCQkJCWM3LjIsMCwxMyw1LjYsMTMuNSwxMi43YzQuOSwwLjcsMTAuMSwxLjUsMTMuMywyLjFjNy4yLDEuNSwxMS44LDMsMTMuNCwzczQtMi4xLDE0LjUtMS4xYzAuMiwwLjQtMi4zLDAuNS00LjcsMS43cy00LDEuMS00LDEuNAoJCQkJczEuMy0wLjQsNCwxLjNzNy41LDIuMyw3LjUsMi44cy02LjEsMi40LTE2LjItMC44Yy0yLjYtMC44LTguNiw2LjItMzYuMSw4LjJjLTI3LjYsMi03NC4yLDMuNS03NC4yLDMuNXMyLjgsMy42LDYuOSw0LjYKCQkJCWMwLjIsMC40LTEuNiwxLjctOS42LDAuMmMtNy45LTEuNS0xMi4yLTQuOC0xMi4yLTQuOHMtMTUuNy0xLTIxLjYtMmMtNS45LTEtMTIuNy0zLjUtMTcuNC00cy0yNS45LTMtMTcuOC04LjUKCQkJCWMwLDAsNy4yLTQuMiwyMy42LTguM2MyLTMuNSw1LjctNS45LDEwLjEtNS45YzIuNywwLDUuMiwwLjksNy4xLDIuNWMxLjQtMC4yLDIuOS0wLjQsNC40LTAuNmMxLjItMS4xLDIuOC0xLjgsNC41LTEuOAoJCQkJYzEuMiwwLDIuMywwLjMsMy4yLDAuOWwwLjUtMC4xYzEtMy45LDQuNS02LjgsOC43LTYuOGMyLjgsMCw1LjQsMS4zLDcsMy4zdi0yLjhjMC0yLjksMi40LTUuMyw1LjMtNS4zYzIuOCwwLDUuMi0yLjIsNS4zLTUuMQoJCQkJdi0wLjJ2LThMMjQ5LjYsMTc4TDI0OS42LDE3OHoiLz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF83XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMDAzLjIzODQiIHkxPSItNDMuNjgxOCIgeDI9IjEwMDMuOTQ2MSIgeTI9Ii00My42ODE4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQ0IDAgMCAxMSAtNDM5MTkuMTk5MiA2NTUuNSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UyRTNFNiIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMC40NTQzIiBzdHlsZT0ic3RvcC1jb2xvcjojRUNFRUYwIi8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTJFNEU2Ii8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMjlfIiBjbGFzcz0ic3QxIiBkPSJNMjE2LjgsMTY5LjVoNDR2NmMwLDIuOC05LjgsNS0yMiw1cy0yMi0yLjItMjItNWwwLDBMMjE2LjgsMTY5LjVMMjE2LjgsMTY5LjV6Ii8+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIjlpIfku71fMV8iIGNsYXNzPSJzdDIiIGQ9Ik0yMTYuOCwxNjVoNDR2NmMwLDIuOC05LjgsNS0yMiw1cy0yMi0yLjItMjItNWwwLDBMMjE2LjgsMTY1TDIxNi44LDE2NXoiLz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF85XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI5NDcuNDg4OCIgeTE9Ii04LjM4NDgiIHgyPSI5NDguMTg2MyIgeTI9Ii04LjM4NDgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTIgMCAwIDU0LjcgLTExMTc3LjIwMDIgNTgxLjI5OTEpIj4KCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMUYzRjUiLz4KCQkJCTxzdG9wICBvZmZzZXQ9IjAuNDU3NiIgc3R5bGU9InN0b3AtY29sb3I6I0Y0RjVGNyIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0VDRUVGMCIvPgoJCQk8L2xpbmVhckdyYWRpZW50PgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzI4XyIgY2xhc3M9InN0MyIgZD0iTTE5Ni44LDk1LjNjMS44LDAsNiw4LjMsNiwxMS43bDAsMHY0M2gtMTJ2LTQzdi0wLjJDMTkwLjksMTAzLjQsMTk1LDk1LjMsMTk2LjgsOTUuMwoJCQkJeiIvPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCIXzEwXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI5NDcuODQ2NCIgeTE9Ii0xOS44MjgyIiB4Mj0iOTQ3LjgyNyIgeTI9Ii0xOS42NDE4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEyIDAgMCAyNC4yIC0xMTA5My4yMDAyIDYwMi45OTkzKSI+CgkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojQ0REMEQyO3N0b3Atb3BhY2l0eTowIi8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQ0REMEQyIi8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwb2x5Z29uIGlkPSLlvaLnirbnu5PlkIhfMjZfIiBjbGFzcz0ic3Q0IiBwb2ludHM9IjI3NC44LDExNyAyNzQuOCwxMzIuNiAyNzkuNywxNDEuMiAyODYuOCwxMzUuNCAyODYuOCwxMjYgCQkJIi8+CgoJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfMTFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9Ijk0OC4xNzE2IiB5MT0iLTguMzg0OCIgeDI9Ijk0Ny40NzQxIiB5Mj0iLTguMzg0OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxMiAwIDAgNTQuNyAtMTEwOTMuMjAwMiA1ODEuMjk5MSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0YxRjNGNSIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMC40NTc2IiBzdHlsZT0ic3RvcC1jb2xvcjojRjRGNUY3Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRUNFRUYwIi8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMjVfIiBjbGFzcz0ic3Q1IiBkPSJNMjgwLjgsOTUuM2MtMS44LDAtNiw4LjMtNiwxMS43bDAsMHY0M2gxMnYtNDN2LTAuMgoJCQkJQzI4Ni42LDEwMy40LDI4Mi41LDk1LjMsMjgwLjgsOTUuM3oiLz4KCQkJPGcgaWQ9Iue8lue7hF8zXyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODAuNzYwNDk5LCA3Ny4wMDAwMDApIj4KCgkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLot6/lvoQtM18xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI1MTQuMzE0MSIgeTE9Ii02Ljg5MDUiIHgyPSI1MTQuMzk0MyIgeTI9Ii02LjUyMDQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMzYgMCAwIDY2IC0xODM5NS43MzI0IDUwNikiPgoJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFOEU5RUIiLz4KCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRDdEOERCIi8+CgkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJPHBhdGggaWQ9Iui3r+W+hC0zXzNfIiBjbGFzcz0ic3Q2IiBkPSJNMTM1LDIwYy0xLjQsNy00LjUsMTMuMy05LjQsMTkuMWMtNy4zLDguNy0xNS4yLDEzLjYtMTguNCwyMy44CgkJCQkJYy0yLjEsNi44LTMuMiwxMi45LTMuMiwxOC4zbDMyLjEsNC44bDMuOS00LjhMMTM1LDIweiIvPgoKCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF8xMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDY5LjEyNSIgeTE9Ii02Ljk4IiB4Mj0iNDY5LjEyNjMiIHkyPSItNi45NjgxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEzIDAgMCA2NC41IC01OTY1LjY4MTYgNTA3LjUpIj4KCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUJFREVGO3N0b3Atb3BhY2l0eTowIi8+CgkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0M4Q0FDQyIvPgoJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMjRfIiBjbGFzcz0ic3Q3IiBkPSJNMTM1LjIsMjEuNWw0LjgsNTkuN2wtMy45LDQuOGwtOS4xLTEuNGwzLjMtNTIuMmMyLTMuNSwzLjQtNy4xLDQuNC0xMC45CgkJCQkJQzEzNC43LDIxLjUsMTM1LjIsMjEuNSwxMzUuMiwyMS41eiIvPgoJCQk8L2c+CgoJCQkJPGcgaWQ9Iue8lue7hF8yXyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcxLjAwMDAwMCwgMTEwLjAwMDAwMCkgc2NhbGUoLTEsIDEpIHRyYW5zbGF0ZSgtMTcxLjAwMDAwMCwgLTExMC4wMDAwMDApIHRyYW5zbGF0ZSgxNTMuMDAwMDAwLCA3Ny4wMDAwMDApIj4KCgkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLot6/lvoQtM180XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNi4xMTk1IiB5MT0iLTYuNzUwNiIgeDI9IjI2LjE5OTgiIHkyPSItNi4zODA1IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDM2IDAgMCA2NiAtMTAyNCA1MDYpIj4KCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRThFOUVCIi8+CgkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0Q3RDhEQiIvPgoJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCTxwYXRoIGlkPSLot6/lvoQtM18yXyIgY2xhc3M9InN0OCIgZD0iTS03MywyMGMtMS40LDctNC41LDEzLjMtOS40LDE5LjFjLTcuMyw4LjctMTUuMiwxMy42LTE4LjQsMjMuOAoJCQkJCWMtMi4xLDYuOC0zLjIsMTIuOS0zLjIsMTguM2wzMi4xLDQuOGwzLjktNC44TC03MywyMHoiLz4KCQkJPC9nPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCIXzEzXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2NTkuNjQ1MyIgeTE9Ii02Ljk4IiB4Mj0iNjU5LjY0NjUiIHkyPSItNi45NjgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEzIDAgMCA2NC41IDg4MzkuMjE0OCA1ODQuNSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VCRURFRjtzdG9wLW9wYWNpdHk6MCIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0M4Q0FDQyIvPgoJCQk8L2xpbmVhckdyYWRpZW50PgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzJfIiBjbGFzcz0ic3Q5IiBkPSJNMjYxLjYsOTguNWwtNC44LDU5LjdsMy45LDQuOGw5LjEtMS40bC0zLjMtNTIuMmMtMi0zLjUtMy40LTcuMS00LjQtMTAuOQoJCQkJQzI2Mi4xLDk4LjUsMjYxLjYsOTguNSwyNjEuNiw5OC41eiIvPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCIXzE1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMDA0Ljk4MTEiIHkxPSItMi42NTU4IiB4Mj0iMTAwNS42ODg3IiB5Mj0iLTIuNjU1OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg0OCAwIDAgMTU0IC00ODAxNy4xOTkyIDUwNikiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VBRUJFRCIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMC40NTQzIiBzdHlsZT0ic3RvcC1jb2xvcjojRjRGNUY3Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRUVGMEYyIi8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMThfIiBjbGFzcz0ic3QxMCIgZD0iTTIzOC44LDIwYzcsMCwyNCwyNy43LDI0LDQxbDAsMHYxMDZjMCwwLjEsMCwwLjIsMCwwLjNzMCwwLjIsMCwwLjIKCQkJCWMwLDMuNi0xMC43LDYuNS0yNCw2LjVzLTI0LTIuOS0yNC02LjVjMC0wLjEsMC0wLjIsMC0wLjJjMC0wLjEsMC0wLjIsMC0wLjNWNjF2LTAuNEMyMTUuMSw0Ny4yLDIzMS44LDIwLDIzOC44LDIweiIvPgoJCQk8Zz4KCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol83XyIgY2xhc3M9InN0MTEiIGN4PSIyMzguOCIgY3k9IjcxIiByPSI5LjUiLz4KCgkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI5NzYuMDc5IiB5MT0iLTI1LjMzMzQiIHgyPSI5NzYuMDc5IiB5Mj0iLTI0LjgyNDQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTkgMCAwIDE5IC0xODMwNi42OTkyIDU0Ny41KSI+CgkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTJFNiIvPgoJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMEYyRjUiLz4KCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQk8cGF0aCBjbGFzcz0ic3QxMiIgZD0iTTIzOC44LDgxYy01LjUsMC0xMC00LjUtMTAtMTBzNC41LTEwLDEwLTEwczEwLDQuNSwxMCwxMFMyNDQuMyw4MSwyMzguOCw4MXogTTIzOC44LDYyYy01LDAtOSw0LTksOQoJCQkJCXM0LDksOSw5czktNCw5LTlTMjQzLjgsNjIsMjM4LjgsNjJ6Ii8+CgkJCTwvZz4KCQkJPGc+CgkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaLlpIfku70tMTFfMV8iIGNsYXNzPSJzdDExIiBjeD0iMjM4LjgiIGN5PSI4OSIgcj0iMy41Ii8+CgoJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iODkzLjA3MTUiIHkxPSItNjkuMjA0OCIgeDI9Ijg5My4wNzE1IiB5Mj0iLTY4LjY1MjIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNyAwIDAgNyAtNjAxMi43MDAyIDU3MS41KSI+CgkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTJFNiIvPgoJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMEYyRjUiLz4KCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQk8cGF0aCBjbGFzcz0ic3QxMyIgZD0iTTIzOC44LDkzYy0yLjIsMC00LTEuOC00LTRzMS44LTQsNC00czQsMS44LDQsNFMyNDEsOTMsMjM4LjgsOTN6IE0yMzguOCw4NmMtMS43LDAtMywxLjMtMywzczEuMywzLDMsMwoJCQkJCXMzLTEuMywzLTNTMjQwLjUsODYsMjM4LjgsODZ6Ii8+CgkJCTwvZz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF8xNl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTAwNC45ODExIiB5MT0iLTcwLjk3MDYiIHgyPSIxMDA1LjY4NTQiIHkyPSItNzAuOTcwNiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg0OCAwIDAgNi44IC00ODAxNy4xOTkyIDYyNC4wMDA0KSI+CgkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTJFM0U2Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIwLjQ3NjYiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQkZERkYiLz4KCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMkU0RTYiLz4KCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF8xNF8iIGNsYXNzPSJzdDE0IiBkPSJNMjYyLjgsMTM4djIuNWMtMy45LDIuNS0xMy4yLDQuMy0yNCw0LjNzLTIwLjEtMS44LTI0LTQuM1YxMzhsMCwwCgkJCQljMC42LDIuOCwxMS4xLDUuNSwyNCw1LjVTMjYyLjIsMTQwLjgsMjYyLjgsMTM4TDI2Mi44LDEzOHoiLz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiOWkh+S7vS0yXzJfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEwMDQuOTgxMSIgeTE9Ii03MC45NzA2IiB4Mj0iMTAwNS42ODU0IiB5Mj0iLTcwLjk3MDYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNDggMCAwIDYuOCAtNDgwMTcuMTk5MiA2MjkuMDAwNCkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UyRTNFNiIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMC40NzY2IiBzdHlsZT0ic3RvcC1jb2xvcjojRkJGREZGIi8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTJFNEU2Ii8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIjlpIfku70tMl8xXyIgY2xhc3M9InN0MTUiIGQ9Ik0yNjIuOCwxNDN2Mi41Yy0zLjksMi41LTEzLjIsNC4zLTI0LDQuM3MtMjAuMS0xLjgtMjQtNC4zVjE0M2wwLDAKCQkJCWMwLjYsMi44LDExLjEsNS41LDI0LDUuNVMyNjIuMiwxNDUuOCwyNjIuOCwxNDNMMjYyLjgsMTQzeiIvPgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzhfIiBjbGFzcz0ic3QxNiIgZD0iTTI2Mi44LDczYzQzLjItOC42LDc3LjEtNi4zLDgwLjksNi43YzQuNiwxNS45LTM3LjQsNDEuOS05My42LDU4LjEKCQkJCXMtMTA1LjYsMTYuMy0xMTAuMiwwLjRjLTQtMTQuMSwyOC40LTM2LjEsNzQuOS01Mi4xdjEuMWMtNDUuOCwxNS45LTc3LjcsMzcuNS03My45LDUwLjhjNC4zLDE1LjEsNTMuMiwxNC45LDEwOC45LTEuMQoJCQkJczk3LjMtNDEuNyw5Mi45LTU2LjhjLTMuNS0xMi40LTM3LjItMTQuNS03OS45LTZWNzNMMjYyLjgsNzN6Ii8+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDE2IiBkPSJNMTA1LjIsNzZjMy44LTE0LDUwLjctMTQsMTA5LjUtMS4xdjFjLTU4LjMtMTIuOC0xMDUtMTIuOS0xMDguNiwwLjMKCQkJCWMtNCwxNS4xLDQ5LjEsNDMuMiwxMTguNSw2MS44czEyOS41LDIwLjksMTMzLjYsNS44YzMuNi0xMy40LTM3LjctMzctOTUuNi01NS4xdi0xLjFjNTguNiwxOC4zLDEwMC4zLDQyLjIsOTYuNSw1Ni40CgkJCQljLTQuMywxNi02NC42LDEzLjctMTM0LjgtNS4xUzEwMSw5MiwxMDUuMiw3NnoiLz4KCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzZfIiBjbGFzcz0ic3QyIiBjeD0iMzE3LjgiIGN5PSIxMDkiIHI9IjIiLz4KCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzVfIiBjbGFzcz0ic3QyIiBjeD0iMTE3LjMiIGN5PSIxMjEuNSIgcj0iMS41Ii8+CgkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol80XyIgY2xhc3M9InN0MiIgY3g9IjI4MS44IiBjeT0iNTgiIHI9IjEiLz4KCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzNfIiBjbGFzcz0ic3QyIiBjeD0iMTkxLjgiIGN5PSIxNjQiIHI9IjEiLz4KCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzFfIiBjbGFzcz0ic3QyIiBjeD0iMzUxLjgiIGN5PSIxNTAiIHI9IjIiLz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==";
var searchEmpty = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6I0M0QzZDQzt9Cgkuc3Qye2ZpbGw6dXJsKCPnn6nlvaItMl8xXyk7fQoJLnN0M3tmaWxsOnVybCgj55+p5b2iXzZfKTt9Cgkuc3Q0e2ZpbGw6I0RDREVFMDt9Cgkuc3Q1e2ZpbGw6I0QxRDNENjt9Cgkuc3Q2e2ZpbGw6dXJsKCPnn6nlvaItM18xXyk7fQoJLnN0N3tmaWxsOiNFNUU3RUM7fQoJLnN0OHtmaWxsOiNEQ0RERTA7fQoJLnN0OXtmaWxsOnVybCgj6Lev5b6ELTEzXzFfKTt9Cgkuc3QxMHtmaWxsOnVybCgj5qSt5ZyG5b2iXzNfKTtzdHJva2U6dXJsKCPmpK3lnIblvaJfNF8pO30KCS5zdDExe2ZpbGw6dXJsKCPmpK3lnIblvaJfNV8pO3N0cm9rZTp1cmwoI+akreWchuW9ol82Xyk7fQoJLnN0MTJ7ZmlsbDojRkZGRkZGO30KPC9zdHlsZT4KPGcgaWQ9Iumhtemdoi0xIj4KCTxnIGlkPSJFeGNlcHRpb25feDJGX+W8guW4uOaPkOekuiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg2OS4wMDAwMDAsIC0yOTE4LjAwMDAwMCkiPgoJCTxnIGlkPSLmkJzntKLkuLrnqboiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDg2OS4wMDAwMDAsIDI5MTguMDAwMDAwKSI+CgkJCTxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjI0My4wNDY0IiB5MT0iMTY3Ljk3OTMiIHgyPSIyNDUuODA3MSIgeTI9IjE5NC4yNDU2Ij4KCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQkZDRkQiLz4KCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMkY0RjciLz4KCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJPHBhdGggaWQ9IkZpbGwtMSIgY2xhc3M9InN0MCIgZD0iTTE5My4xLDE3NC4yYzE0LjgtMy4zLDM2LTQuOCw1MC41LTQuMWMxNC40LDAuNywyNi40LDMuMywyNy4zLDIuN2MyLjktMS45LDktMi44LDguNy0yCgkJCQljLTAuMywwLjctNC4zLDMuMS0zLDMuNGMxLjMsMC40LDE0LjEsMS45LDE5LjUsM2M1LjMsMS4xLDguOCwyLjIsOS45LDIuMmMxLjIsMCwzLTEuNiwxMC43LTAuOGMwLjEsMC4zLTEuNywwLjQtMy40LDEuMwoJCQkJYy0xLjcsMC45LTMsMC44LTMsMXMxLTAuMywzLDFzNS41LDEuNyw1LjUsMnMtNC41LDEuOC0xMi0wLjZjLTEuOS0wLjYtNi4zLDQuNi0yNi44LDYuMXMtNTUsMi42LTU1LDIuNnMyLjEsMi43LDUuMSwzLjQKCQkJCWMwLjIsMC4zLTEuMiwxLjMtNy4xLDAuMmMtNS45LTEuMS05LTMuNi05LTMuNnMtMTEuNi0wLjctMTYtMS41Yy00LjQtMC43LTkuNC0yLjYtMTIuOS0zcy0xOS4yLTIuMi0xMy4yLTYuMwoJCQkJQzE3MiwxODEuMiwxNzguMywxNzcuNSwxOTMuMSwxNzQuMnoiLz4KCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiCIgY2xhc3M9InN0MSIgZD0iTTE5My4xLDE3Ny40djkuNGg5LjR2MS45aC0xMS4ydi0xMS4yTDE5My4xLDE3Ny40TDE5My4xLDE3Ny40eiIvPgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9IiBjbGFzcz0ic3QxIiBkPSJNMjAwLjYsNjQuOWgtOS40djkuNGgtMS45di05LjRsMCwwVjYzaDExLjJMMjAwLjYsNjQuOUwyMDAuNiw2NC45eiIvPgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9LTIiIGNsYXNzPSJzdDEiIGQ9Ik0yODguOCw3NC4ydi05LjRoLTkuNFY2M2g5LjRsMCwwaDEuOXYxMS4ySDI4OC44eiIvPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iLTJfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDExLjY3NjgiIHkxPSItMS42MDY2IiB4Mj0iNDExLjY3NjgiIHkyPSItMC42NzA3IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDg2LjI1IDAgMCAxMDguNzUgLTM1MjY3LjEyNSAyNDYuNSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VCRURGMDtzdG9wLW9wYWNpdHk6MC45OTE3Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTFFM0U2Ii8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLnn6nlvaItMiIgY2xhc3M9InN0MiIgZD0iTTE5Ny45LDcwLjVoODQuMmMwLjYsMCwxLDAuNCwxLDF2MTA2LjhjMCwwLjYtMC40LDEtMSwxaC04NC4yYy0wLjYsMC0xLTAuNC0xLTFWNzEuNQoJCQkJQzE5Ni45LDcwLjksMTk3LjMsNzAuNSwxOTcuOSw3MC41eiIvPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzZfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjQxMC42NjE0IiB5MT0iLTEuODc3MyIgeDI9IjQxMC42NjE0IiB5Mj0iLTAuODg4OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg3MS4yNSAwIDAgOTMuNzUgLTI5MDE5LjYyNSAyNTQpIj4KCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGRkZGRkYiLz4KCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMkY0RjciLz4KCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJPHJlY3QgaWQ9IuefqeW9ol8xXyIgeD0iMjA0LjQiIHk9Ijc4IiBjbGFzcz0ic3QzIiB3aWR0aD0iNzEuMiIgaGVpZ2h0PSI5My44Ii8+CgkJCTxyZWN0IGlkPSLnn6nlvaJfMl8iIHg9IjIxOS40IiB5PSI4MS44IiBjbGFzcz0ic3Q0IiB3aWR0aD0iNDEuMiIgaGVpZ2h0PSIxLjkiLz4KCQkJPHJlY3QgaWQ9IuefqeW9ol8zXyIgeD0iMjA0LjQiIHk9IjE3MS44IiBjbGFzcz0ic3Q1IiB3aWR0aD0iNzEuMiIgaGVpZ2h0PSIxLjkiLz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9oi0zXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjQwNi40MTUyIiB5MT0iLTExLjczMzQiIHgyPSI0MDYuNDE1MiIgeTI9Ii0xMC43NDEzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQxLjI1IDAgMCAxNSAtMTY1MjQuNjI1IDI0Mi43NSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VERUZGMiIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U4RUFFRCIvPgoJCQk8L2xpbmVhckdyYWRpZW50PgoJCQk8cmVjdCBpZD0i55+p5b2iLTMiIHg9IjIxOS40IiB5PSI2Ni44IiBjbGFzcz0ic3Q2IiB3aWR0aD0iNDEuMiIgaGVpZ2h0PSIxNSIvPgoJCQk8ZyBpZD0i57yW57uELTMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIyMy4xMjUwMDAsIDk4LjYyNTAwMCkiPgoJCQkJPHJlY3QgaWQ9IuefqeW9ol80XyIgY2xhc3M9InN0MSIgd2lkdGg9IjMuOCIgaGVpZ2h0PSIxLjkiLz4KCQkJCTxyZWN0IGlkPSLnn6nlvaLlpIfku70iIHg9IjcuNSIgY2xhc3M9InN0MSIgd2lkdGg9IjMuOCIgaGVpZ2h0PSIxLjkiLz4KCQkJCTxyZWN0IGlkPSLnn6nlvaLlpIfku70tMiIgeD0iMTUiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMS45Ii8+CgkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTMiIHg9IjIyLjUiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMS45Ii8+CgkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTQiIHg9IjMwIiBjbGFzcz0ic3QxIiB3aWR0aD0iMy44IiBoZWlnaHQ9IjEuOSIvPgoJCQk8L2c+CgkJCTxnIGlkPSLnvJbnu4QtNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjI4Ljc1MDAwMCwgMTEzLjYyNTAwMCkiPgoJCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iIiBjbGFzcz0ic3Q3IiBjeD0iMjQuNCIgY3k9IjI2LjIiIHI9IjI0LjQiLz4KCQkJCTxwYXRoIGlkPSLot6/lvoQtMTIiIGNsYXNzPSJzdDciIGQ9Ik0zOSw0NWwzLjEsMy4yYy0wLjYsMC44LTAuNiwxLjUsMCwyLjJzMi4yLDIuNSw0LjcsNS4zdi03LjVsLTYuMS01TDM5LDQ1eiIvPgoKCQkJCQk8ZyBpZD0i57yW57uELTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwLjIyNjMxNywgNTEuNzA5MDc3KSByb3RhdGUoLTQ1LjAwMDAwMCkgdHJhbnNsYXRlKC01MC4yMjYzMTcsIC01MS43MDkwNzcpIHRyYW5zbGF0ZSg0NC42MDEzMTcsIDM2LjcwOTA3NykiPgoKCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol81XyIgeD0iMy44IiB5PSIwIiB0cmFuc2Zvcm09Im1hdHJpeCgtMSA1LjA3MDM2M2UtMDYgLTUuMDcwMzYzZS0wNiAtMSAxMS40IDkuMzUpIiBjbGFzcz0ic3Q4IiB3aWR0aD0iMy43IiBoZWlnaHQ9IjkuNCIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLot6/lvoQtMTNfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTEwOS4zOTE1IiB5MT0iLTU1LjkzODMiIHgyPSItMTA5LjU1NzgiIHkyPSItNTUuODkwNSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg5LjIxMjkgMCAwIDIyLjUgMTAxMy45Mjg1IDEyNzcuMjgxKSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNEN0Q4REIiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0JFQkZDMiIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHBhdGggaWQ9Iui3r+W+hC0xMyIgY2xhc3M9InN0OSIgZD0iTTMuNyw1LjdoNGMwLjUsMCwxLDAuNCwxLDAuOWwxLjUsMjAuNWMwLDAuNi0wLjQsMS0wLjksMS4xYzAsMCwwLDAtMC4xLDBIMgoJCQkJCQljLTAuNiwwLTEtMC40LTEtMXYtMC4xTDIuNyw2LjZDMi43LDYuMSwzLjIsNS43LDMuNyw1Ljd6Ii8+CgkJCQk8L2c+CgkJCQk8ZyBpZD0i57yW57uELTUiPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaJfM18iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTQ5LjcxMTUiIHkxPSItMy42ODU5IiB4Mj0iLTQ5LjcxMTUiIHkyPSItMi42ODU5IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQ3Ljc1IDAgMCA0Ny43NSAyMzk4LjEyNSAxNzYuNSkiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxLjUzMDgyOGUtMDMiIHN0eWxlPSJzdG9wLWNvbG9yOiNERERFRTAiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMC45OTgiIHN0eWxlPSJzdG9wLWNvbG9yOiNDM0M1QzciLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaJfNF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTQ5LjcxMTUiIHkxPSItMy42ODU4IiB4Mj0iLTQ5LjcxMTUiIHkyPSItMi43MDU0IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQ3Ljc1IDAgMCA0Ny43NSAyMzk4LjEyNSAxNzYuNSkiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRERERUUwIi8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCRUMwQzIiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol8xXyIgY2xhc3M9InN0MTAiIGN4PSIyNC40IiBjeT0iMjQuNCIgcj0iMjMuOSIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaJfNV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTUyLjM5NjYiIHkxPSItNC44MjIiIHgyPSItNTIuMzk2NiIgeTI9Ii0zLjgzOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgzNi41IDAgMCAzNi41IDE5MzYuODc1IDE4Mi4xMjUpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZFRkVGRSIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjJGNEY3Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5qSt5ZyG5b2iXzZfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9Ii01Mi4zOTY2IiB5MT0iLTQuODIyIiB4Mj0iLTUyLjM5NjYiIHkyPSItMy44Mzk4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDM2LjUgMCAwIDM2LjUgMTkzNi44NzUgMTgyLjEyNSkiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjNGNEY1Ii8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGM0Y1RjciLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol8yXyIgY2xhc3M9InN0MTEiIGN4PSIyNC40IiBjeT0iMjQuNCIgcj0iMTguMiIvPgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDEyIiBkPSJNMjMuNSwxMi4zYzUuOCwwLDEwLjksMy4zLDEzLjQsOC4yYy0yLjUtMS42LTUuNS0yLjYtOC43LTIuNmMtNCwwLTcuNywxLjUtMTAuNSw0CgkJCQkJCUwxNCwxNS43QzE2LjYsMTMuNiwxOS45LDEyLjMsMjMuNSwxMi4zeiIvPgoJCQkJPC9nPgoJCQkJPHBvbHlnb24gaWQ9Iui3r+W+hC0xNCIgY2xhc3M9InN0NSIgcG9pbnRzPSI0Ni45LDUzLjQgNDYuOSw1NS42IDU0LjQsNjQuNCA1NC40LDYyLjMgCQkJCSIvPgoJCQk8L2c+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=";
let ExceptionEnum;
(function(ExceptionEnum2) {
  ExceptionEnum2["CODE_404"] = "404";
  ExceptionEnum2["CODE_403"] = "403";
  ExceptionEnum2["CODE_500"] = "500";
  ExceptionEnum2["BUILDING"] = "building";
  ExceptionEnum2["EMPTY"] = "empty";
  ExceptionEnum2["SEARCH"] = "search-empty";
  ExceptionEnum2["LOGIN"] = "login";
})(ExceptionEnum || (ExceptionEnum = {}));
let SceneEnum;
(function(SceneEnum2) {
  SceneEnum2["PAGE"] = "page";
  SceneEnum2["PART"] = "part";
})(SceneEnum || (SceneEnum = {}));
var Exception = defineComponent({
  name: "Exception",
  props: {
    type: j("type", {}).def(ExceptionEnum.CODE_404),
    scene: j("scene", {}).def(SceneEnum.PAGE),
    title: PropTypes.string,
    description: PropTypes.string
  },
  setup(props2, {
    slots
  }) {
    const images = {
      403: permissions,
      404: notFound,
      500: maintain,
      building: Building,
      empty,
      "search-empty": searchEmpty,
      login
    };
    const renderImg = () => {
      if (_$1.isFunction(slots.type)) {
        return createVNode("div", {
          "class": "lesscode-bk-exception-img"
        }, [slots.type()]);
      }
      const imgSrc = images[props2.type] ? images[props2.type] : empty;
      return createVNode("div", {
        "class": "lesscode-bk-exception-img"
      }, [createVNode("img", {
        "class": "exception-image",
        "src": imgSrc,
        "alt": "type"
      }, null)]);
    };
    const renderTitle = () => {
      if (_$1.isFunction(slots.title)) {
        return createVNode("div", {
          "class": "lesscode-bk-exception-title"
        }, [slots.title()]);
      }
      if (props2.title) {
        return createVNode("div", {
          "class": "lesscode-bk-exception-title"
        }, [props2.title]);
      }
      return null;
    };
    const renderDescription = () => {
      if (_$1.isFunction(slots.description)) {
        return createVNode("div", {
          "class": "lesscode-bk-exception-description"
        }, [slots.description()]);
      }
      if (props2.description) {
        return createVNode("div", {
          "class": "lesscode-bk-exception-description"
        }, [props2.description]);
      }
      return null;
    };
    const renderFooter = () => {
      if (_$1.isFunction(slots.default)) {
        return createVNode("div", {
          "class": "lesscode-bk-exception-footer"
        }, [slots.default()]);
      }
      return null;
    };
    return () => {
      const rootClass = classes({
        "lesscode-bk-exception": true,
        [`lesscode-bk-exception-${props2.scene}`]: true
      });
      return createVNode("div", {
        "class": rootClass
      }, [renderImg(), renderTitle(), renderDescription(), renderFooter()]);
    };
  }
});
const BkException = withInstall(Exception);
var Component$t = defineComponent({
  name: "FixedNavbar",
  props: {
    navItems: PropTypes.array.def([]),
    extCls: PropTypes.string.def(""),
    position: PropTypes.oneOf(["middle", "top", "bottom"]).def("middle"),
    modelValue: PropTypes.bool.def(true)
  },
  emits: ["update:modelValue", "click"],
  setup(props2, {
    emit
  }) {
    const navConfig = props2.navItems.map((item) => Object.assign({
      tooltip: {
        disabled: true
      },
      action: () => {
      },
      icon: "",
      text: ""
    }, item));
    const zIndex = bkZIndexManager.getModalNextIndex();
    const handleClick = (item) => {
      emit("click", item);
      item.action();
    };
    return () => props2.modelValue && createVNode("div", {
      "class": `lesscode-bk-fixed-navbar ${props2.extCls} ${props2.position}`,
      "style": {
        zIndex
      }
    }, [navConfig.map((item) => createVNode("div", {
      "class": "fixed-navbar-item",
      "onClick": handleClick.bind(this, item)
    }, [item.icon ? createVNode("i", {
      "class": `${item.icon} icon`
    }, null) : "", item.text ? createVNode("span", {
      "class": "text"
    }, [item.text]) : ""]))]);
  }
});
const BkFixedNavbar = withInstall(Component$t);
var LinkThemeEnum;
(function(LinkThemeEnum2) {
  LinkThemeEnum2["DANGER"] = "danger";
  LinkThemeEnum2["SUCCESS"] = "success";
  LinkThemeEnum2["PRIMARY"] = "primary";
  LinkThemeEnum2["WARNING"] = "warning";
  LinkThemeEnum2["DEFAULT"] = "default";
})(LinkThemeEnum || (LinkThemeEnum = {}));
var Component$s = defineComponent({
  name: "Link",
  props: {
    theme: j("linkTheme", {}).def(LinkThemeEnum.DEFAULT),
    href: PropTypes.string.def(""),
    disabled: PropTypes.bool.def(false),
    underline: PropTypes.bool.def(false),
    target: PropTypes.string.def("_self")
  },
  emits: ["click"],
  setup(props2, {
    emit
  }) {
    const handleClick = (event) => {
      if (props2.disabled) {
        event.preventDefault();
        return false;
      }
      emit("click", event);
    };
    return {
      handleClick
    };
  },
  render() {
    var _a, _b;
    const linkClass = classes({
      "is-disabled": this.disabled,
      "has-underline": this.underline
    }, `${this.theme} lesscode-bk-link`);
    return createVNode("a", {
      "href": this.href,
      "target": this.target,
      "class": linkClass,
      "onClick": this.handleClick
    }, [createVNode("span", null, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)])]);
  }
});
const BkLink = withInstall(Component$s);
const isElement$2 = (e) => {
  if (typeof Element === "undefined")
    return false;
  return e instanceof Element;
};
const nodeList$1 = /* @__PURE__ */ new Map();
let startClick;
document.addEventListener("mousedown", (e) => startClick = e);
document.addEventListener("mouseup", (e) => {
  for (const handlers of nodeList$1.values()) {
    for (const { documentHandler } of handlers) {
      documentHandler(e, startClick);
    }
  }
});
function createDocumentHandler(el, binding) {
  let excludes = [];
  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else if (isElement$2(binding.arg)) {
    excludes.push(binding.arg);
  }
  return function(mouseup, mousedown) {
    const { popperRef } = binding.instance;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    const isSelf = el === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }
    binding.value(mouseup, mousedown);
  };
}
const ClickOutside = {
  beforeMount(el, binding) {
    if (!nodeList$1.has(el)) {
      nodeList$1.set(el, []);
    }
    nodeList$1.get(el).push({
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  updated(el, binding) {
    if (!nodeList$1.has(el)) {
      nodeList$1.set(el, []);
    }
    const handlers = nodeList$1.get(el);
    const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
    const newHandler = {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    };
    if (oldHandlerIndex >= 0) {
      handlers.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers.push(newHandler);
    }
  },
  unmounted(el) {
    nodeList$1.delete(el);
  }
};
ClickOutside.install = (app) => {
  app.directive("bkTooltips", ClickOutside);
};
var Arrow = defineComponent({
  name: "PopArrow",
  render() {
    const arrowClassName = resolveClassName("pop2-arrow");
    return createVNode("div", {
      "class": arrowClassName
    }, null);
  }
});
const EMPTY$2 = (..._args) => true;
let EMIT_EVENTS$1;
(function(EMIT_EVENTS2) {
  EMIT_EVENTS2["SHOW"] = "show";
  EMIT_EVENTS2["HIDE"] = "hide";
  EMIT_EVENTS2["CLICK_OUTSIDE"] = "clickoutside";
  EMIT_EVENTS2["CONTENT_MOUSEENTER"] = "contentMouseenter";
  EMIT_EVENTS2["CONTENT_MOUSELEAVE"] = "contentMouseleave";
  EMIT_EVENTS2["STOP_HIDE"] = "stopHide";
})(EMIT_EVENTS$1 || (EMIT_EVENTS$1 = {}));
const EMIT_EVENT_TYPES$1 = {
  [EMIT_EVENTS$1.SHOW]: EMPTY$2,
  [EMIT_EVENTS$1.HIDE]: EMPTY$2,
  [EMIT_EVENTS$1.CLICK_OUTSIDE]: EMPTY$2,
  [EMIT_EVENTS$1.CONTENT_MOUSEENTER]: EMPTY$2,
  [EMIT_EVENTS$1.CONTENT_MOUSELEAVE]: EMPTY$2,
  [EMIT_EVENTS$1.STOP_HIDE]: EMPTY$2
};
var Content = defineComponent({
  name: "PopContent",
  props: {
    width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).def("auto"),
    height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).def("auto"),
    maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).def("auto"),
    extCls: PropTypes.string.def("")
  },
  setup(props2) {
    const resolveValToPix = (val) => {
      if (/^\d+\.?\d*$/.test(`${val}`)) {
        return `${val}px`;
      }
      return val;
    };
    const style2 = computed(() => ({
      width: resolveValToPix(props2.width),
      height: resolveValToPix(props2.height),
      maxHeight: resolveValToPix(props2.maxHeight)
    }));
    return {
      style: style2
    };
  },
  render() {
    var _a, _b, _c, _d, _e, _f;
    const className = [resolveClassName("popover"), resolveClassName("pop2-content"), this.extCls];
    return createVNode("div", {
      "class": className,
      "tabindex": "-1",
      "style": this.style
    }, [(_c = (_b = (_a = this.$slots).arrow) == null ? void 0 : _b.call(_a)) != null ? _c : "", (_f = (_e = (_d = this.$slots).default) == null ? void 0 : _e.call(_d)) != null ? _f : ""]);
  }
});
const EventProps$1 = {
  onAfterHidden: Function,
  onAfterShow: Function
};
const PopoverProps = __spreadValues({
  isShow: PropTypes.bool.def(false),
  always: PropTypes.bool.def(false),
  disabled: PropTypes.bool.def(false),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).def("auto"),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).def("auto"),
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).def("auto"),
  content: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.any]).def(""),
  allowHtml: PropTypes.bool.def(false),
  placement: placementType$1().def(PlacementEnum.TOP_START),
  theme: PropTypes.string.def("dark"),
  trigger: triggerType$1(),
  renderType: renderType(),
  arrow: PropTypes.bool.def(true),
  padding: PropTypes.number.def(5),
  offset: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({})]).def(6),
  boundary: PropTypes.oneOfType([PropTypes.string.def("parent"), PropTypes.instanceOf(HTMLElement)]),
  zIndex: PropTypes.number.def(void 0),
  disableTeleport: PropTypes.bool.def(false),
  autoPlacement: PropTypes.bool.def(false),
  autoVisibility: PropTypes.bool.def(true),
  disableOutsideClick: PropTypes.bool.def(false),
  disableTransform: PropTypes.bool.def(false),
  reference: PropTypes.any.def(null),
  modifiers: PropTypes.array.def([]),
  popoverDelay: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]).def(100),
  extCls: PropTypes.string.def("")
}, EventProps$1);
var Reference = defineComponent({
  name: "PopReference",
  render() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)) != null ? _c : "";
  }
});
var Root = defineComponent({
  props: {
    class: PropTypes.string.def("")
  },
  render() {
    var _a, _b;
    return createVNode(Fragment, null, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)]);
  }
});
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference: reference2,
    floating
  } = _ref;
  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference2[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference2.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case "right":
      coords = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference2.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference2.x,
        y: reference2.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference2, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference: reference2,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  for (let i2 = 0; i2 < middleware.length; i2++) {
    const {
      name,
      fn: fn2
    } = middleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference2,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data2)
    });
    if (reset2) {
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference: reference2,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return __spreadProps(__spreadValues({}, rect), {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? __spreadProps(__spreadValues({}, rects.floating), {
      x: x2,
      y: y2
    }) : rects.reference,
    offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]);
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$1 = Math.min;
const max$1 = Math.max;
function within(min$1$1, value, max$1$1) {
  return max$1(min$1$1, min$1(value, max$1$1));
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getMainAxisFromPlacement(placement);
    const alignment = getAlignment(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    if (clientSize === 0) {
      clientSize = rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min2, center, max2);
    const alignmentPadding = alignment === "start" ? paddingObject[minProp] : paddingObject[maxProp];
    const shouldAddOffset = alignmentPadding > 0 && center !== offset2 && rects.reference[length] <= rects.floating[length];
    const alignmentOffset = shouldAddOffset ? center < min2 ? min2 - center : max2 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
const hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
const sides = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;
      const {
        x: x2,
        y: y2,
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const _a = options, {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "alignment",
        "allowedPlacements",
        "autoAlignment"
      ]);
      const placements2 = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow2 = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;
      const currentPlacement = placements2[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const {
        main: main2,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          x: x2,
          y: y2,
          reset: {
            placement: placements2[0]
          }
        };
      }
      const currentOverflows = [overflow2[getSide(currentPlacement)], overflow2[main2], overflow2[cross]];
      const allOverflows = [...(_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements2[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a2, b2) => a2.overflows[0] - b2.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow3) => overflow3 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = middlewareArguments;
      const _a = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "fallbackPlacements",
        "fallbackStrategy",
        "flipAlignment"
      ]);
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow2 = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow2[side]);
      }
      if (checkCrossAxis) {
        const {
          main: main2,
          cross
        } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
        overflows.push(overflow2[main2], overflow2[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$map$so;
            const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2, d2.overflows.filter((overflow3) => overflow3 > 0).reduce((acc, overflow3) => acc + overflow3, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow2, rect) {
  return {
    top: overflow2.top - rect.height,
    right: overflow2.right - rect.width,
    bottom: overflow2.bottom - rect.height,
    left: overflow2.left - rect.width
  };
}
function isAnySideFullyClipped(overflow2) {
  return sides.some((side) => overflow2[side] >= 0);
}
const hide$1 = function(_temp) {
  let _a = _temp === void 0 ? {} : _temp, {
    strategy = "referenceHidden"
  } = _a, detectOverflowOptions = __objRest(_a, [
    "strategy"
  ]);
  return {
    name: "hide",
    async fn(middlewareArguments) {
      const {
        rects
      } = middlewareArguments;
      switch (strategy) {
        case "referenceHidden": {
          const overflow2 = await detectOverflow(middlewareArguments, __spreadProps(__spreadValues({}, detectOverflowOptions), {
            elementContext: "reference"
          }));
          const offsets = getSideOffsets(overflow2, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow2 = await detectOverflow(middlewareArguments, __spreadProps(__spreadValues({}, detectOverflowOptions), {
            altBoundary: true
          }));
          const offsets = getSideOffsets(overflow2, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(middlewareArguments, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = middlewareArguments;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(middlewareArguments) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : __spreadValues({
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null
  }, rawValue);
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2
      } = middlewareArguments;
      const diffCoords = await convertValueToCoords(middlewareArguments, value);
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement
      } = middlewareArguments;
      const _a = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        }
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "limiter"
      ]);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow2 = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow2[minSide];
        const max2 = mainAxisCoord - overflow2[maxSide];
        mainAxisCoord = within(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow2[minSide];
        const max2 = crossAxisCoord - overflow2[maxSide];
        crossAxisCoord = within(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, middlewareArguments), {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return __spreadProps(__spreadValues({}, limitedCoords), {
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      });
    }
  };
};
const inline = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(middlewareArguments) {
      var _await$platform$getCl;
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = middlewareArguments;
      const {
        padding = 2,
        x: x2,
        y: y2
      } = options;
      const fallback = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: rects.reference,
        offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
        strategy
      }) : rects.reference);
      const clientRects = (_await$platform$getCl = await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];
      const paddingObject = getSideObjectFromPadding(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null) {
          var _clientRects$find;
          return (_clientRects$find = clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;
        }
        if (clientRects.length >= 2) {
          if (getMainAxisFromPlacement(placement) === "x") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === "top";
            const top3 = firstRect.top;
            const bottom3 = lastRect.bottom;
            const left3 = isTop ? firstRect.left : lastRect.left;
            const right3 = isTop ? firstRect.right : lastRect.right;
            const width2 = right3 - left3;
            const height2 = bottom3 - top3;
            return {
              top: top3,
              bottom: bottom3,
              left: left3,
              right: right3,
              width: width2,
              height: height2,
              x: left3,
              y: top3
            };
          }
          const isLeftSide = getSide(placement) === "left";
          const maxRight = max$1(...clientRects.map((rect) => rect.right));
          const minLeft = min$1(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top2 = measureRects[0].top;
          const bottom2 = measureRects[measureRects.length - 1].bottom;
          const left2 = minLeft;
          const right2 = maxRight;
          const width = right2 - left2;
          const height = bottom2 - top2;
          return {
            top: top2,
            bottom: bottom2,
            left: left2,
            right: right2,
            width,
            height,
            x: left2,
            y: top2
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function getUAString() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
  }
  return navigator.userAgent;
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement$1(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow: overflow2,
    overflowX,
    overflowY
  } = getComputedStyle$1$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow2 + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox2 = /firefox/i.test(getUAString());
  const css = getComputedStyle$1$1(element);
  return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox2 && css.willChange === "filter" || isFirefox2 && (css.filter ? css.filter !== "none" : false);
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  const win = isElement$1(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x2 = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y2 = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent), strategy === "fixed");
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }
  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return __spreadProps(__spreadValues({}, rect), {
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  });
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1$1(body || html2).direction === "rtl") {
    x2 += max(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (["html", "body", "#document"].includes(getNodeName(parentNode))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));
}
function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
  const top2 = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  return {
    top: top2,
    left: left2,
    x: left2,
    y: top2,
    right: left2 + element.clientWidth,
    bottom: top2 + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element, strategy));
  }
  if (isElement$1(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingAncestors.filter((clippingAncestors2) => isElement$1(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement: isElement$1,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: (_ref) => {
    let {
      reference: reference2,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference2, getOffsetParent(floating), strategy),
      floating: __spreadProps(__spreadValues({}, getDimensions(floating)), {
        x: 0,
        y: 0
      })
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1$1(element).direction === "rtl"
};
function autoUpdate(reference2, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement$1(reference2) ? getOverflowAncestors(reference2) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    observer = new ResizeObserver(update);
    isElement$1(reference2) && !animationFrame && observer.observe(reference2);
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference2) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference2);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  if (!elementResize) {
    update();
  }
  return () => {
    var _observer;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const computePosition = (reference2, floating, options) => computePosition$1(reference2, floating, __spreadValues({
  platform
}, options));
var usePlatform = (fullscreenTarget) => {
  const getElementRects = ({
    reference: reference2,
    floating
  }) => {
    const refRect = reference2.getBoundingClientRect();
    const floatRect = floating.getBoundingClientRect();
    return {
      reference: {
        width: refRect.width,
        height: refRect.height,
        x: refRect.x,
        y: refRect.y
      },
      floating: {
        width: floatRect.width,
        height: floatRect.height,
        x: floatRect.x,
        y: floatRect.y
      }
    };
  };
  const getDimensions2 = (element) => {
    const {
      width,
      height
    } = element.getBoundingClientRect();
    return {
      width,
      height
    };
  };
  const getClippingRect2 = ({}) => {
    var _a;
    const {
      width = 0,
      height = 0
    } = (_a = fullscreenTarget == null ? void 0 : fullscreenTarget.getBoundingClientRect()) != null ? _a : {};
    return {
      width,
      height,
      x: 0,
      y: 0
    };
  };
  return {
    getElementRects,
    getDimensions: getDimensions2,
    getClippingRect: getClippingRect2
  };
};
const CachedConst = {};
const isAvailableId = (query) => {
  const container2 = document.querySelector(query);
  return container2 instanceof HTMLElement;
};
const getFullscreenUid = () => {
  if (!CachedConst.fullscreenReferId) {
    CachedConst.fullscreenReferId = `id_${uuid_1.v4()}`;
  }
  return CachedConst.fullscreenReferId;
};
const isElement = (element) => element instanceof Element || element instanceof HTMLDocument;
const contentAsHTMLElement = (content) => {
  if (isElement(content)) {
    return {
      isElement: true,
      content,
      vNode: void 0
    };
  }
  if (/^(#|\.)/.test(content)) {
    const target = document.querySelector(content);
    const isEle = isElement(target);
    return {
      isElement: isEle,
      content: isEle ? target : content,
      vNode: isEle ? void 0 : content
    };
  }
  return {
    isElement: false,
    content,
    vNode: content
  };
};
var useFloating = (props2, ctx, {
  refReference,
  refContent,
  refArrow,
  refRoot
}) => {
  const localIsShow = ref(false);
  const fullScreenTarget = ref();
  const isElementFullScreen = () => {
    var _a, _b, _c;
    const elReference = resolveTargetElement((_a = refReference.value) == null ? void 0 : _a.$el);
    if ((_b = document.fullscreenElement) == null ? void 0 : _b.shadowRoot) {
      return document.fullscreenElement.shadowRoot.contains(elReference);
    }
    return (_c = document.fullscreenElement) == null ? void 0 : _c.contains(elReference);
  };
  const getFullscreenRoot = (selector) => {
    if (isElementFullScreen()) {
      if (document.fullscreenElement.shadowRoot) {
        return document.fullscreenElement.shadowRoot.querySelector(selector);
      }
      return document.fullscreenElement.querySelector(selector);
    }
    return document.body;
  };
  const themeList = ["dark", "light"];
  const compTheme = computed(() => {
    var _a, _b;
    const themes2 = (_b = (_a = props2.theme) == null ? void 0 : _a.split(/\s+/)) != null ? _b : [];
    themes2.sort((a2, b2) => Number(themeList.includes(b2)) - Number(themeList.includes(a2)));
    const systemThemes = themes2;
    const customThemes = themes2.filter((item) => !themeList.includes(item));
    return {
      systemThemes,
      customThemes
    };
  });
  const isHideMiddlewareAvailable = () => props2.autoVisibility;
  const isAutoPlacementAvailable = () => props2.autoPlacement;
  const resolvePopElements = () => {
    var _a, _b, _c, _d;
    const elReference = resolveTargetElement((_a = refReference.value) == null ? void 0 : _a.$el);
    const elContent = resolveTargetElement((_b = refContent.value) == null ? void 0 : _b.$el);
    const elArrow = props2.arrow ? resolveTargetElement((_c = refArrow.value) == null ? void 0 : _c.$el) : null;
    const root = resolveTargetElement((_d = refRoot.value) == null ? void 0 : _d.$el);
    const {
      isElement: isElement2,
      content
    } = contentAsHTMLElement(props2.content);
    if (elContent && isElement2 && !(elContent == null ? void 0 : elContent.contains(content))) {
      elContent.append(content);
    }
    return {
      elReference,
      elContent,
      elArrow,
      root
    };
  };
  const resolveModifiers = () => {
    const resolveResult = {};
    if (Array.isArray(props2.modifiers)) {
      props2.modifiers.forEach((m2) => {
        var _a, _b, _c, _d;
        let result;
        if (m2.name === "offset") {
          if (typeof ((_a = m2.options) == null ? void 0 : _a.offset) === "number") {
            result = (_b = m2.options) == null ? void 0 : _b.offset;
          }
          if (Array.isArray((_c = m2.options) == null ? void 0 : _c.offset)) {
            const [mainAxis, crossAxis] = (_d = m2.options) == null ? void 0 : _d.offset;
            result = {
              mainAxis,
              crossAxis
            };
          }
          Object.assign(resolveResult, {
            offset: result
          });
        }
      });
    }
    return resolveResult;
  };
  const resolvePopOptions = (elArrow, props3) => {
    var _a;
    const modifiers = resolveModifiers();
    const middleware = [offset(modifiers.offset || props3.offset), shift({
      padding: props3.padding
    })];
    const options = {
      placement: props3.placement,
      middleware
    };
    if (props3.arrow) {
      middleware.push(arrow({
        element: elArrow
      }));
    }
    if (isAutoPlacementAvailable()) {
      middleware.push(autoPlacement());
    } else {
      middleware.unshift(inline());
      middleware.push(flip());
    }
    if (isHideMiddlewareAvailable()) {
      options.middleware.push(hide$1());
    }
    if (isElementFullScreen() || props3.isVirtualEl) {
      const {
        getElementRects,
        getDimensions: getDimensions2,
        getClippingRect: getClippingRect2
      } = usePlatform(fullScreenTarget.value);
      Object.assign(options, {
        platform: __spreadProps(__spreadValues({}, (_a = props3 == null ? void 0 : props3.platform) != null ? _a : {}), {
          getElementRects,
          getDimensions: getDimensions2,
          getClippingRect: getClippingRect2
        })
      });
    }
    return options;
  };
  const resolveTargetElement = (target) => {
    if (target instanceof HTMLElement) {
      return target;
    }
    if (target instanceof Text) {
      return resolveTargetElement(target.nextElementSibling);
    }
    if (typeof (target == null ? void 0 : target.getBoundingClientRect) === "function") {
      return target;
    }
    return null;
  };
  const customThemeCls = compTheme.value.customThemes.join(" ");
  const customTheme = compTheme.value.customThemes.reduce((out, cur) => __spreadValues({
    [`data-${cur}-theme`]: true
  }, out), {});
  const contentClass = `${customThemeCls}`;
  let cleanup = null;
  const getRoundPixelVal = (val) => {
    const dpr = window.devicePixelRatio || 1;
    return Math.round(val * dpr) / dpr || 0;
  };
  const updatePopContentStyle = (elContent, x2, y2, middlewareData) => {
    var _a;
    if (props2.disableTransform) {
      Object.assign(elContent.style, {
        left: `${getRoundPixelVal(x2)}px`,
        top: `${getRoundPixelVal(y2)}px`
      });
    } else {
      Object.assign(elContent.style, {
        left: "0",
        top: "0",
        transform: `translate3d(${getRoundPixelVal(x2)}px,${getRoundPixelVal(y2)}px,0)`
      });
    }
    const referenceHidden = isHideMiddlewareAvailable() ? (_a = middlewareData.hide) == null ? void 0 : _a.referenceHidden : false;
    Object.assign(elContent.style, {
      visibility: referenceHidden ? "hidden" : "visible"
    });
  };
  const updateArrowStyle = (elArrow, resolvedPlacement, middlewareData) => {
    var _a;
    if (props2.arrow) {
      const {
        x: arrowX,
        y: arrowY
      } = (_a = middlewareData.arrow) != null ? _a : {};
      elArrow.setAttribute("data-arrow", resolvedPlacement);
      const arrowConfig = {
        left: "",
        top: "",
        bottom: "",
        right: ""
      };
      Object.assign(elArrow.style, arrowConfig);
      const arrowSide = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
      }[resolvedPlacement];
      Object.assign(elArrow.style, {
        left: arrowX !== null ? `${arrowX}px` : "",
        top: arrowY !== null ? `${arrowY}px` : "",
        [arrowSide]: "-4px"
      });
    }
  };
  const createPopInstance = () => {
    const {
      elReference,
      elContent
    } = resolvePopElements();
    cleanup = autoUpdate(elReference, elContent, () => {
      if (localIsShow.value) {
        updatePopover(null, props2);
      }
    });
  };
  const updatePopover = (virtualEl = null, props3 = {}) => {
    const {
      elReference,
      elContent,
      elArrow
    } = resolvePopElements();
    const targetEl = virtualEl || elReference;
    if (!targetEl || !elContent)
      return;
    const options = resolvePopOptions(elArrow, props3);
    computePosition(targetEl, elContent, options).then(({
      x: x2,
      y: y2,
      placement,
      middlewareData
    }) => {
      const oldClass = elContent.className;
      elContent.className = `${oldClass.replace(contentClass, "")} ${contentClass}`.replace(/\s+/mg, " ").replace(/^\s+|\s+$/g, "");
      Object.keys(customTheme).forEach((key2) => {
        elContent.setAttribute(key2, customTheme[key2]);
      });
      const placementStr = placement.split("-")[0];
      let resolvedPlacement = placementStr;
      if (!["left", "right", "top", "bottom"].includes(placementStr)) {
        resolvedPlacement = "top";
      }
      updatePopContentStyle(elContent, x2, y2, middlewareData);
      updateArrowStyle(elArrow, resolvedPlacement, middlewareData);
    });
  };
  let popHideTimerId = void 0;
  let popShowTimerId = void 0;
  let isMouseenter = false;
  const resolvePopoverDelay = () => {
    if (Array.isArray(props2.popoverDelay)) {
      return [props2.popoverDelay[0], props2.popoverDelay.slice(-1)[0]];
    }
    return [props2.popoverDelay, props2.popoverDelay];
  };
  const showPopover = () => {
    const delay = resolvePopoverDelay()[0];
    popShowTimerId = setTimeout(() => {
      if (popHideTimerId) {
        clearTimeout(popHideTimerId);
      }
      if (!props2.disabled) {
        localIsShow.value = true;
      }
    }, delay);
  };
  const hidePopover = () => {
    const delay = resolvePopoverDelay()[1];
    popHideTimerId = setTimeout(() => {
      popShowTimerId && clearTimeout(popShowTimerId);
      localIsShow.value = false;
    }, delay);
  };
  const hanldePopoverShow = () => {
    var _a;
    const elContent = resolveTargetElement((_a = refContent.value) == null ? void 0 : _a.$el);
    elContent.style.setProperty("display", "block");
    elContent.style.setProperty("z-index", `${props2.zIndex ? props2.zIndex : bkZIndexManager.getPopperIndex()}`);
    updatePopover();
    ctx.emit("afterShow", {
      isShow: true
    });
  };
  const handlePopoverHide = () => {
    var _a;
    const elContent = resolveTargetElement((_a = refContent.value) == null ? void 0 : _a.$el);
    elContent.style.setProperty("display", "none");
    ctx.emit("afterHidden", {
      isShow: false
    });
  };
  const triggerPopover = () => {
    if (!localIsShow.value) {
      showPopover();
    } else {
      hidePopover();
    }
  };
  const handleClickRef = () => {
    triggerPopover();
  };
  const handlePopContentMouseEnter = () => {
    if (props2.trigger !== "hover") {
      return;
    }
    if (popHideTimerId) {
      isMouseenter = true;
      clearTimeout(popHideTimerId);
      popHideTimerId = void 0;
    }
    emitPopContentMouseEnter();
  };
  const handlePopContentMouseLeave = () => {
    if (isMouseenter) {
      hidePopover();
      isMouseenter = false;
      emitPopContentMouseLeave();
    }
  };
  const emitPopContentMouseEnter = () => {
    ctx.emit(EMIT_EVENTS$1.CONTENT_MOUSEENTER);
  };
  const emitPopContentMouseLeave = () => {
    ctx.emit(EMIT_EVENTS$1.CONTENT_MOUSELEAVE);
  };
  const resolveTriggerEvents = () => {
    var _a;
    const triggerEvents = {
      hover: {
        content: [["mouseenter", handlePopContentMouseEnter], ["mouseleave", handlePopContentMouseLeave]],
        reference: [["mouseenter", showPopover], ["mouseleave", hidePopover], ["focus", showPopover], ["blur", hidePopover]]
      },
      click: [["click", handleClickRef]],
      manual: {
        content: [["mouseenter", emitPopContentMouseEnter], ["mouseleave", emitPopContentMouseLeave]],
        reference: [[]]
      }
    };
    return (_a = triggerEvents[props2.trigger]) != null ? _a : [];
  };
  const updateFullscreenTarget = (val) => {
    fullScreenTarget.value = val;
  };
  watch(() => props2.isShow, (val) => {
    localIsShow.value = val;
  });
  watch(localIsShow, (val) => {
    if (val) {
      hanldePopoverShow();
    } else {
      handlePopoverHide();
    }
  });
  const stopHide = () => {
    if (popHideTimerId) {
      isMouseenter = true;
      clearTimeout(popHideTimerId);
      popHideTimerId = void 0;
    }
  };
  return {
    showPopover,
    hidePopover,
    resolveTriggerEvents,
    updatePopover,
    triggerPopover,
    resolvePopElements,
    isElementFullScreen,
    resolveTargetElement,
    createPopInstance,
    updateFullscreenTarget,
    getFullscreenRoot,
    stopHide,
    localIsShow,
    cleanup
  };
};
let popContainerId = null;
let parentNodeReferId = null;
var usePopperId = (props2, prefix = "#") => {
  const getPrefixId = (root) => {
    let resolvedBoundary = null;
    const resolveBoundary = (fn2) => {
      if (resolvedBoundary === null) {
        fn2();
      }
    };
    const resolveParentBoundary = () => {
      if (/^parent$/i.test(props2.boundary)) {
        resolvedBoundary = `${prefix}${popContainerId}`;
        const { parentNode } = root || {};
        if (parentNode == null ? void 0 : parentNode.parentNode) {
          parentNode.parentNode.setAttribute("data-pnode-id", parentNodeReferId);
          resolvedBoundary = `[data-pnode-id=${parentNodeReferId}]`;
        }
      }
    };
    const resolveCommonBoundary = () => {
      if (!/^body$/i.test(props2.boundary) && typeof props2.boundary === "string") {
        if (!isAvailableId(props2.boundary)) {
          console.error("props.boundary is not available selector");
          resolvedBoundary = "body";
          return;
        }
        resolvedBoundary = props2.boundary;
      }
    };
    resolveBoundary(resolveParentBoundary);
    resolveBoundary(resolveCommonBoundary);
    resolveBoundary(() => {
      resolvedBoundary = typeof props2.boundary === "string" ? props2.boundary : `${prefix}${popContainerId}`;
    });
    return resolvedBoundary;
  };
  if (popContainerId === null || !isAvailableId(`#${popContainerId}`)) {
    popContainerId = `id_${uuid_1.v4()}`;
    const popContainer = document.createElement("div");
    popContainer.setAttribute("id", popContainerId);
    popContainer.setAttribute("data-popper-id", popContainerId);
    document.body.append(popContainer);
  }
  if (parentNodeReferId === null) {
    parentNodeReferId = `id_${uuid_1.v4()}`;
  }
  return {
    popContainerId,
    prefixId: getPrefixId(),
    getPrefixId
  };
};
var usePopoverInit = (props2, ctx, { refReference, refContent, refArrow, refRoot }) => {
  let storeEvents = null;
  const isFullscreen = ref(false);
  const fullscreenReferId = getFullscreenUid();
  const fullScreenTarget = ref();
  const {
    localIsShow,
    showPopover,
    hidePopover,
    updatePopover,
    resolveTriggerEvents,
    resolvePopElements,
    isElementFullScreen,
    updateFullscreenTarget,
    createPopInstance,
    getFullscreenRoot,
    stopHide
  } = useFloating(props2, ctx, { refReference, refContent, refArrow, refRoot });
  const showFn = () => {
    showPopover();
  };
  const hideFn = () => {
    hidePopover();
  };
  const initPopInstance = () => {
    createPopInstance();
    if (props2.always) {
      showPopover();
    } else {
      addEventToPopTargetEl();
    }
  };
  const addEventToPopTargetEl = () => {
    const { elReference, elContent } = resolvePopElements();
    storeEvents = resolveTriggerEvents();
    if (Array.isArray(storeEvents)) {
      addEventToTargetEl(elReference, storeEvents);
    } else {
      const { content, reference: reference2 } = storeEvents;
      addEventToTargetEl(elReference, reference2);
      addEventToTargetEl(elContent, content);
    }
  };
  const addEventToTargetEl = (target, evets) => {
    evets.forEach(([event, listener]) => {
      if (event && typeof listener === "function") {
        target.addEventListener(event, listener);
      }
    });
  };
  const removeEventListener2 = () => {
    if (storeEvents == null ? void 0 : storeEvents.length) {
      const { elReference } = resolvePopElements();
      if (elReference) {
        storeEvents.forEach(([event, listener]) => {
          if (event && typeof listener === "function") {
            elReference.removeEventListener(event, listener);
          }
        });
      }
      storeEvents = null;
    }
  };
  const updateBoundary = () => {
    const { elReference, root } = resolvePopElements();
    if (isFullscreen.value) {
      boundary.value = fullScreenTarget == null ? void 0 : fullScreenTarget.value;
      return;
    }
    boundary.value = getPrefixId(root || elReference);
  };
  const { getPrefixId } = usePopperId(props2, "#");
  const setFullscreenTag = () => {
    var _a;
    (_a = fullScreenTarget == null ? void 0 : fullScreenTarget.value) == null ? void 0 : _a.setAttribute("data-fllsrn-id", fullscreenReferId);
  };
  const clearFullscreenTag = () => {
    var _a, _b;
    const query = `[data-fllsrn-id=${fullscreenReferId}]`;
    ((_b = (_a = fullScreenTarget == null ? void 0 : fullScreenTarget.value) == null ? void 0 : _a.querySelectorAll(query)) != null ? _b : []).forEach((element) => {
      element == null ? void 0 : element.removeAttribute("data-fllsrn-id");
    });
  };
  const boundary = ref();
  const beforeInstanceUnmount = () => {
    removeEventListener2();
  };
  const updateFullscreen = (target) => {
    fullScreenTarget.value = target;
    updateFullscreenTarget(target);
    isFullscreen.value = isElementFullScreen();
    setFullscreenTag();
  };
  const handleFullscreenChange = (e) => {
    if (!document.fullscreenElement) {
      clearFullscreenTag();
    }
    updateFullscreen(e.target);
    updateBoundary();
    updatePopover(null, props2);
  };
  const onMountedFn = () => {
    if (props2.disabled) {
      return;
    }
    initPopInstance();
    if (isElementFullScreen()) {
      const query = `[data-fllsrn-id=${fullscreenReferId}]`;
      const target = getFullscreenRoot(query);
      updateFullscreen(target);
    }
    updateBoundary();
    document.body.addEventListener("fullscreenchange", handleFullscreenChange);
  };
  const onUnmountedFn = () => {
    beforeInstanceUnmount();
    document.body.removeEventListener("fullscreenchange", handleFullscreenChange);
  };
  const handleClickOutside = (_e) => {
    ctx.emit(EMIT_EVENTS$1.CLICK_OUTSIDE, { isShow: localIsShow.value, event: _e });
    if (props2.disableOutsideClick || props2.always || props2.disabled || props2.trigger === "manual") {
      return;
    }
    if (localIsShow.value) {
      hideFn();
    }
  };
  return {
    onMountedFn,
    onUnmountedFn,
    handleClickOutside,
    beforeInstanceUnmount,
    updateBoundary,
    initPopInstance,
    updatePopover,
    showPopover,
    hidePopover,
    showFn,
    hideFn,
    stopHide,
    isFullscreen,
    boundary,
    localIsShow
  };
};
var Component$r = defineComponent({
  name: "Popover",
  components: {
    Content,
    Arrow,
    Root
  },
  directives: {
    clickoutside: ClickOutside
  },
  props: PopoverProps,
  emits: EMIT_EVENT_TYPES$1,
  setup(props2, ctx) {
    const {
      content,
      theme,
      disableTeleport
    } = props2;
    const {
      reference: reference2
    } = toRefs(props2);
    const refDefaultReference = ref();
    const refContent = ref();
    const refArrow = ref();
    const refRoot = ref();
    const refReference = computed(() => reference2.value || refDefaultReference.value);
    const {
      onMountedFn,
      onUnmountedFn,
      handleClickOutside,
      beforeInstanceUnmount,
      updateBoundary,
      initPopInstance,
      showFn,
      hideFn,
      showPopover,
      hidePopover,
      updatePopover,
      stopHide,
      localIsShow,
      boundary
    } = usePopoverInit(props2, ctx, {
      refReference,
      refContent,
      refArrow,
      refRoot
    });
    if (!props2.always && !props2.disabled) {
      watch(() => props2.isShow, () => {
        props2.isShow ? showPopover() : hidePopover();
      }, {
        immediate: true
      });
    }
    watch(() => [props2.disabled], (val) => {
      if (val[0]) {
        beforeInstanceUnmount();
      } else {
        initPopInstance();
      }
    });
    updateBoundary();
    onMounted(onMountedFn);
    onBeforeUnmount(onUnmountedFn);
    const transBoundary = computed(() => !disableTeleport);
    const show2 = () => {
      showFn();
    };
    const hide2 = () => {
      hideFn();
    };
    const contentIsShow = computed(() => {
      if (props2.renderType === RenderType.AUTO) {
        return true;
      }
      return localIsShow.value;
    });
    const renderContent2 = () => {
      if (props2.allowHtml) {
        const {
          vNode
        } = contentAsHTMLElement(props2.content);
        return vNode;
      }
      return content;
    };
    return {
      boundary,
      arrow: props2.arrow,
      refDefaultReference,
      refContent,
      refArrow,
      content,
      theme,
      transBoundary,
      handleClickOutside,
      updatePopover,
      hide: hide2,
      show: show2,
      stopHide,
      contentIsShow,
      renderContent: renderContent2
    };
  },
  render() {
    return createVNode(Root, {
      "ref": "refRoot"
    }, {
      default: () => [createVNode(Reference, {
        "ref": "refDefaultReference"
      }, {
        default: () => {
          var _a, _b, _c;
          return [(_c = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)) != null ? _c : createVNode("span", null, null)];
        }
      }), createVNode(Teleport, {
        "to": this.boundary,
        "disabled": !this.transBoundary
      }, {
        default: () => [withDirectives(createVNode(Content, {
          "ref": "refContent",
          "data-theme": this.theme,
          "extCls": this.extCls,
          "width": this.width,
          "height": this.height,
          "maxHeight": this.maxHeight
        }, {
          default: () => {
            var _a, _b, _c;
            return [this.contentIsShow ? (_c = (_b = (_a = this.$slots).content) == null ? void 0 : _b.call(_a)) != null ? _c : this.renderContent() : ""];
          },
          arrow: () => this.arrow ? createVNode(Arrow, {
            "ref": "refArrow"
          }, {
            default: () => {
              var _a, _b;
              return [(_b = (_a = this.$slots).arrow) == null ? void 0 : _b.call(_a)];
            }
          }) : ""
        }), [[resolveDirective("clickoutside"), this.handleClickOutside]])]
      })]
    });
  }
});
function createPopoverComponent(options) {
  let $PopoverInstance = null;
  let $PopoverInstanceVm = null;
  let $PopoverInstanceEl = null;
  const resolvedOptions = __spreadProps(__spreadValues({
    boundary: "body",
    placement: "top",
    autoVisibility: false
  }, options), {
    trigger: "manual"
  });
  const popoverComponent = {
    name: "$popover",
    setup(_2, {
      expose
    }) {
      const refProps = ref(resolvedOptions);
      const refReference = ref();
      const referStyle = ref({
        position: "absolute",
        pointerEvents: "none",
        left: 0,
        top: 0,
        width: "auto",
        height: "auto",
        transform: ""
      });
      const updateStyle = (target) => {
        if (isElement(target)) {
          const {
            x: x2,
            y: y2,
            width,
            height
          } = target.getBoundingClientRect();
          Object.assign(referStyle.value, {
            width: `${width}px`,
            height: `${height}px`,
            transform: `translate3d(${x2}px,${y2}px,0)`
          });
          return;
        }
        const {
          clientX,
          clientY
        } = target;
        Object.assign(referStyle.value, {
          transform: `translate3d(${clientX}px,${clientY}px,0)`,
          width: "10px",
          height: "10px"
        });
      };
      updateStyle(refProps.value.target);
      const show3 = () => {
        var _a, _b;
        (_b = (_a = refReference.value) == null ? void 0 : _a.show) == null ? void 0 : _b.call(_a);
      };
      const hide3 = () => {
        var _a, _b;
        (_b = (_a = refReference.value) == null ? void 0 : _a.hide) == null ? void 0 : _b.call(_a);
      };
      const stopHide = () => {
        var _a, _b;
        (_b = (_a = refReference.value) == null ? void 0 : _a.stopHide) == null ? void 0 : _b.call(_a);
      };
      const attrs = computed(() => {
        const excludeKeys = ["target"];
        return Object.keys(refProps.value).filter((key2) => !excludeKeys.includes(key2)).reduce((out, curKey) => __spreadProps(__spreadValues({}, out), {
          [curKey]: refProps.value[curKey]
        }), {});
      });
      const updateTarget = (target) => {
        var _a, _b;
        refProps.value.target = target;
        updateStyle(target);
        (_b = (_a = refReference.value) == null ? void 0 : _a.updatePopover) == null ? void 0 : _b.call(_a);
        nextTick(() => {
          var _a2, _b2;
          (_b2 = (_a2 = refReference.value) == null ? void 0 : _a2.updatePopover) == null ? void 0 : _b2.call(_a2);
        });
      };
      const handleContentMouseenter = () => {
        var _a;
        (_a = resolvedOptions.onContentMouseenter) == null ? void 0 : _a.call(resolvedOptions);
      };
      const handleContentMouseleave = () => {
        var _a;
        (_a = resolvedOptions.onContentMouseleave) == null ? void 0 : _a.call(resolvedOptions);
      };
      expose({
        show: show3,
        hide: hide3,
        updateTarget,
        stopHide
      });
      return () => createVNode(Component$r, mergeProps(attrs.value, {
        "ref": refReference,
        "onContentMouseenter": handleContentMouseenter,
        "onContentMouseleave": handleContentMouseleave
      }), {
        default: () => [createVNode("span", {
          "style": referStyle.value
        }, null)]
      });
    }
  };
  function getBoundaryDom(boundary) {
    if (/^body$/i.test(boundary)) {
      return document.body;
    }
    if (/^parent$/i.test(boundary)) {
      if (isElement(resolvedOptions.target)) {
        return resolvedOptions.target.parentNode;
      }
      return resolvedOptions.target.target.parentNode;
    }
    if (typeof boundary === "string" && isAvailableId(boundary)) {
      return document.querySelector(boundary);
    }
    return document.body;
  }
  if ($PopoverInstance === null) {
    $PopoverInstanceEl = document.createElement("div");
    getBoundaryDom(resolvedOptions.boundary).append($PopoverInstanceEl);
    $PopoverInstance = createApp(popoverComponent);
    $PopoverInstanceVm = $PopoverInstance.mount($PopoverInstanceEl);
  }
  function close2() {
    if ($PopoverInstance) {
      $PopoverInstance.unmount();
      $PopoverInstanceVm = null;
      $PopoverInstance = null;
      $PopoverInstanceEl.remove();
    }
  }
  function show2() {
    $PopoverInstanceVm == null ? void 0 : $PopoverInstanceVm.show();
  }
  function update(e) {
    $PopoverInstanceVm == null ? void 0 : $PopoverInstanceVm.updateTarget(e);
  }
  function hide2() {
    $PopoverInstanceVm == null ? void 0 : $PopoverInstanceVm.hide();
  }
  return {
    close: close2,
    show: show2,
    hide: hide2,
    update,
    get vm() {
      return $PopoverInstanceVm;
    },
    get $el() {
      return $PopoverInstanceVm.$el;
    }
  };
}
const BkPopover = withInstall(Component$r);
var popover = defineComponent({
  name: "Popover2",
  setup() {
    return () => createVNode("code", null, ["<bk-popover2></bk-popover2>\u5DF2\u7ECF\u5408\u5E76\u4E3A<bk-popover></bk-popover>\uFF0C\u8BF7\u66FF\u6362\u4E3A<bk-popover></bk-popover>"]);
  }
});
const BkPopover2 = withInstall(popover);
const Circle = (_2, {
  attrs,
  slots
}) => {
  const {
    width,
    percent,
    strokeWidth,
    color,
    strokeLinecap,
    theme,
    type,
    bgColor,
    titleStyle
  } = attrs;
  const circleStrokeWidth = strokeWidth || 6;
  const circleSize = width || 126;
  const circleStyle = {
    width: typeof circleSize === "number" ? `${circleSize}px` : circleSize,
    height: typeof circleSize === "number" ? `${circleSize}px` : circleSize,
    fontSize: `${circleSize * 0.15 + 6}px`
  };
  const radius = 50 - circleStrokeWidth / 2;
  const isDashboard = type === "dashboard";
  const len = Math.PI * 2 * radius;
  const rate2 = isDashboard && 0.75 || 1;
  const strokeDashoffset = `${-1 * len * (1 - rate2) / 2}px`;
  const transition = "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease";
  const trailStyle = {
    strokeDasharray: `${len * rate2}px, ${len}px`,
    strokeDashoffset
  };
  const pathStyle = {
    strokeDasharray: `${len * rate2 * (percent / 100)}px, ${len}px`,
    strokeDashoffset,
    transition
  };
  const path = `
    M 50 50
    m 0 ${isDashboard ? "" : "-"}${radius}
    a ${radius} ${radius} 0 1 1 0 ${isDashboard ? "-" : ""}${radius * 2}
    a ${radius} ${radius} 0 1 1 0 ${isDashboard ? "" : "-"}${radius * 2}
  `;
  const progressCircleTrail = {
    d: path,
    stroke: bgColor || "#f5f5f5",
    "stroke-linecap": strokeLinecap,
    "stroke-width": circleStrokeWidth,
    "fill-opacity": "0",
    class: "process-circle-trail",
    style: trailStyle
  };
  const progressCirclePath = {
    d: path,
    stroke: color || "#13ce66",
    "stroke-linecap": strokeLinecap,
    "stroke-width": percent > 0 && circleStrokeWidth || 0,
    "fill-opacity": "0",
    class: `process-circle-path lesscode-bk-${theme}-circle-trail`,
    style: pathStyle
  };
  return createVNode("div", {
    "class": "progress-outer-circle",
    "style": circleStyle
  }, [createVNode("svg", {
    "viewBox": "0 0 100 100"
  }, [createVNode("path", progressCircleTrail, null), createVNode("path", progressCirclePath, null)]), createVNode("span", {
    "class": "progress-circle-text",
    "style": titleStyle
  }, [slots == null ? void 0 : slots.default()])]);
};
const Line = (_2, {
  attrs,
  slots
}) => {
  const {
    percent,
    strokeWidth,
    size,
    color,
    titleStyle,
    showText,
    textInside,
    theme
  } = attrs;
  const percentStyle = {
    height: `${strokeWidth}px`,
    lineHeight: `${strokeWidth}px`
  };
  const barStyle = {
    width: `${percent}%`,
    background: color,
    animationDuration: "3s"
  };
  const showDefault = (isTextInside = true) => {
    if (!(showText || slots.default)) {
      return null;
    }
    if (isTextInside && textInside || !isTextInside && !textInside) {
      return slots == null ? void 0 : slots.default();
    }
    return null;
  };
  return createVNode("div", {
    "class": "progress-outer"
  }, [createVNode("div", {
    "class": `lesscode-bk-progress-${size || "normal"} progress-bar`,
    "style": percentStyle
  }, [createVNode("div", {
    "style": barStyle,
    "class": {
      "progress-inner": true,
      [`lesscode-bk-${theme}`]: true
    }
  }, [createVNode("div", {
    "class": "inner-text",
    "style": titleStyle
  }, [showDefault()])])]), showDefault(false)]);
};
function _isSlot$6(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
var Component$q = defineComponent({
  name: "Progress",
  props: {
    extCls: PropTypes.string,
    type: PropTypes.string.validate((value) => ["line", "circle", "dashboard"].includes(value)).def("line"),
    percent: PropTypes.number.def(0),
    theme: PropTypes.theme().def(ThemeEnum.PRIMARY),
    size: PropTypes.size(),
    width: PropTypes.number.def(126),
    strokeWidth: PropTypes.number,
    strokeLinecap: PropTypes.string.def("round"),
    textInside: PropTypes.bool.def(false),
    showText: PropTypes.bool.def(true),
    color: PropTypes.string,
    bgColor: PropTypes.string,
    fixed: PropTypes.number.validate((value) => value >= 0 && value <= 20).def(0),
    format: PropTypes.func.def((percent) => `${percent}%`),
    titleStyle: PropTypes.object.def({
      fontSize: "16px",
      verticalAlign: "middle"
    })
  },
  setup() {
    return {};
  },
  methods: {
    validPercent(percent) {
      if (!percent || percent < 0) {
        return 0;
      }
      if (percent > 100) {
        return 100;
      }
      return percent;
    },
    renderProcessInfo() {
      var _a;
      const {
        showText,
        format: format2,
        percent,
        textInside,
        titleStyle,
        fixed
      } = this.$props;
      const formatPercent = format2((_a = this.validPercent(percent)) == null ? void 0 : _a.toFixed(fixed));
      if ((showText || this.$slots.default) && textInside) {
        return this.$slots.default ? this.$slots.default() : createVNode("span", null, [formatPercent]);
      }
      if (!showText || textInside)
        return null;
      return createVNode("span", {
        "class": "progress-text",
        "style": typeof formatPercent === "string" ? titleStyle : void 0
      }, [this.$slots.default ? this.$slots.default() : formatPercent]);
    }
  },
  render() {
    const progressInfo = this.renderProcessInfo();
    const $props = __spreadProps(__spreadValues({}, this.$props), {
      percent: this.validPercent(this.percent)
    });
    let progress2 = createVNode(Line, $props, _isSlot$6(progressInfo) ? progressInfo : {
      default: () => [progressInfo]
    });
    if (this.type === "circle" || this.type === "dashboard") {
      progress2 = createVNode(Circle, $props, _isSlot$6(progressInfo) ? progressInfo : {
        default: () => [progressInfo]
      });
    }
    const progressProps = {
      class: classes({
        extCls: !!this.extCls
      }, `lesscode-bk-progress lesscode-bk-progress-${this.type}`)
    };
    return createVNode("div", progressProps, [progress2]);
  }
});
const BkProgress = withInstall(Component$q);
const radioGroupKey = Symbol("RadioGroup");
function useFocus() {
  const isFocused = ref(false);
  const blur = () => {
    isFocused.value = false;
  };
  const focus = () => {
    isFocused.value = true;
  };
  return [
    isFocused,
    {
      blur,
      focus
    }
  ];
}
const useRadio = () => {
  const currentInstance = getCurrentInstance();
  const {
    props: props2,
    emit
  } = currentInstance;
  const radioGroup = inject(radioGroupKey, EMPTY_OBJ);
  const isGroup = !isEmptyObj(radioGroup);
  const isChecked = ref(false);
  const isDisabled = computed(() => {
    if (isGroup && radioGroup.props.disabled) {
      return true;
    }
    return props2.disabled;
  });
  if (isGroup) {
    watch(() => radioGroup.props.modelValue, (modelValue) => {
      isChecked.value = modelValue === props2.label;
    }, {
      immediate: true
    });
  } else {
    watch(() => props2.modelValue, (modelValue) => {
      if (modelValue === "") {
        return;
      }
      isChecked.value = modelValue === props2.label;
    }, {
      immediate: true
    });
  }
  const setChecked = (value = true) => {
    isChecked.value = value;
  };
  const handleChange = (event) => {
    if (isDisabled.value) {
      return;
    }
    const $targetInput = event.target;
    isChecked.value = $targetInput.checked;
    const nextValue = isChecked.value ? props2.label : "";
    emit("update:modelValue", nextValue);
    emit("change", nextValue);
    if (isGroup) {
      radioGroup.handleChange(currentInstance.proxy);
    }
    nextTick(() => {
      if ($targetInput.checked !== isChecked.value) {
        $targetInput.checked = isChecked.value;
      }
    });
  };
  onMounted(() => {
    if (isGroup) {
      radioGroup.register(currentInstance.proxy);
    }
  });
  onBeforeUnmount(() => {
    if (isGroup) {
      radioGroup.unregister(currentInstance.proxy);
    }
  });
  return {
    isChecked,
    isDisabled,
    setChecked,
    handleChange
  };
};
const radioProps = {
  name: PropTypes.string.def(""),
  label: PropTypes.oneOfType([String, Number, Boolean]).isRequired,
  modelValue: PropTypes.oneOfType([String, Number, Boolean]).def(""),
  checked: PropTypes.bool.def(false),
  disabled: PropTypes.bool.def(false)
};
var Component$p = defineComponent({
  name: "Radio",
  props: radioProps,
  emits: ["change", "update:modelValue"],
  setup() {
    const [isFocused, {
      blur: handleBlur,
      focus: handleFocus
    }] = useFocus();
    const {
      isChecked,
      isDisabled,
      setChecked,
      handleChange
    } = useRadio();
    return {
      isFocused,
      isChecked,
      isDisabled,
      setChecked,
      handleBlur,
      handleFocus,
      handleChange
    };
  },
  render() {
    const radioClass = classes({
      "lesscode-bk-radio": true,
      "is-focused": this.isFocused,
      "is-disabled": this.isDisabled,
      "is-checked": this.isChecked
    });
    const renderLabel = () => {
      if (!this.label && !this.$slots.default) {
        return null;
      }
      return createVNode("span", {
        "class": "lesscode-bk-radio-label"
      }, [this.$slots.default ? this.$slots.default() : this.label]);
    };
    return createVNode("label", {
      "class": radioClass,
      "tabindex": "0"
    }, [createVNode("input", {
      "class": "lesscode-bk-radio-input",
      "type": "radio",
      "tabindex": "0",
      "value": this.label,
      "checked": this.isChecked,
      "disabled": this.isDisabled,
      "onFocus": this.handleFocus,
      "onBlur": this.handleBlur,
      "onChange": this.handleChange
    }, null), renderLabel()]);
  }
});
const radioButtonProps = {
  name: PropTypes.string.def(""),
  label: PropTypes.oneOfType([String, Number, Boolean]).isRequired,
  modelValue: PropTypes.oneOfType([String, Number, Boolean]).def(""),
  checked: PropTypes.bool.def(false),
  disabled: PropTypes.bool.def(false),
  size: PropTypes.size()
};
var RadioButton = defineComponent({
  name: "RadioButton",
  props: radioButtonProps,
  emits: ["change", "update:modelValue"],
  setup() {
    const [isFocused, {
      blur: handleBlur,
      focus: handleFocus
    }] = useFocus();
    const {
      isChecked,
      isDisabled,
      setChecked,
      handleChange
    } = useRadio();
    return {
      isFocused,
      isChecked,
      isDisabled,
      setChecked,
      handleBlur,
      handleFocus,
      handleChange
    };
  },
  render() {
    const radioClass = classes({
      "lesscode-bk-radio-button": true,
      "is-focused": this.isFocused,
      "is-disabled": this.isDisabled,
      "is-checked": this.isChecked
    });
    const renderLabel = () => {
      if (!this.label && !this.$slots.default) {
        return null;
      }
      return createVNode("div", {
        "class": "lesscode-bk-radio-button-label"
      }, [this.$slots.default ? this.$slots.default() : this.label]);
    };
    return createVNode("label", {
      "class": radioClass,
      "tabindex": "0"
    }, [createVNode("input", {
      "class": "lesscode-bk-radio-button-input",
      "type": "radio",
      "tabindex": "0",
      "value": this.label,
      "checked": this.isChecked,
      "disabled": this.isDisabled,
      "onFocus": this.handleFocus,
      "onBlur": this.handleBlur,
      "onChange": this.handleChange
    }, null), renderLabel()]);
  }
});
const radioGroupProps = {
  name: PropTypes.string.def(""),
  modelValue: PropTypes.oneOfType([String, Number, Boolean]),
  disabled: PropTypes.bool,
  withValidate: PropTypes.bool.def(true),
  type: PropTypes.oneOf(["tab", "capsule", "card"]).def("tab")
};
var RadioGroup = defineComponent({
  name: "RadioGroup",
  props: radioGroupProps,
  emits: ["change", "update:modelValue"],
  setup(props2, context) {
    const formItem = useFormItem();
    const radioInstanceList = [];
    const register = (radioContext) => {
      radioInstanceList.push(radioContext);
    };
    const unregister = (radioContext) => {
      const index2 = radioInstanceList.indexOf(radioContext);
      if (index2 > -1) {
        radioInstanceList.splice(index2, 1);
      }
    };
    const handleChange = (checkedRadioInstance) => {
      const nextValue = checkedRadioInstance.label;
      radioInstanceList.forEach((radioInstance) => {
        if (radioInstance !== checkedRadioInstance) {
          radioInstance.setChecked(false);
        }
      });
      context.emit("update:modelValue", nextValue);
      context.emit("change", nextValue);
    };
    provide(radioGroupKey, {
      props: props2,
      register,
      unregister,
      handleChange
    });
    watch(() => props2.modelValue, () => {
      var _a;
      if (props2.withValidate) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
      }
    });
    onMounted(() => {
      if (props2.modelValue === "") {
        return;
      }
      radioInstanceList.forEach((radioInstance) => {
        radioInstance.setChecked(radioInstance.label === props2.modelValue);
      });
    });
    return {};
  },
  render() {
    var _a;
    return createVNode("div", {
      "class": ["lesscode-bk-radio-group", `lesscode-bk-radio-${this.type}`]
    }, [(_a = this.$slots) == null ? void 0 : _a.default()]);
  }
});
const BkRadio = withInstallProps(Component$p, { Group: RadioGroup, Button: RadioButton });
var star = defineComponent({
  name: "Star",
  props: {
    rate: PropTypes.number.def(0),
    width: PropTypes.number.def(15),
    height: PropTypes.number.def(16),
    editable: PropTypes.bool.def(true),
    hoverRate: PropTypes.number.def(0),
    max: PropTypes.number.def(5)
  },
  emits: ["chooseRate", "changeHover"],
  setup(props2, {
    emit
  }) {
    const chooseRate = (index2) => {
      if (!props2.editable)
        return;
      const rate2 = index2 + 1;
      emit("chooseRate", rate2);
    };
    const changeHover = (index2) => {
      if (!props2.editable)
        return;
      const rate2 = index2 + 1;
      emit("changeHover", rate2);
    };
    const starClass = (index2) => classes({
      "lesscode-bk-is-select": index2 < Math.floor(displayRate.value),
      "lesscode-bk-is-edit": props2.editable,
      "lesscode-bk-rate-star": true
    });
    const displayRate = computed(() => props2.hoverRate || props2.rate);
    const starStyle = {
      width: `${props2.width}px`,
      height: `${props2.height}px`,
      minWidth: `${props2.width}px`
    };
    return () => createVNode("p", {
      "class": "lesscode-bk-rate-stars"
    }, [Array(props2.max).fill(1).map((_2, index2) => createVNode("svg", {
      "class": starClass(index2),
      "style": starStyle,
      "x": "0px",
      "y": "0px",
      "viewBox": "0 0 64 64",
      "onClick": () => chooseRate(index2),
      "onMouseenter": () => changeHover(index2)
    }, [createVNode("g", {
      "transform": "translate(-143.000000, -635.000000)"
    }, [createVNode("g", {
      "transform": "translate(83.000000, 114.000000)"
    }, [createVNode("g", {
      "transform": "translate(15.000000, 384.000000)"
    }, [createVNode("g", {
      "transform": "translate(29.000000, 137.000000)"
    }, [createVNode("polygon", {
      "class": "st1",
      "points": "48,53 28.2,63.9 32,40.8 16,24.4 38.1,21 48,-0.1 57.8,21 79.9,24.4 63.9,40.8 67.7,63.9"
    }, null)])])])])]))]);
  }
});
var Component$o = defineComponent({
  name: "Rate",
  components: {
    star
  },
  props: {
    modelValue: PropTypes.number.def(0),
    size: PropTypes.size(),
    editable: PropTypes.bool.def(true),
    withValidate: PropTypes.bool.def(true)
  },
  emits: ["change", "update:modelValue"],
  setup(props2, {
    emit
  }) {
    const formItem = useFormItem();
    const hoverRate = ref(0);
    const chooseRate = (val) => {
      if (!props2.editable)
        return;
      emit("update:modelValue", val);
      emit("change", val);
    };
    const changeHover = (val) => {
      hoverRate.value = val;
    };
    const rateClass = classes({
      "lesscode-bk-rate": true
    });
    const sizeMap = {
      small: {
        width: 12,
        height: 12
      },
      large: {
        width: 18,
        height: 18
      }
    };
    const rateSize = sizeMap[props2.size] || {
      width: 15,
      height: 16
    };
    const starStyle = computed(() => {
      const integer = Math.floor(props2.modelValue);
      const fixWidth = (rateSize.width + 3) * integer;
      const rateWidth = rateSize.width * (props2.modelValue - integer);
      return {
        width: `${fixWidth + rateWidth}px`
      };
    });
    const commonAttrs = {
      width: rateSize.width,
      height: rateSize.height
    };
    watch(() => props2.modelValue, () => {
      var _a;
      if (props2.withValidate) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
      }
    });
    return () => createVNode("p", {
      "class": rateClass
    }, [props2.editable ? createVNode(star, mergeProps({
      "rate": props2.modelValue,
      "hover-rate": hoverRate.value,
      "onChooseRate": chooseRate,
      "onChangeHover": changeHover,
      "onMouseleave": () => changeHover(0)
    }, commonAttrs), null) : [createVNode(star, mergeProps({
      "rate": 5,
      "style": starStyle.value,
      "class": "lesscode-bk-score-real",
      "editable": false
    }, commonAttrs), null), createVNode(star, mergeProps({
      "rate": 0,
      "editable": false
    }, commonAttrs), null)]]);
  }
});
const BkRate = withInstall(Component$o);
var Component$n = defineComponent({
  name: "Swiper",
  props: {
    isLoop: PropTypes.bool.def(true),
    loopTime: PropTypes.number.def(8e3),
    pics: PropTypes.array.def([]),
    list: PropTypes.array.def([]),
    height: PropTypes.number,
    width: PropTypes.number
  },
  emits: ["index-change"],
  setup(props2, {
    emit,
    slots
  }) {
    const {
      isLoop,
      loopTime,
      pics,
      list,
      height,
      width
    } = toRefs(props2);
    const swiperRef = ref();
    const swiperIndex = ref(0);
    const renderWidth = ref(0);
    const renderHeight = ref(0);
    const loopId = ref(0);
    let resizeObserver;
    const computedRenderDataList = computed(() => {
      var _a;
      return ((_a = list.value) == null ? void 0 : _a.length) > 0 ? list.value : pics.value;
    });
    const computedSwiperTranslateStyle = computed(() => ({
      width: `${renderWidth.value * computedRenderDataList.value.length}px`,
      transform: `translateX(-${renderWidth.value * swiperIndex.value}px)`
    }));
    const computedSwiperRenderStyle = computed(() => ({
      width: `${renderWidth.value}px`,
      height: `${renderHeight.value}px`
    }));
    const changeIndex = (index2) => {
      let showIndex = index2;
      if (index2 >= computedRenderDataList.value.length) {
        showIndex = 0;
      }
      if (index2 < 0) {
        showIndex = computedRenderDataList.value.length - 1;
      }
      swiperIndex.value = showIndex;
      emit("index-change", showIndex);
    };
    const goToLink = (link2) => {
      if (!link2)
        return;
      window.open(link2, "_blank");
    };
    const getRenderItemClass = (renderData) => ["lesscode-bk-swiper-img", {
      "lesscode-bk-swiper-link": renderData.link
    }, renderData.class];
    const getRenderItemStyle = (renderData) => ({
      "background-image": `url(${renderData.url})`,
      "background-color": renderData.color
    });
    const getRenderIndexStyle = (index2) => ({
      "lesscode-bk-current-index": swiperIndex.value === index2
    });
    const startLoop = () => {
      if (isLoop.value) {
        loopId.value = window.setTimeout(() => {
          changeIndex(swiperIndex.value + 1);
          startLoop();
        }, loopTime.value);
      }
    };
    const endLoop = () => {
      window.clearTimeout(loopId.value);
    };
    const watchParentSizeChange = () => {
      var _a;
      const parentEle = (_a = swiperRef.value) == null ? void 0 : _a.parentElement;
      if (!parentEle || !window.ResizeObserver) {
        return;
      }
      resizeObserver = new ResizeObserver(() => {
        calcSize();
      });
      resizeObserver.observe(parentEle);
    };
    const endWatchParentSizeChange = () => {
      var _a;
      (_a = resizeObserver.disconnect) == null ? void 0 : _a.call(resizeObserver);
    };
    const getElementSize = (node) => {
      if (node === void 0) {
        return {
          height: 0,
          width: 0
        };
      }
      const computedStyle = getComputedStyle(node);
      const width2 = node.clientWidth - parseFloat(computedStyle.paddingTop) - parseFloat(computedStyle.paddingBottom);
      const height2 = node.clientHeight - parseFloat(computedStyle.paddingLeft) - parseFloat(computedStyle.paddingRight);
      return {
        height: height2,
        width: width2
      };
    };
    const calcSize = () => {
      var _a;
      const swiperParentSize = getElementSize((_a = swiperRef.value) == null ? void 0 : _a.parentElement);
      renderWidth.value = +width.value > 0 ? width.value : swiperParentSize.width;
      renderHeight.value = +height.value > 0 ? height.value : swiperParentSize.height;
    };
    watch([height, width], calcSize);
    onMounted(() => {
      calcSize();
      startLoop();
      watchParentSizeChange();
    });
    onBeforeUnmount(() => {
      endLoop();
      endWatchParentSizeChange();
    });
    return () => createVNode("section", {
      "class": "lesscode-bk-swiper-home",
      "ref": swiperRef,
      "style": computedSwiperRenderStyle.value
    }, [createVNode("hgroup", {
      "style": computedSwiperTranslateStyle.value,
      "class": "lesscode-bk-transition lesscode-bk-swiper-main"
    }, [computedRenderDataList.value.map((renderData) => {
      var _a, _b;
      return createVNode("h3", {
        "class": "lesscode-bk-swiper-card",
        "style": computedSwiperRenderStyle.value
      }, [(_b = (_a = slots.default) == null ? void 0 : _a.call(slots, renderData)) != null ? _b : createVNode("span", {
        "class": getRenderItemClass(renderData),
        "style": getRenderItemStyle(renderData),
        "onClick": () => goToLink(renderData.link)
      }, null)]);
    })]), createVNode("ul", {
      "class": "lesscode-bk-swiper-index"
    }, [computedRenderDataList.value.map((_2, index2) => createVNode("li", {
      "class": getRenderIndexStyle(index2),
      "onMouseover": () => changeIndex(index2)
    }, null))]), createVNode("span", {
      "class": "lesscode-bk-swiper-nav lesscode-bk-nav-prev",
      "onClick": () => changeIndex(swiperIndex.value - 1)
    }, [createVNode("i", {
      "class": "lesscode-bk-swiper-nav-icon"
    }, null)]), createVNode("span", {
      "class": "lesscode-bk-swiper-nav lesscode-bk-nav-next",
      "onClick": () => changeIndex(swiperIndex.value + 1)
    }, [createVNode("i", {
      "class": "lesscode-bk-swiper-nav-icon"
    }, null)])]);
  }
});
const BkSwiper = withInstall(Component$n);
const selectKey = Symbol("BkSelect");
const optionGroupKey = Symbol("BkOptionGroup");
function useHover() {
  const isHover = ref(false);
  const setHover = () => {
    isHover.value = true;
  };
  const cancelHover = () => {
    isHover.value = false;
  };
  return {
    isHover,
    setHover,
    cancelHover
  };
}
function useRegistry(data2) {
  const register = (key2, item) => {
    if (!item)
      return;
    if (data2.value.has(key2)) {
      console.warn(`repeat ${key2}`, item);
      return;
    }
    return data2.value.set(key2, item);
  };
  const unregister = (key2) => {
    data2.value.delete(key2);
  };
  return {
    register,
    unregister
  };
}
function useDebouncedRef(value, delay = 200) {
  let timeout;
  let innerValue = value;
  return customRef((track, trigger) => ({
    get() {
      track();
      return innerValue;
    },
    set(newValue) {
      clearTimeout(timeout);
      if (newValue === void 0 || newValue === "") {
        innerValue = newValue;
        trigger();
      } else {
        timeout = setTimeout(() => {
          innerValue = newValue;
          trigger();
        }, delay);
      }
    }
  }));
}
function usePopover(config, triggerRef) {
  const { popoverMinWidth } = config;
  let observerIns = null;
  const popperWidth = ref("auto");
  const isPopoverShow = ref(false);
  const togglePopover = () => {
    isPopoverShow.value = !isPopoverShow.value;
  };
  const hidePopover = () => {
    isPopoverShow.value = false;
  };
  const showPopover = () => {
    isPopoverShow.value = true;
  };
  const triggerRefResize = () => {
    var _a;
    popperWidth.value = Math.max((_a = triggerRef.value) == null ? void 0 : _a.offsetWidth, popoverMinWidth);
  };
  onMounted(() => {
    if (!triggerRef.value)
      return;
    observerIns = observerResize$1(triggerRef.value, triggerRefResize, 60, true);
    observerIns.start();
  });
  onBeforeUnmount(() => {
    observerIns == null ? void 0 : observerIns.stop();
    observerIns = null;
  });
  return {
    isPopoverShow,
    popperWidth,
    togglePopover,
    hidePopover,
    showPopover
  };
}
function useRemoteSearch(method, callBack) {
  const searchKey = useDebouncedRef("");
  const searchLoading = ref(false);
  watch(searchKey, async () => {
    try {
      searchLoading.value = true;
      await method(searchKey.value);
      searchLoading.value = false;
    } catch (err) {
      console.error(err);
    } finally {
      callBack == null ? void 0 : callBack();
    }
  });
  return {
    searchKey,
    searchLoading
  };
}
function toLowerCase(value = "") {
  if (!value)
    return value;
  return String(value).trim().toLowerCase();
}
var BkOption = defineComponent({
  name: "Option",
  props: {
    value: {
      type: [String, Number, Object],
      require: true
    },
    label: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def(""),
    disabled: PropTypes.bool.def(false)
  },
  setup(props2) {
    const {
      proxy
    } = getCurrentInstance();
    const states = reactive({
      visible: true
    });
    const {
      disabled,
      value
    } = toRefs(props2);
    const select2 = inject(selectKey, null);
    const group = inject(optionGroupKey, null);
    const selected = computed(() => {
      var _a;
      return (_a = select2 == null ? void 0 : select2.selected) == null ? void 0 : _a.some((item) => item.value === value.value);
    });
    const multiple = computed(() => select2 == null ? void 0 : select2.multiple);
    const isHover = computed(() => (select2 == null ? void 0 : select2.activeOptionValue) === value.value);
    const showSelectedIcon = computed(() => select2 == null ? void 0 : select2.showSelectedIcon);
    const handleOptionClick = () => {
      if (disabled.value)
        return;
      select2 == null ? void 0 : select2.handleOptionSelected(proxy);
    };
    const handleMouseEnter = () => {
      select2.activeOptionValue = value.value;
    };
    onBeforeMount(() => {
      select2 == null ? void 0 : select2.register(value.value, proxy);
      group == null ? void 0 : group.register(value.value, proxy);
    });
    onBeforeUnmount(() => {
      select2 == null ? void 0 : select2.unregister(value.value);
      group == null ? void 0 : group.unregister(value.value);
    });
    return __spreadProps(__spreadValues({}, toRefs(states)), {
      selected,
      multiple,
      isHover,
      showSelectedIcon,
      handleOptionClick,
      handleMouseEnter
    });
  },
  render() {
    var _a, _b, _c;
    const selectItemClass = classes({
      "is-selected": this.selected,
      "is-disabled": this.disabled,
      "is-multiple": this.multiple,
      "is-hover": this.isHover,
      [resolveClassName("select-option")]: true
    });
    return withDirectives(createVNode("li", {
      "class": selectItemClass,
      "onClick": this.handleOptionClick,
      "onMouseenter": this.handleMouseEnter
    }, [(_c = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)) != null ? _c : createVNode("span", {
      "class": resolveClassName("select-option-item"),
      "title": String(this.label)
    }, [this.label]), this.multiple && this.selected && this.showSelectedIcon && createVNode(done, {
      "class": resolveClassName("select-selected-icon"),
      "width": 22,
      "height": 22
    }, null)]), [[vShow, this.visible]]);
  }
});
var OptionGroup = defineComponent({
  name: "OptionGroup",
  props: {
    label: PropTypes.string.def(""),
    disabled: PropTypes.bool.def(false),
    collapsible: PropTypes.bool.def(false),
    collapse: PropTypes.bool.def(false)
  },
  setup(props2, {
    emit
  }) {
    const instance = getCurrentInstance();
    const {
      proxy
    } = instance;
    const select2 = inject(selectKey, null);
    const states = reactive({
      groupCollapse: props2.collapse,
      visible: true
    });
    const optionsMap = ref(/* @__PURE__ */ new Map());
    const {
      register,
      unregister
    } = useRegistry(optionsMap);
    const groupLabel = computed(() => `${props2.label} (${[...optionsMap.value.values()].filter((option) => option.visible).length})`);
    const handleToggleCollapse = () => {
      if (!props2.collapsible || props2.disabled)
        return;
      states.groupCollapse = !states.groupCollapse;
      emit("update:collapse", states.groupCollapse);
    };
    provide(optionGroupKey, reactive(__spreadProps(__spreadValues({}, toRefs(props2)), {
      register,
      unregister,
      groupCollapse: toRef(states, "groupCollapse")
    })));
    onBeforeMount(() => {
      select2 == null ? void 0 : select2.registerGroup(instance.uid, proxy);
    });
    onBeforeUnmount(() => {
      select2 == null ? void 0 : select2.unregisterGroup(instance.uid);
    });
    return __spreadProps(__spreadValues({}, toRefs(states)), {
      groupLabel,
      handleToggleCollapse
    });
  },
  render() {
    var _a, _b;
    const groupClass = classes({
      [resolveClassName("option-group")]: true,
      collapsible: this.collapsible,
      disabled: this.disabled
    });
    const groupLabelClass = classes({
      [resolveClassName("option-group-label")]: true,
      collapsible: this.collapsible
    });
    const groupLabelIconClass = classes({
      "default-group-label-icon": true,
      collapse: this.groupCollapse
    });
    return withDirectives(createVNode("ul", {
      "class": groupClass
    }, [createVNode("li", {
      "class": groupLabelClass,
      "onClick": this.handleToggleCollapse
    }, [this.$slots.label ? this.$slots.label() : createVNode("span", {
      "class": "default-group-label"
    }, [this.collapsible && createVNode(angleUpFill, {
      "class": groupLabelIconClass
    }, null), createVNode("span", {
      "class": "default-group-label-title"
    }, [this.groupLabel])])]), withDirectives(createVNode("ul", {
      "class": resolveClassName("option-group-content")
    }, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)]), [[vShow, !this.groupCollapse]])]), [[vShow, this.visible]]);
  }
});
function placementType() {
  return E().def("bottom");
}
var props = {
  content: PropTypes.string,
  type: PropTypes.oneOf(["tips", "title"]).def("title"),
  calType: PropTypes.oneOf(["dom", "canvas"]).def("dom"),
  boundary: PropTypes.oneOfType([PropTypes.string.def("parent"), PropTypes.instanceOf(HTMLElement)]).def(document.body),
  placement: placementType().def("top-start"),
  resizeable: PropTypes.bool
};
function getActualWidthByCanvas(text, options) {
  const { fontSize = 14, fontFamily = "Microsoft YaHei" } = options;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  ctx.font = `${fontSize}px ${fontFamily}`;
  const metrics = ctx.measureText(text);
  const actual = Math.abs(metrics.actualBoundingBoxLeft) + Math.abs(metrics.actualBoundingBoxRight);
  return Math.max(metrics.width, actual);
}
function getActualWidthByDom(text, options, dom = document.body) {
  if (!dom) {
    return 0;
  }
  const { fontSize, fontFamily } = options || {};
  const tempDom = document.createElement("div");
  tempDom.style.cssText = `position: absolute;left: -999em;top:-999em;z-index: -1;text-overflow: initial;
    ${fontSize ? `font-size:${fontSize} ;` : ""}
    ${fontFamily ? `font-family:${fontFamily} ` : ""}
  `;
  tempDom.innerText = text;
  dom.append(tempDom);
  const { clientWidth } = tempDom;
  dom.removeChild(tempDom);
  return clientWidth;
}
var overflow = "";
var OverflowTitle = defineComponent({
  name: "OverflowTitle",
  props,
  setup(props2, {
    slots
  }) {
    const boxRef = ref(null);
    const textRef = ref(null);
    const isShowTips = ref(false);
    const textProps = shallowRef();
    const contentText = computed(() => {
      var _a;
      if (props2.content) {
        return props2.content;
      }
      return (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots);
    });
    onMounted(() => {
      const {
        clientWidth
      } = boxRef.value;
      const resizeHandler = debounce(500, () => {
        var _a, _b, _c;
        isShowTips.value = false;
        textProps.value = {};
        let textWidth = 0;
        if (props2.calType === "dom") {
          textWidth = getActualWidthByDom((_a = textRef.value) == null ? void 0 : _a.textContent, null, boxRef.value);
        } else {
          const {
            fontSize,
            fontFamily
          } = getComputedStyle(boxRef.value);
          textWidth = getActualWidthByCanvas(contentText.value, {
            fontSize,
            fontFamily
          });
        }
        if (textWidth > clientWidth) {
          isShowTips.value = true;
          if (props2.type === "title") {
            textProps.value = {
              title: (_c = (_b = textRef == null ? void 0 : textRef.value) == null ? void 0 : _b.innerText) != null ? _c : props2.content
            };
          }
        }
      });
      resizeHandler();
      if (props2.resizeable) {
        const observer = new ResizeObserver(resizeHandler);
        observer.observe(boxRef.value);
        onBeforeUnmount(() => {
          boxRef.value && (observer == null ? void 0 : observer.unobserve(boxRef.value));
          observer == null ? void 0 : observer.disconnect();
        });
      }
    });
    return {
      boxRef,
      textRef,
      isShowTips,
      contentText,
      textProps
    };
  },
  render() {
    return createVNode("div", {
      "ref": "boxRef",
      "class": "position-relative"
    }, [createVNode(BkPopover, {
      "disabled": this.type === "title" || !this.isShowTips,
      "placement": this.placement,
      "boundary": this.boundary || document.body
    }, {
      default: () => createVNode("div", mergeProps({
        "ref": "textRef",
        "class": "text-ov"
      }, this.textProps), [this.contentText]),
      content: () => this.contentText
    })]);
  }
});
const overflowTitle = {
  mounted(el, { value = {} }) {
    const { clientWidth } = el.parentElement;
    if (!clientWidth) {
      return;
    }
    const { content, calType = "dom" } = value;
    const text = content || el.innerText;
    let textWidth = 0;
    if (calType === "dom") {
      textWidth = getActualWidthByDom(el.textContent, null, el.parentElement);
    } else {
      const { fontSize, fontFamily } = getComputedStyle(el);
      textWidth = getActualWidthByCanvas(text, { fontSize, fontFamily });
    }
    if (textWidth > clientWidth) {
      el.setAttribute("title", text);
    }
  }
};
const BkOverflowTitle = withInstall(OverflowTitle);
var _populated = false;
var _ie, _firefox, _opera, _webkit, _chrome;
var _ie_real_version;
var _osx, _windows, _linux, _android;
var _win64;
var _iphone, _ipad, _native;
var _mobile;
function _populate() {
  if (_populated) {
    return;
  }
  _populated = true;
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);
  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);
  _win64 = !!/Win64/.exec(uas);
  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : agent[5] ? parseFloat(agent[5]) : NaN;
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;
    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }
  if (os) {
    if (os[1]) {
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);
      _osx = ver ? parseFloat(ver[1].replace("_", ".")) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}
var UserAgent_DEPRECATED$1 = {
  ie: function() {
    return _populate() || _ie;
  },
  ieCompatibilityMode: function() {
    return _populate() || _ie_real_version > _ie;
  },
  ie64: function() {
    return UserAgent_DEPRECATED$1.ie() && _win64;
  },
  firefox: function() {
    return _populate() || _firefox;
  },
  opera: function() {
    return _populate() || _opera;
  },
  webkit: function() {
    return _populate() || _webkit;
  },
  safari: function() {
    return UserAgent_DEPRECATED$1.webkit();
  },
  chrome: function() {
    return _populate() || _chrome;
  },
  windows: function() {
    return _populate() || _windows;
  },
  osx: function() {
    return _populate() || _osx;
  },
  linux: function() {
    return _populate() || _linux;
  },
  iphone: function() {
    return _populate() || _iphone;
  },
  mobile: function() {
    return _populate() || (_iphone || _ipad || _android || _mobile);
  },
  nativeApp: function() {
    return _populate() || _native;
  },
  android: function() {
    return _populate() || _android;
  },
  ipad: function() {
    return _populate() || _ipad;
  }
};
var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED$1;
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var ExecutionEnvironment$1 = {
  canUseDOM,
  canUseWorkers: typeof Worker !== "undefined",
  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
  canUseViewport: canUseDOM && !!window.screen,
  isInWorker: !canUseDOM
};
var ExecutionEnvironment_1 = ExecutionEnvironment$1;
var ExecutionEnvironment = ExecutionEnvironment_1;
var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true;
}
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported$1(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !("addEventListener" in document)) {
    return false;
  }
  var eventName = "on" + eventNameSuffix;
  var isSupported = eventName in document;
  if (!isSupported) {
    var element = document.createElement("div");
    element.setAttribute(eventName, "return;");
    isSupported = typeof element[eventName] === "function";
  }
  if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
    isSupported = document.implementation.hasFeature("Events.wheel", "3.0");
  }
  return isSupported;
}
var isEventSupported_1 = isEventSupported$1;
var UserAgent_DEPRECATED = UserAgent_DEPRECATED_1;
var isEventSupported = isEventSupported_1;
var PIXEL_STEP = 10;
var LINE_HEIGHT$1 = 40;
var PAGE_HEIGHT = 800;
function normalizeWheel$1(event) {
  var sX = 0, sY = 0, pX = 0, pY = 0;
  if ("detail" in event) {
    sY = event.detail;
  }
  if ("wheelDelta" in event) {
    sY = -event.wheelDelta / 120;
  }
  if ("wheelDeltaY" in event) {
    sY = -event.wheelDeltaY / 120;
  }
  if ("wheelDeltaX" in event) {
    sX = -event.wheelDeltaX / 120;
  }
  if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ("deltaY" in event) {
    pY = event.deltaY;
  }
  if ("deltaX" in event) {
    pX = event.deltaX;
  }
  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {
      pX *= LINE_HEIGHT$1;
      pY *= LINE_HEIGHT$1;
    } else {
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY
  };
}
normalizeWheel$1.getEventType = function() {
  return UserAgent_DEPRECATED.firefox() ? "DOMMouseScroll" : isEventSupported("wheel") ? "wheel" : "mousewheel";
};
var normalizeWheel_1 = normalizeWheel$1;
var normalizeWheel = normalizeWheel_1;
const isFirefox = typeof navigator !== "undefined" && navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
const mousewheelHandler = function(element, callback) {
  if (element == null ? void 0 : element.addEventListener) {
    element.addEventListener(isFirefox ? "DOMMouseScroll" : "mousewheel", function(e) {
      const normalized = normalizeWheel(e);
      callback == null ? void 0 : callback.apply(this, [e, normalized]);
    });
  }
};
const mousewheel = {
  beforeMount(el, binding) {
    console.error(el, binding);
    mousewheelHandler(el, binding.value);
  }
};
const nodeList = /* @__PURE__ */ new Map();
const tooltips = {
  beforeMount(el, binding) {
    const opts = getOpts(binding);
    const { trigger } = opts;
    const popper2 = renderContent(opts);
    let delayTimeout = null;
    if (trigger === "hover") {
      let hideTimeout = null;
      el.addEventListener("mouseenter", () => {
        delayTimeout = setTimeout(() => {
          show(el);
          clearTimeout(hideTimeout);
          clearTimeout(delayTimeout);
        }, opts.delay);
      });
      popper2.addEventListener("mouseenter", () => {
        clearTimeout(hideTimeout);
      });
      el.addEventListener("mouseleave", () => {
        clearTimeout(delayTimeout);
        hideTimeout = setTimeout(() => {
          hide(el);
        }, 100);
      });
      el.addEventListener("click", () => {
        hide(el);
      });
      popper2.addEventListener("mouseleave", () => {
        clearTimeout(delayTimeout);
        hideTimeout = setTimeout(() => {
          hide(el);
        }, 100);
      });
    } else if (trigger === "click") {
      document.body.addEventListener("click", (event) => {
        if (el.contains(event.target) && !popper2.hasAttribute("data-show")) {
          delayTimeout = setTimeout(() => {
            show(el);
            clearTimeout(delayTimeout);
          }, opts.delay);
        } else if (popper2.hasAttribute("data-show")) {
          hide(el);
        }
      });
    }
    nodeList.set(el, {
      opts,
      popper: popper2,
      popperInstance: null
    });
  },
  updated(el, binding) {
    nodeList.get(el).opts = getOpts(binding);
  },
  unmounted(el) {
    hide(el);
    nodeList.delete(el);
  }
};
function initOptions() {
  const defaultOpts = {
    arrow: true,
    disabled: false,
    trigger: "hover",
    theme: "dark",
    content: "",
    showOnInit: false,
    placement: "top",
    distance: 8,
    extCls: "",
    delay: 0,
    onShow: () => {
    },
    onHide: () => {
    }
  };
  return defaultOpts;
}
function getOpts(binding) {
  const opts = initOptions();
  if (typeof binding.value === "object") {
    Object.assign(opts, binding.value);
  } else {
    opts.content = binding.value;
  }
  return opts;
}
function renderContent(opts) {
  const { content: value, arrow: hasArrow, theme, extCls } = opts;
  const isLight = theme === "light";
  const zIndex = bkZIndexManager.getPopperIndex();
  const content = document.createElement("div");
  content.className = `${resolveClassName("popper")} ${isLight ? "light" : "dark"} ${extCls}`;
  content.innerText = value;
  content.style.zIndex = String(zIndex);
  if (hasArrow) {
    const arrow2 = renderArrow();
    content.appendChild(arrow2);
  }
  return content;
}
function renderArrow() {
  const arrow2 = document.createElement("div");
  arrow2.className = resolveClassName("popper-arrow");
  arrow2.setAttribute("data-popper-arrow", "");
  return arrow2;
}
function createPopperInstance(el, popper2) {
  const { opts } = nodeList.get(el);
  const { placement, distance: distance2, showOnInit } = opts;
  const popperInstance = createPopper(el, popper2, {
    placement,
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, distance2]
        }
      }
    ]
  });
  if (showOnInit)
    show(el);
  return popperInstance;
}
function show(el) {
  const { popper: popper2, opts } = nodeList.get(el);
  const { disabled, content, arrow: hasArrow, onShow } = opts;
  if (disabled)
    return;
  popper2.innerText = content;
  if (hasArrow) {
    const arrow2 = renderArrow();
    popper2.appendChild(arrow2);
  }
  document.body.appendChild(popper2);
  const popperInstance = createPopperInstance(el, popper2);
  onShow();
  popper2.setAttribute("data-show", "");
  popperInstance.setOptions((options) => __spreadProps(__spreadValues({}, options), {
    modifiers: [
      ...options.modifiers,
      { name: "eventListeners", enabled: true }
    ]
  }));
  popperInstance.forceUpdate();
  nodeList.get(el).popperInstance = popperInstance;
}
function hide(el) {
  if (!nodeList.get(el))
    return;
  const { popper: popper2, popperInstance, opts } = nodeList.get(el);
  const { onHide } = opts;
  if (popper2 && document.body.contains(popper2)) {
    popper2.removeAttribute("data-show");
    popperInstance == null ? void 0 : popperInstance.destroy();
    document.body.removeChild(popper2);
    onHide();
  }
}
const resolveOptions = (el, binding) => {
  const options = {
    content: "",
    target: el
  };
  if (typeof binding.value === "object") {
    Object.assign(options, binding.value);
  } else {
    options.content = binding.value;
  }
  return options;
};
const createInstance = (el, binding) => {
  let instance = null;
  let createTimer = null;
  let hidePopTimer = null;
  const options = resolveOptions(el, binding);
  const { disabled } = options;
  if (disabled || instance) {
    return;
  }
  const handleContentEnter = () => {
    hidePopTimer && clearTimeout(hidePopTimer);
    hidePopTimer = null;
  };
  const handleContentLeave = () => {
    if (createTimer) {
      clearTimeout(createTimer);
    }
    instance == null ? void 0 : instance.hide();
    instance == null ? void 0 : instance.close();
    instance = null;
  };
  const handleMouseEnter = () => {
    createTimer && clearTimeout(createTimer);
    createTimer = setTimeout(() => {
      const targetOptions = resolveOptions(el, binding);
      targetOptions.isShow = true;
      targetOptions.content = targetOptions.content || el.innerHTML;
      targetOptions.allowHtml = true;
      Object.assign(targetOptions, {
        onContentMouseenter: handleContentEnter,
        onContentMouseleave: handleContentLeave
      });
      instance = createPopoverComponent(targetOptions);
    }, 100);
  };
  const handleMouseLeave = () => {
    hidePopTimer = setTimeout(() => {
      if (createTimer) {
        clearTimeout(createTimer);
      }
      instance == null ? void 0 : instance.hide();
      instance == null ? void 0 : instance.close();
      instance = null;
    }, 120);
  };
  el.addEventListener("mouseenter", handleMouseEnter);
  el.addEventListener("mouseleave", handleMouseLeave);
  Object.assign(binding, {
    __cached: {
      handleMouseEnter,
      handleMouseLeave
    }
  });
  const destroyInstance = (element) => {
    var _a, _b;
    handleMouseLeave();
    (_a = element != null ? element : el) == null ? void 0 : _a.removeEventListener("mouseenter", handleMouseEnter);
    (_b = element != null ? element : el) == null ? void 0 : _b.removeEventListener("mouseleave", handleMouseLeave);
  };
  return {
    destroyInstance,
    instance
  };
};
const ellipsis = {
  mounted(el, binding) {
    createInstance(el, binding);
  },
  beforeUnmount(el, binding) {
    if (binding.__cached) {
      const { handleMouseEnter, handleMouseLeave } = binding.__cached;
      el.removeEventListener("mouseenter", handleMouseEnter);
      el.removeEventListener("mouseleave", handleMouseLeave);
      binding.__cached = null;
    }
  }
};
const EventProps = {
  onContentScroll: Function
};
const virtualRenderProps = __spreadValues({
  list: PropTypes.array.def([]),
  enabled: PropTypes.bool.def(true),
  scrollEvent: PropTypes.bool.def(false),
  lineHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).def(30),
  minHeight: PropTypes.number.def(30),
  height: PropTypes.oneOfType([PropTypes.string.def("100%"), PropTypes.number]).def("100%"),
  width: PropTypes.oneOfType([PropTypes.string.def("100%"), PropTypes.number]).def("100%"),
  className: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.object, PropTypes.arrayOf(PropTypes.object), PropTypes.string]).def(""),
  contentClassName: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.object, PropTypes.arrayOf(PropTypes.object), PropTypes.string]).def(""),
  contentStyle: PropTypes.object.def({}),
  scrollXName: PropTypes.string.def(resolveClassName("F-scroll-x")),
  scrollYName: PropTypes.string.def(resolveClassName("F-scroll-y")),
  groupItemCount: PropTypes.number.def(1),
  preloadItemCount: PropTypes.number.def(1),
  renderAs: PropTypes.string.def("div"),
  contentAs: PropTypes.string.def("div"),
  scrollOffsetTop: PropTypes.number.def(0),
  scrollPosition: PropTypes.string.def("content"),
  abosuteHeight: PropTypes.oneOfType([PropTypes.string.def("auto"), PropTypes.number]).def("auto"),
  throttleDelay: PropTypes.number.def(60),
  rowKey: PropTypes.string.def(void 0)
}, EventProps);
var useTagRender = (props2, ctx) => {
  const {
    renderAs,
    contentAs
  } = props2;
  const handleScrollCallback = (event, _startIndex, _endIndex, _scrollTop, translateY, scrollLeft, pos) => {
    ctx.emit("content-scroll", [event, {
      translateY,
      translateX: scrollLeft,
      pos
    }]);
  };
  const vVirtualRender = resolveDirective("bkVirtualRender");
  const dirModifier = {
    lineHeight: props2.lineHeight,
    handleScrollCallback,
    pagination: {},
    throttleDelay: props2.throttleDelay,
    onlyScroll: props2.scrollEvent
  };
  const refRoot = ref(null);
  const scrollTo = ({
    left: left2 = 0,
    top: top2 = 0
  }) => {
    refRoot.value.scrollTo(left2, top2);
  };
  ctx.expose({
    scrollTo
  });
  return {
    rendAsTag: () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      return h$1(renderAs, {
        class: props2.className,
        ref: refRoot
      }, [(_c = (_b = (_a = ctx.slots).beforeContent) == null ? void 0 : _b.call(_a)) != null ? _c : "", withDirectives(h$1(contentAs, {
        class: props2.contentClassName,
        style: props2.contentStyle
      }, [(_f = (_e = (_d = ctx.slots).default) == null ? void 0 : _e.call(_d, {
        data: props2.list
      })) != null ? _f : ""]), [[vVirtualRender, dirModifier]]), (_i = (_h = (_g = ctx.slots).afterContent) == null ? void 0 : _h.call(_g)) != null ? _i : "", (_l = (_k = (_j = ctx.slots).afterSection) == null ? void 0 : _k.call(_j)) != null ? _l : ""]);
    }
  };
};
function getMatchedIndex(maxCount, maxHeight, groupItemCount, callback) {
  let startIndex = 0;
  let height = 0;
  let diffHeight = 0;
  let lastHeight = 0;
  for (; startIndex < maxCount; startIndex++) {
    lastHeight = callback(startIndex, [startIndex * groupItemCount, (startIndex + 1) * groupItemCount, "virtual"]);
    if (height + lastHeight > maxHeight) {
      diffHeight = maxHeight - height;
      break;
    }
    height += lastHeight;
  }
  return { startIndex, height, diffHeight };
}
function computedVirtualIndex(lineHeight, callback, pagination2, el, event) {
  if (!el) {
    return;
  }
  const elScrollTop = el.scrollTop;
  const elScrollLeft = el.scrollLeft;
  const { scrollTop: scrollTop2, count, groupItemCount, startIndex, endIndex, scrollLeft } = pagination2;
  const { offsetHeight } = el;
  let targetStartIndex = 0;
  let targetEndIndex = 0;
  let translateY = 0;
  if (typeof lineHeight === "number") {
    targetStartIndex = Math.floor(elScrollTop / lineHeight);
    targetEndIndex = Math.ceil(offsetHeight / lineHeight) + targetStartIndex;
    translateY = elScrollTop % lineHeight;
  }
  if (typeof lineHeight === "function") {
    const startValue = getMatchedIndex(count, elScrollTop, groupItemCount, lineHeight);
    targetStartIndex = startValue.startIndex > 0 ? startValue.startIndex : 0;
    translateY = startValue.diffHeight;
    const endValue = getMatchedIndex(count, offsetHeight, groupItemCount, lineHeight);
    targetEndIndex = endValue.startIndex + targetStartIndex + 1;
  }
  if (elScrollTop !== scrollTop2 || targetStartIndex !== startIndex || targetEndIndex !== endIndex || scrollLeft !== elScrollLeft) {
    const bottom2 = el.scrollHeight - el.offsetHeight - el.scrollTop;
    typeof callback === "function" && callback(event, targetStartIndex, targetEndIndex, elScrollTop, translateY, elScrollLeft, { bottom: bottom2 >= 0 ? bottom2 : 0 });
  }
}
function visibleRender(e, wrapper, binding) {
  const { lineHeight = 30, handleScrollCallback, pagination: pagination2 = {}, onlyScroll } = binding.value;
  if (onlyScroll) {
    const elScrollTop = wrapper.scrollTop;
    const elScrollLeft = wrapper.scrollLeft;
    const bottom2 = wrapper.scrollHeight - wrapper.offsetHeight - wrapper.scrollTop;
    handleScrollCallback(e, null, null, elScrollTop, elScrollTop, elScrollLeft, { bottom: bottom2 >= 0 ? bottom2 : 0 });
    return;
  }
  const { startIndex, endIndex, groupItemCount, count, scrollTop: scrollTop2, scrollLeft } = pagination2;
  computedVirtualIndex(lineHeight, handleScrollCallback, { scrollTop: scrollTop2, startIndex, endIndex, groupItemCount, count, scrollLeft }, wrapper, e);
}
const throttledRender = (delay = 60) => lodash.exports.throttle((e, wrapper, binding) => visibleRender(e, wrapper, binding), delay);
const executeThrottledRender = (e, wrapper, binding, delay = 60) => {
  Reflect.apply(throttledRender(delay), globalThis, [e, wrapper, binding]);
};
var virtualRender = {
  mounted(el, binding) {
    const wrapper = el.parentNode;
    const { throttleDelay } = binding.value;
    wrapper.addEventListener("scroll", (e) => {
      executeThrottledRender(e, wrapper, binding, throttleDelay);
    });
  },
  unbind(el) {
    if (el) {
      const wrapper = el.parentNode;
      if (!wrapper) {
        return;
      }
      wrapper.removeEventListener("scroll", throttledRender);
    }
  }
};
var Component$m = defineComponent({
  name: "VirtualRender",
  directives: {
    bkVirtualRender: virtualRender
  },
  props: virtualRenderProps,
  emits: ["content-scroll"],
  setup(props2, ctx) {
    const {
      renderAs,
      contentAs
    } = props2;
    const resolvePropClassName = (prop) => {
      if (typeof prop === "string") {
        return [prop];
      }
      if (typeof prop === "object" && !Array.isArray(prop)) {
        return [prop];
      }
      return prop;
    };
    if (!props2.enabled) {
      const {
        rendAsTag
      } = useTagRender(props2, ctx);
      return rendAsTag;
    }
    const refRoot = ref(null);
    const pagination2 = reactive({
      startIndex: 0,
      endIndex: 0,
      scrollTop: 1,
      scrollLeft: 0,
      translateY: 0,
      translateX: 0,
      count: 0,
      pos: {},
      groupItemCount: props2.groupItemCount
    });
    const handleScrollCallback = (event, startIndex, endIndex, scrollTop2, translateY, scrollLeft, pos) => {
      pagination2.startIndex = startIndex;
      pagination2.endIndex = endIndex;
      pagination2.scrollTop = scrollTop2;
      pagination2.translateY = translateY;
      pagination2.translateX = scrollLeft;
      pagination2.scrollLeft = scrollLeft;
      pagination2.pos = pos;
      ctx.emit("content-scroll", [event, pagination2]);
    };
    onMounted(() => {
      nextTick(() => {
        handleListChanged(props2.list);
        afterListDataReset();
      });
    });
    watch(() => props2.list, () => {
      handleChangeListConfig();
      afterListDataReset();
    }, {
      deep: true
    });
    watch(() => props2.lineHeight, () => {
      handleChangeListConfig();
      afterListDataReset();
    });
    const handleChangeListConfig = () => {
      handleListChanged(props2.list);
    };
    const listLength = ref(0);
    const innerHeight = ref(0);
    const handleListChanged = (list) => {
      listLength.value = Math.ceil((list || []).length / props2.groupItemCount);
      pagination2.count = listLength.value;
      pagination2.startIndex = 0;
      pagination2.endIndex = 0;
      pagination2.translateY = 0;
      pagination2.scrollTop = 0;
      const isAuto = typeof props2.abosuteHeight === "string" && props2.abosuteHeight === "auto";
      if (isAuto) {
        if (typeof props2.lineHeight === "function") {
          innerHeight.value = 0;
          let fnValue = 0;
          for (let i2 = 0; i2 < listLength.value; i2++) {
            const fnVal = props2.lineHeight.call(this, i2, list.slice(i2 * props2.groupItemCount, props2.groupItemCount));
            fnValue += typeof fnVal === "number" ? fnVal : 0;
          }
          innerHeight.value = fnValue;
        } else {
          innerHeight.value = props2.lineHeight * listLength.value;
        }
      } else {
        innerHeight.value = props2.abosuteHeight;
      }
    };
    const afterListDataReset = (scrollTop2 = true) => {
      var _a;
      const el = (_a = refRoot.value) == null ? void 0 : _a.parentNode;
      computedVirtualIndex(props2.lineHeight, handleScrollCallback, pagination2, el, null);
      if (scrollTop2 && refRoot.value) {
        refRoot.value.scrollTo(0, 0);
      }
    };
    const localList = computed(() => {
      if (props2.rowKey !== void 0) {
        return props2.list;
      }
      return (props2.list || []).map((item, index2) => __spreadProps(__spreadValues({}, item), {
        $index: index2
      }));
    });
    const calcList = computed(() => localList.value.slice(pagination2.startIndex * props2.groupItemCount, (pagination2.endIndex + props2.preloadItemCount) * props2.groupItemCount));
    const innerContentStyle = computed(() => props2.scrollPosition === "content" ? {
      top: `${pagination2.scrollTop + props2.scrollOffsetTop}px`,
      transform: `translateY(-${pagination2.translateY}px)`
    } : {});
    const wrapperStyle = computed(() => __spreadValues({
      height: typeof props2.height === "number" ? `${props2.height}px` : props2.height,
      width: typeof props2.width === "number" ? `${props2.width}px` : props2.width,
      display: "inline-block"
    }, props2.scrollPosition === "container" ? innerContentStyle.value : {}));
    const innerStyle = computed(() => {
      const isHidden = typeof props2.abosuteHeight === "number" && props2.abosuteHeight === 0;
      return {
        height: `${innerHeight.value < props2.minHeight ? props2.minHeight : innerHeight.value}px`,
        display: isHidden ? "none" : "block"
      };
    });
    const wrapperClass = computed(() => [resolveClassName("virtual-render"), props2.scrollXName, props2.scrollYName, ...resolvePropClassName(props2.className), props2.scrollPosition === "container" ? resolveClassName("virtual-content") : ""]);
    const innerClass = computed(() => [props2.scrollPosition === "content" ? resolveClassName("virtual-content") : "", ...resolvePropClassName(props2.contentClassName)]);
    const vVirtualRender = resolveDirective("bkVirtualRender");
    const dirModifier = {
      lineHeight: props2.lineHeight,
      handleScrollCallback,
      pagination: pagination2,
      throttleDelay: props2.throttleDelay
    };
    const reset2 = () => {
      handleChangeListConfig();
      afterListDataReset();
    };
    const scrollTo = (option = {
      left: 0,
      top: 0
    }) => {
      const {
        left: left2,
        top: top2
      } = option;
      refRoot.value.scrollTo(left2, top2);
    };
    ctx.expose({
      reset: reset2,
      scrollTo
    });
    return () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      return h$1(renderAs || "div", {
        ref: refRoot,
        class: wrapperClass.value,
        style: wrapperStyle.value
      }, [(_c = (_b = (_a = ctx.slots).beforeContent) == null ? void 0 : _b.call(_a)) != null ? _c : "", withDirectives(h$1(contentAs || "div", {
        class: innerClass.value,
        style: __spreadValues(__spreadValues({}, innerContentStyle.value), props2.contentStyle)
      }, [(_f = (_e = (_d = ctx.slots).default) == null ? void 0 : _e.call(_d, {
        data: calcList.value
      })) != null ? _f : ""]), [[vVirtualRender, dirModifier]]), (_i = (_h = (_g = ctx.slots).afterContent) == null ? void 0 : _h.call(_g)) != null ? _i : "", h$1("div", {
        class: [resolveClassName("virtual-section")],
        style: innerStyle.value
      }), (_l = (_k = (_j = ctx.slots).afterSection) == null ? void 0 : _k.call(_j)) != null ? _l : ""]);
    };
  }
});
const BkVirtualRender = withInstall(Component$m);
var TagStrokeType;
(function(TagStrokeType2) {
  TagStrokeType2["UNKNOWN"] = "";
  TagStrokeType2["FILLED"] = "filled";
  TagStrokeType2["STROKE"] = "stroke";
})(TagStrokeType || (TagStrokeType = {}));
var Component$l = defineComponent({
  name: "Tag",
  props: {
    theme: TagThemeType(),
    closable: PropTypes.bool.def(false),
    type: j("tagStorkeType", {}).def(TagStrokeType.UNKNOWN),
    checkable: PropTypes.bool.def(false),
    checked: PropTypes.bool.def(false),
    radius: PropTypes.string.def("2px"),
    extCls: PropTypes.string.def("")
  },
  emits: ["change", "close"],
  slots: ["icon"],
  setup(props2, {
    emit
  }) {
    const wrapperCls = computed(() => classes({
      "lesscode-bk-tag-closable": props2.closable,
      "lesscode-bk-tag-checkable": props2.checkable,
      "lesscode-bk-tag-check": props2.checked,
      [`lesscode-bk-tag-${props2.type}`]: props2.type,
      [`lesscode-bk-tag-${props2.theme}`]: props2.theme,
      [props2.extCls]: !!props2.extCls
    }, "lesscode-bk-tag"));
    const wrapperStyle = computed(() => ({
      borderRadius: props2.radius
    }));
    const handleClose = (e) => {
      e.preventDefault();
      e.stopPropagation();
      emit("close", e);
    };
    const handleClick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (props2.checkable) {
        emit("change", !props2.checked);
      }
    };
    return {
      wrapperCls,
      wrapperStyle,
      handleClose,
      handleClick
    };
  },
  render() {
    var _a, _b;
    return createVNode("div", {
      "class": this.wrapperCls,
      "style": this.wrapperStyle,
      "onClick": this.handleClick
    }, [this.$slots.icon ? createVNode("span", {
      "class": "lesscode-bk-tag-icon"
    }, [this.$slots.icon()]) : "", createVNode("span", {
      "class": "lesscode-bk-tag-text"
    }, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)]), this.closable ? createVNode(error, {
      "class": "lesscode-bk-tag-close",
      "onClick": this.handleClose
    }, null) : ""]);
  }
});
const BkTag = withInstall(Component$l);
var SelectTagInput = defineComponent({
  name: "SelectTagInput",
  props: {
    selected: {
      type: Array,
      default: () => []
    },
    tagTheme: TagThemeType(),
    placeholder: PropTypes.string.def(""),
    filterable: PropTypes.bool.def(false),
    allowCreate: PropTypes.bool.def(false),
    disabled: PropTypes.bool.def(false),
    modelValue: PropTypes.any,
    collapseTags: PropTypes.bool.def(false)
  },
  emits: ["update:modelValue", "remove", "enter", "keydown"],
  setup(props2, {
    emit
  }) {
    const {
      proxy
    } = getCurrentInstance();
    const select2 = inject(selectKey, null);
    const {
      modelValue,
      collapseTags,
      selected
    } = toRefs(props2);
    const value = ref(modelValue.value);
    const inputRef = ref();
    const overflowTagIndex = ref(null);
    watch(modelValue, () => {
      value.value = modelValue.value;
    });
    watch([selected, collapseTags], () => {
      calcOverflow();
    }, {
      flush: "post"
    });
    const handleRemoveTag = (val) => {
      emit("remove", val);
    };
    const focus = () => {
      var _a;
      (_a = inputRef.value) == null ? void 0 : _a.focus();
    };
    const handleInput = (e) => {
      emit("update:modelValue", e.target.value);
    };
    const handleKeydown = (e) => {
      switch (e.code) {
        case "Enter": {
          emit("enter", e.target.value, e);
          break;
        }
      }
      emit("keydown", e.target.value, e);
    };
    const getTagDOM = (index2) => {
      const tags = [...proxy.$el.querySelectorAll(".lesscode-bk-tag")];
      return typeof index2 === "number" ? tags[index2] : tags;
    };
    const calcOverflow = () => {
      if (!collapseTags.value)
        return;
      overflowTagIndex.value = null;
      setTimeout(() => {
        const tags = getTagDOM();
        const tagIndexInSecondRow = tags.findIndex((currentTag, index2) => {
          if (!index2) {
            return false;
          }
          const previousTag = tags[index2 - 1];
          return previousTag.offsetTop !== currentTag.offsetTop;
        });
        overflowTagIndex.value = tagIndexInSecondRow > 0 ? tagIndexInSecondRow : null;
      });
    };
    return {
      select: select2,
      overflowTagIndex,
      value,
      inputRef,
      handleRemoveTag,
      focus,
      handleInput,
      handleKeydown
    };
  },
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const prefix = (_b = (_a = this.$slots) == null ? void 0 : _a.prefix) == null ? void 0 : _b.call(_a);
    const selectTagClass = classes({
      [resolveClassName("select-tag")]: true,
      [resolveClassName("select-tag--default")]: true,
      "is-disabled": this.disabled,
      "collapse-tag": this.collapseTags,
      "has-prefix": !!prefix && (prefix == null ? void 0 : prefix.every((item) => {
        var _a2;
        return !!((_a2 = item.children) == null ? void 0 : _a2.length);
      }))
    });
    const tagWrapperClass = classes({
      [resolveClassName("select-tag-wrapper")]: true
    });
    const inputStyle = {
      display: this.selected.length && !this.filterable ? "none" : ""
    };
    return createVNode("div", {
      "class": selectTagClass
    }, [(_d = (_c = this.$slots) == null ? void 0 : _c.prefix) == null ? void 0 : _d.call(_c), createVNode("span", {
      "class": tagWrapperClass
    }, [(_g = (_f = (_e = this.$slots).default) == null ? void 0 : _f.call(_e)) != null ? _g : this.selected.map((item, index2) => createVNode(BkTag, {
      "closable": true,
      "theme": this.tagTheme,
      "style": {
        display: this.collapseTags && this.overflowTagIndex && index2 >= this.overflowTagIndex ? "none" : ""
      },
      "onClose": () => this.handleRemoveTag(item.value)
    }, {
      default: () => {
        var _a2;
        return [(_a2 = this.select) == null ? void 0 : _a2.handleGetLabelByValue(item.value)];
      }
    })), !!this.overflowTagIndex && this.collapseTags && createVNode(BkTag, {
      "class": resolveClassName("select-overflow-tag")
    }, {
      default: () => [createTextVNode("+"), this.selected.length - this.overflowTagIndex]
    }), createVNode("input", {
      "class": resolveClassName("select-tag-input"),
      "ref": "inputRef",
      "type": "text",
      "style": inputStyle,
      "placeholder": !this.selected.length ? this.placeholder : "",
      "readonly": !this.filterable,
      "disabled": this.disabled,
      "value": !this.filterable ? "" : this.value,
      "onInput": this.handleInput,
      "onKeydown": this.handleKeydown
    }, null)]), (_i = (_h = this.$slots) == null ? void 0 : _h.suffix) == null ? void 0 : _i.call(_h)]);
  }
});
var Component$k = defineComponent({
  name: "Select",
  directives: {
    clickoutside: ClickOutside
  },
  props: {
    modelValue: PropTypes.any,
    multiple: PropTypes.bool.def(false),
    disabled: PropTypes.bool.def(false),
    size: PropTypes.size().def(SizeEnum.DEFAULT),
    clearable: PropTypes.bool.def(true),
    loading: PropTypes.bool.def(false),
    filterable: PropTypes.bool.def(false),
    remoteMethod: PropTypes.func,
    scrollHeight: PropTypes.number.def(200),
    showSelectAll: PropTypes.bool.def(false),
    popoverMinWidth: PropTypes.number.def(0),
    showOnInit: PropTypes.bool.def(false),
    multipleMode: PropTypes.oneOf(["default", "tag"]).def("default"),
    tagTheme: TagThemeType(),
    behavior: InputBehaviorType(),
    collapseTags: PropTypes.bool.def(false),
    autoHeight: PropTypes.bool.def(true),
    noDataText: PropTypes.string,
    noMatchText: PropTypes.string,
    loadingText: PropTypes.string,
    placeholder: PropTypes.string,
    searchPlaceholder: PropTypes.string,
    selectAllText: PropTypes.string,
    scrollLoading: PropTypes.bool.def(false),
    allowCreate: PropTypes.bool.def(false),
    popoverOptions: Object,
    customContent: PropTypes.bool.def(false),
    list: PropTypes.array.def([]),
    idKey: PropTypes.string.def("value"),
    displayKey: PropTypes.string.def("label"),
    withValidate: PropTypes.bool.def(true),
    showSelectedIcon: PropTypes.bool.def(true),
    inputSearch: PropTypes.bool.def(true),
    enableVirtualRender: PropTypes.bool.def(false),
    allowEmptyValues: PropTypes.array.def([]),
    autoFocus: PropTypes.bool.def(false),
    keepSearchValue: PropTypes.bool.def(false),
    prefix: PropTypes.string
  },
  emits: ["update:modelValue", "change", "toggle", "clear", "scroll-end", "focus", "blur"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("select");
    const {
      modelValue,
      disabled,
      filterable,
      multiple,
      remoteMethod,
      loading: loading2,
      popoverMinWidth,
      showOnInit,
      multipleMode,
      allowCreate,
      customContent,
      showSelectedIcon,
      inputSearch,
      enableVirtualRender,
      showSelectAll,
      scrollHeight,
      list,
      displayKey,
      idKey,
      collapseTags,
      autoHeight,
      popoverOptions,
      allowEmptyValues,
      autoFocus,
      keepSearchValue
    } = toRefs(props2);
    const localNoDataText = computed(() => {
      if (props2.noDataText === void 0) {
        return t2.value.noData;
      }
      return props2.noDataText;
    });
    const localNoMatchText = computed(() => {
      if (props2.noMatchText === void 0) {
        return t2.value.noMatchedData;
      }
      return props2.noMatchText;
    });
    const localLoadingText = computed(() => {
      if (props2.loadingText === void 0) {
        return t2.value.loading;
      }
      return props2.loadingText;
    });
    const localPlaceholder = computed(() => {
      if (props2.placeholder === void 0) {
        return t2.value.pleaseSelect;
      }
      return props2.placeholder;
    });
    const localSearchPlaceholder = computed(() => {
      if (props2.searchPlaceholder === void 0) {
        return t2.value.enterKeywords;
      }
      return props2.searchPlaceholder;
    });
    const localSelectAllText = computed(() => {
      if (props2.selectAllText === void 0) {
        return t2.value.all;
      }
      return props2.selectAllText;
    });
    const formItem = useFormItem();
    const inputRef = ref();
    const triggerRef = ref();
    const contentRef = ref();
    const searchRef = ref();
    const selectTagInputRef = ref();
    const virtualRenderRef = ref();
    const popoverRef = ref();
    const optionsMap = ref(/* @__PURE__ */ new Map());
    const options = computed(() => [...optionsMap.value.values()]);
    const groupsMap = ref(/* @__PURE__ */ new Map());
    const selected = ref([]);
    const cacheSelectedMap = computed(() => selected.value.reduce((pre, item) => {
      pre[item.value] = item.label;
      return pre;
    }, {}));
    const activeOptionValue = ref();
    const listMap = computed(() => list.value.reduce((pre, item) => {
      pre[item[idKey.value]] = item[displayKey.value];
      return pre;
    }, {}));
    watch(modelValue, () => {
      var _a;
      handleSetSelectedData();
      if (props2.withValidate) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
      }
    }, {
      deep: true
    });
    watch(selected, () => {
      var _a;
      (_a = popoverRef.value) == null ? void 0 : _a.updatePopover(null, popoverConfig.value);
    });
    const virtualList = computed(() => isRemoteSearch.value ? list.value : list.value.filter((item) => {
      var _a;
      return (_a = toLowerCase(String(item[displayKey.value]))) == null ? void 0 : _a.includes(toLowerCase(searchKey.value));
    }));
    const isDisabled = computed(() => disabled.value || loading2.value);
    const selectedLabel = computed(() => selected.value.map((item) => {
      var _a, _b;
      return ((_b = (_a = optionsMap.value) == null ? void 0 : _a.get(item.value)) == null ? void 0 : _b.label) || item.label || listMap.value[item.value];
    }));
    const isAllSelected = computed(() => {
      const normalSelectedValues = options.value.reduce((pre, option) => {
        if (!option.disabled) {
          pre.push(option.value);
        }
        return pre;
      }, []);
      return normalSelectedValues.length <= selected.value.length && normalSelectedValues.every((val) => selected.value.some((item) => item.value === val));
    });
    const isGroup = computed(() => !!groupsMap.value.size);
    const isOptionsEmpty = computed(() => !options.value.length);
    const isSearchEmpty = computed(() => options.value.length && options.value.every((option) => !option.visible));
    const isRemoteSearch = computed(() => filterable.value && typeof remoteMethod.value === "function");
    const isShowSelectContent = computed(() => !(searchLoading.value || isOptionsEmpty.value || isSearchEmpty.value) || customContent.value);
    const isShowSelectAll = computed(() => multiple.value && showSelectAll.value && (!searchKey.value || !filterable.value));
    const virtualHeight = computed(() => scrollHeight.value - 12 - (isShowSelectAll.value ? 32 : 0));
    const curContentText = computed(() => {
      if (searchLoading.value) {
        return localLoadingText.value;
      }
      if (isOptionsEmpty.value) {
        return localNoDataText.value;
      }
      if (isSearchEmpty.value) {
        return localNoMatchText.value;
      }
      return "";
    });
    const isCollapseTags = computed(() => autoHeight.value ? collapseTags.value && !isPopoverShow.value : collapseTags.value);
    const popoverConfig = computed(() => lodash.exports.merge({
      theme: "light lesscode-bk-select-popover",
      trigger: "manual",
      width: popperWidth.value,
      arrow: false,
      placement: "bottom-start",
      isShow: isPopoverShow.value,
      reference: selectTagInputRef.value,
      offset: 6,
      popoverDelay: 0,
      renderType: RenderType.AUTO
    }, popoverOptions.value));
    const {
      register,
      unregister
    } = useRegistry(optionsMap);
    const {
      register: registerGroup,
      unregister: unregisterGroup
    } = useRegistry(groupsMap);
    const {
      isHover,
      setHover,
      cancelHover
    } = useHover();
    const isFocus = ref(false);
    const handleFocus = () => {
      if (isFocus.value)
        return;
      isFocus.value = true;
      emit("focus");
    };
    const handleBlur = () => {
      if (!isFocus.value)
        return;
      isFocus.value = false;
      emit("blur");
    };
    const {
      popperWidth,
      isPopoverShow,
      hidePopover,
      showPopover,
      togglePopover
    } = usePopover({
      popoverMinWidth: popoverMinWidth.value
    }, triggerRef);
    watch(isPopoverShow, () => {
      emit("toggle", isPopoverShow.value);
    });
    const isInput = computed(() => (filterable.value && inputSearch.value || allowCreate.value) && isPopoverShow.value);
    watch(isPopoverShow, (isShow) => {
      if (!isShow) {
        if (!keepSearchValue.value) {
          searchKey.value = "";
        }
      } else {
        setTimeout(() => {
          focusInput();
          initActiveOptionValue();
        }, 10);
      }
    });
    const initActiveOptionValue = () => {
      var _a;
      const firstSelected = selected.value[0];
      const option = optionsMap.value.get(firstSelected == null ? void 0 : firstSelected.value);
      if (option && !option.disabled && option.visible) {
        activeOptionValue.value = firstSelected == null ? void 0 : firstSelected.value;
      } else {
        activeOptionValue.value = (_a = options.value.find((option2) => !option2.disabled && option2.visible)) == null ? void 0 : _a.value;
      }
    };
    const defaultSearchMethod = (value) => {
      if (!filterable.value)
        return;
      options.value.forEach((option) => {
        var _a;
        option.visible = (_a = toLowerCase(String(option.label))) == null ? void 0 : _a.includes(toLowerCase(value));
      });
    };
    const {
      searchKey,
      searchLoading
    } = useRemoteSearch(isRemoteSearch.value ? remoteMethod.value : defaultSearchMethod, initActiveOptionValue);
    const emitChange = (val) => {
      if (val === modelValue.value)
        return;
      emit("update:modelValue", val, modelValue.value);
      emit("change", val, modelValue.value);
    };
    const handleTogglePopover = () => {
      if (isDisabled.value)
        return;
      handleFocus();
      togglePopover();
    };
    const handleInputChange = (value) => {
      if (!filterable.value)
        return;
      searchKey.value = value;
    };
    const handleInputEnter = (val, e) => {
      const value = String(val);
      if (!allowCreate.value || !value || filterable.value && options.value.find((data3) => toLowerCase(String(data3.label)) === toLowerCase(value)))
        return;
      const data2 = optionsMap.value.get(value);
      if (data2)
        return;
      e.stopPropagation();
      if (multiple.value) {
        selected.value.push({
          value,
          label: value
        });
        emitChange(selected.value.map((item) => item.value));
      } else {
        selected.value = [{
          value,
          label: value
        }];
        emitChange(value);
        hidePopover();
      }
      searchKey.value = "";
    };
    const handleOptionSelected = (option) => {
      if (isDisabled.value || !option)
        return;
      if (multiple.value) {
        const index2 = selected.value.findIndex((item) => item.value === option.value);
        if (index2 > -1) {
          selected.value.splice(index2, 1);
        } else {
          selected.value.push({
            value: option.value,
            label: option.label || option.value
          });
        }
        emitChange(selected.value.map((item) => item.value));
      } else {
        selected.value = [{
          label: option.label || option.value,
          value: option.value
        }];
        emitChange(option.value);
        hidePopover();
      }
      focusInput();
    };
    const focusInput = () => {
      setTimeout(() => {
        var _a, _b, _c;
        if (!inputSearch.value && !allowCreate.value) {
          (_a = searchRef.value) == null ? void 0 : _a.focus();
        } else {
          if (multipleMode.value === "tag") {
            (_b = selectTagInputRef.value) == null ? void 0 : _b.focus();
          } else {
            (_c = inputRef.value) == null ? void 0 : _c.focus();
          }
        }
      }, 0);
    };
    const handleClear = (e) => {
      e.stopPropagation();
      selected.value = [];
      emitChange(multiple.value ? [] : "");
      emit("clear", multiple.value ? [] : "");
      hidePopover();
    };
    const handleSelectedAllOptionMouseEnter = () => {
      activeOptionValue.value = "";
    };
    const handleToggleAll = () => {
      if (isAllSelected.value) {
        selected.value = [];
      } else {
        options.value.forEach((option) => {
          if (option.disabled || selected.value.find((item) => item.value === option.value))
            return;
          selected.value.push({
            value: option.value,
            label: option.label || option.value
          });
        });
      }
      emitChange(selected.value.map((item) => item.value));
      focusInput();
    };
    const handleScroll2 = (e) => {
      const {
        scrollTop: scrollTop2,
        clientHeight,
        scrollHeight: scrollHeight2
      } = e.target;
      if (scrollTop2 + clientHeight === scrollHeight2) {
        emit("scroll-end");
      }
    };
    const handleDeleteTag = (val) => {
      if (isDisabled.value)
        return;
      const index2 = selected.value.findIndex((item) => item.value === val);
      if (index2 > -1) {
        selected.value.splice(index2, 1);
        emitChange(selected.value.map((item) => item.value));
      }
    };
    const handleGetLabelByValue = (value) => {
      var _a, _b;
      let tmpValue = value;
      if (typeof tmpValue === "object") {
        for (const key2 of optionsMap.value.keys()) {
          if (lodash.exports.isEqual(key2, tmpValue)) {
            tmpValue = key2;
            break;
          }
        }
      }
      return ((_b = (_a = optionsMap.value) == null ? void 0 : _a.get(tmpValue)) == null ? void 0 : _b.label) || cacheSelectedMap.value[tmpValue] || listMap.value[tmpValue] || tmpValue;
    };
    const handleSetSelectedData = () => {
      if (Array.isArray(modelValue.value)) {
        selected.value = [...modelValue.value.map((value) => ({
          value,
          label: handleGetLabelByValue(value)
        }))];
      } else {
        if (modelValue.value !== void 0 || allowEmptyValues.value.includes(modelValue.value)) {
          selected.value = [{
            value: modelValue.value,
            label: handleGetLabelByValue(modelValue.value)
          }];
        } else {
          selected.value = [];
        }
      }
    };
    const handleKeydown = (e) => {
      var _a, _b;
      if (!isPopoverShow.value)
        return;
      const availableOptions = options.value.filter((option) => !option.disabled && option.visible);
      const index2 = availableOptions.findIndex((option) => option.value === activeOptionValue.value);
      if (!availableOptions.length || index2 === -1)
        return;
      switch (e.code) {
        case "ArrowDown": {
          e.preventDefault();
          const nextIndex = index2 >= availableOptions.length - 1 ? 0 : index2 + 1;
          activeOptionValue.value = (_a = availableOptions[nextIndex]) == null ? void 0 : _a.value;
          break;
        }
        case "ArrowUp": {
          e.preventDefault();
          const preIndex = index2 === 0 ? availableOptions.length - 1 : index2 - 1;
          activeOptionValue.value = (_b = availableOptions[preIndex]) == null ? void 0 : _b.value;
          break;
        }
        case "Backspace": {
          if (!multiple.value || !selected.value.length || searchKey.value.length || e.target === searchRef.value)
            return;
          selected.value.pop();
          emitChange(selected.value.map((item) => item.value));
          break;
        }
        case "Enter": {
          const option = optionsMap.value.get(activeOptionValue.value);
          handleOptionSelected(option);
          break;
        }
      }
    };
    const handleClickOutside = ({
      event
    }) => {
      var _a;
      const {
        target
      } = event;
      if (((_a = triggerRef.value) == null ? void 0 : _a.contains(target)) || triggerRef.value === target)
        return;
      hidePopover();
      handleBlur();
    };
    const handlePopoverShow = () => {
      setTimeout(() => {
        var _a, _b;
        enableVirtualRender.value && ((_b = (_a = virtualRenderRef.value) == null ? void 0 : _a.reset) == null ? void 0 : _b.call(_a));
      });
    };
    provide(selectKey, reactive({
      multiple,
      selected,
      activeOptionValue,
      showSelectedIcon,
      register,
      unregister,
      registerGroup,
      unregisterGroup,
      handleOptionSelected,
      handleGetLabelByValue
    }));
    onMounted(() => {
      handleSetSelectedData();
      setTimeout(() => {
        showOnInit.value && showPopover();
        autoFocus.value && focusInput();
      });
    });
    return {
      selected,
      isInput,
      options,
      isDisabled,
      selectedLabel,
      isPopoverShow,
      isHover,
      popperWidth,
      inputRef,
      triggerRef,
      contentRef,
      searchRef,
      selectTagInputRef,
      virtualRenderRef,
      popoverRef,
      searchLoading,
      isOptionsEmpty,
      isSearchEmpty,
      isFocus,
      isShowSelectContent,
      curContentText,
      isGroup,
      searchKey,
      isShowSelectAll,
      virtualHeight,
      virtualList,
      isCollapseTags,
      popoverConfig,
      focusInput,
      setHover,
      cancelHover,
      handleFocus,
      handleBlur,
      handleTogglePopover,
      handleClear,
      hidePopover,
      showPopover,
      handleToggleAll,
      handleOptionSelected,
      handleClickOutside,
      handleScroll: handleScroll2,
      handleDeleteTag,
      handleInputChange,
      handleInputEnter,
      handleKeydown,
      handleSelectedAllOptionMouseEnter,
      handlePopoverShow,
      localLoadingText,
      localPlaceholder,
      localSearchPlaceholder,
      localSelectAllText
    };
  },
  render() {
    const selectClass = classes({
      [resolveClassName("select")]: true,
      "popover-show": this.isPopoverShow,
      "is-disabled": this.isDisabled,
      "is-focus": this.isFocus,
      "is-filterable": this.filterable,
      [this.size]: true,
      [this.behavior]: true
    });
    const suffixIcon = () => {
      if (this.loading) {
        return createVNode(BkLoading, {
          "loading": true,
          "theme": "primary",
          "class": "spinner",
          "mode": "spin",
          "size": "mini"
        }, null);
      }
      if (this.clearable && this.isHover && this.selected.length && !this.isDisabled) {
        return createVNode(close$1, {
          "class": "clear-icon",
          "onClick": this.handleClear
        }, null);
      }
      return createVNode(angleUp, {
        "class": "angle-up"
      }, null);
    };
    const renderTriggerInput = () => {
      if (this.multipleMode === "tag") {
        return createVNode(SelectTagInput, {
          "ref": "selectTagInputRef",
          "modelValue": this.searchKey,
          "onUpdate:modelValue": ($event) => this.searchKey = $event,
          "selected": this.selected,
          "tagTheme": this.tagTheme,
          "placeholder": this.localPlaceholder,
          "filterable": this.isInput,
          "disabled": this.isDisabled,
          "onRemove": this.handleDeleteTag,
          "collapseTags": this.isCollapseTags,
          "onEnter": this.handleInputEnter,
          "onKeydown": (_2, e) => this.handleKeydown(e)
        }, {
          prefix: () => {
            var _a, _b;
            if (typeof this.$slots.prefix === "function") {
              return (_b = (_a = this.$slots).prefix) == null ? void 0 : _b.call(_a);
            }
            if (this.prefix) {
              return createVNode("div", {
                "class": "lesscode-bk-select--prefix-area"
              }, [createVNode("span", null, [this.prefix])]);
            }
            return "";
          },
          default: this.$slots.tag && (() => this.$slots.tag({
            selected: this.selected
          })),
          suffix: () => suffixIcon()
        });
      }
      return createVNode(BkInput, mergeProps({
        "ref": "inputRef",
        "type": "text",
        "modelValue": this.isInput ? this.searchKey : this.selectedLabel.join(","),
        "placeholder": this.isInput ? this.selectedLabel.join(",") || this.localPlaceholder : this.localPlaceholder,
        "readonly": !this.isInput,
        "selectReadonly": true,
        "disabled": this.isDisabled,
        "behavior": this.behavior,
        "size": this.size,
        "withValidate": false,
        "onInput": this.handleInputChange,
        "onEnter": this.handleInputEnter,
        "onKeydown": (_2, e) => this.handleKeydown(e)
      }, this.prefix ? {
        prefix: this.prefix
      } : null), __spreadProps(__spreadValues({}, typeof this.$slots.prefix === "function" ? {
        prefix: () => {
          var _a, _b;
          return (_b = (_a = this.$slots).prefix) == null ? void 0 : _b.call(_a);
        }
      } : null), {
        suffix: () => suffixIcon()
      }));
    };
    const renderSelectTrigger = () => {
      var _a, _b;
      return createVNode("div", {
        "class": resolveClassName("select-trigger"),
        "style": {
          height: this.autoHeight && this.collapseTags ? "32px" : ""
        },
        "ref": "triggerRef",
        "onClick": this.handleTogglePopover,
        "onMouseenter": this.setHover,
        "onMouseleave": this.cancelHover
      }, [((_b = (_a = this.$slots).trigger) == null ? void 0 : _b.call(_a, {
        selected: this.selected
      })) || renderTriggerInput()]);
    };
    const renderSelectContent = () => {
      var _a, _b;
      return createVNode("div", {
        "class": resolveClassName("select-content-wrapper"),
        "ref": "contentRef"
      }, [this.filterable && !this.inputSearch && createVNode("div", {
        "class": resolveClassName("select-search-wrapper")
      }, [createVNode(search, {
        "class": "icon-search",
        "width": 16,
        "height": 16
      }, null), withDirectives(createVNode("input", {
        "ref": "searchRef",
        "class": resolveClassName("select-search-input"),
        "placeholder": this.localSearchPlaceholder,
        "onUpdate:modelValue": ($event) => this.searchKey = $event
      }, null), [[vModelText, this.searchKey]])]), !this.isShowSelectContent && createVNode("div", {
        "class": resolveClassName("select-empty")
      }, [this.searchLoading && createVNode(BkLoading, {
        "class": "mr5",
        "theme": "primary",
        "loading": true,
        "mode": "spin",
        "size": "mini"
      }, null), createVNode("span", null, [this.curContentText])]), createVNode("div", {
        "class": resolveClassName("select-content")
      }, [createVNode("div", {
        "class": resolveClassName("select-dropdown"),
        "style": {
          maxHeight: `${this.scrollHeight}px`
        },
        "onScroll": this.handleScroll
      }, [withDirectives(createVNode("ul", {
        "class": resolveClassName("select-options")
      }, [this.isShowSelectAll && createVNode("li", {
        "class": resolveClassName("select-option"),
        "onMouseenter": this.handleSelectedAllOptionMouseEnter,
        "onClick": this.handleToggleAll
      }, [this.localSelectAllText]), this.enableVirtualRender ? createVNode(BkVirtualRender, {
        "list": this.virtualList,
        "height": this.virtualHeight,
        "lineHeight": 32,
        "ref": "virtualRenderRef"
      }, {
        default: ({
          data: data2
        }) => data2.map((item) => createVNode(BkOption, {
          "key": item[this.idKey],
          "value": item[this.idKey],
          "label": item[this.displayKey]
        }, null))
      }) : this.list.map((item) => createVNode(BkOption, {
        "value": item[this.idKey],
        "label": item[this.displayKey]
      }, null)), (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a), this.scrollLoading && createVNode("li", {
        "class": resolveClassName("select-options-loading")
      }, [createVNode(BkLoading, {
        "class": "spinner mr5",
        "theme": "primary",
        "loading": true,
        "mode": "spin",
        "size": "mini"
      }, null), createVNode("span", null, [this.localLoadingText])])]), [[vShow, this.isShowSelectContent]])]), this.$slots.extension && createVNode("div", {
        "class": resolveClassName("select-extension")
      }, [this.$slots.extension()])])]);
    };
    return createVNode("div", {
      "class": selectClass
    }, [createVNode(BkPopover, mergeProps(this.popoverConfig, {
      "onClickoutside": this.handleClickOutside,
      "onAfterShow": this.handlePopoverShow,
      "ref": "popoverRef"
    }), {
      default: () => renderSelectTrigger(),
      content: () => renderSelectContent()
    })]);
  }
});
const BkSelect = withInstallProps(Component$k, { Option: BkOption, Group: OptionGroup });
function _isSlot$5(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
const {
  propsMixin
} = BkModal;
const sliderPops = Object.assign({}, propsMixin);
sliderPops.width.default = "400";
sliderPops.height.default = "100%";
var Component$j = defineComponent({
  name: "Sideslider",
  components: {
    BkModal,
    BkButton
  },
  props: __spreadProps(__spreadValues({}, sliderPops), {
    direction: {
      type: String,
      default: "right",
      validator: (value) => {
        const textAlign = ["left", "right"];
        if (textAlign.indexOf(value) < 0) {
          console.error(`direction property is not valid: '${value}',\u3010${textAlign.join(" | ")}\u3011`);
          return false;
        }
        return true;
      }
    }
  }),
  emits: ["closed", "update:isShow", "shown", "hidden", "animation-end"],
  setup(props2, {
    slots,
    emit
  }) {
    const handleClose = async () => {
      let shouldClose = true;
      if (typeof props2.beforeClose === "function") {
        shouldClose = await props2.beforeClose();
      }
      if (shouldClose) {
        emit("update:isShow", false);
        emit("closed");
        setTimeout(() => {
          emit("animation-end");
        }, 250);
      }
    };
    const handleShown = () => {
      setTimeout(() => {
        emit("shown");
      }, 200);
    };
    const handleHidden = () => {
      setTimeout(() => {
        emit("hidden");
      }, 200);
    };
    return () => {
      const dialogSlot = {
        header: () => {
          var _a, _b;
          return createVNode(Fragment, null, [createVNode("div", {
            "class": "lesscode-bk-sideslider-header"
          }, [createVNode("div", {
            "class": `lesscode-bk-sideslider-close ${props2.direction}`,
            "onClick": () => {
              handleClose();
            }
          }, null), createVNode("div", {
            "class": `lesscode-bk-sideslider-title ${props2.direction}`
          }, [(_b = (_a = slots.header) == null ? void 0 : _a.call(slots)) != null ? _b : props2.title])])]);
        },
        default: () => {
          var _a, _b;
          return (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : "Content";
        },
        footer: () => {
          if (slots.footer) {
            return createVNode("div", {
              "class": "lesscode-bk-sideslider-footer"
            }, [slots.footer()]);
          }
          return null;
        }
      };
      const className = `lesscode-bk-sideslider-wrapper ${props2.scrollable ? "scroll-able" : ""} ${props2.extCls}`;
      const maxHeight = slots.footer ? "calc(100vh - 106px)" : "calc(100vh - 52px)";
      return createVNode(BkModal, mergeProps(props2, {
        "maxHeight": maxHeight,
        "class": className,
        "style": `${props2.direction}: 0;`,
        "onHidden": handleHidden,
        "onShown": handleShown,
        "onClose": handleClose
      }), _isSlot$5(dialogSlot) ? dialogSlot : {
        default: () => [dialogSlot]
      });
    };
  }
});
const BkSideslider = withInstall(Component$j);
var StatusEnum;
(function(StatusEnum2) {
  StatusEnum2["UNKNOWN"] = "";
  StatusEnum2["ERROR"] = "error";
  StatusEnum2["LOADING"] = "loading";
})(StatusEnum || (StatusEnum = {}));
const stepsProps = {
  theme: PropTypes.theme().def(ThemeEnum.PRIMARY),
  size: PropTypes.size(),
  curStep: PropTypes.number.def(1),
  controllable: PropTypes.bool.def(false),
  direction: directionType(),
  status: j("status", {}).def(StatusEnum.UNKNOWN),
  lineType: lineStyleType(),
  text: PropTypes.bool,
  extCls: PropTypes.string,
  steps: PropTypes.array.def([]),
  beforeChange: PropTypes.func
};
var Component$i = defineComponent({
  name: "Steps",
  props: stepsProps,
  emits: ["update:curStep", "click"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("steps");
    const lang = useLocale("lang");
    const defaultSteps = ref([]);
    const updateSteps = (steps2) => {
      const defaults = [];
      steps2.forEach((step) => {
        var _a;
        if (typeof step === "string") {
          defaults.push(step);
        } else {
          defaults.push({
            title: step.title,
            icon: step.icon,
            description: step.description,
            status: step.status,
            border: (_a = step.border) != null ? _a : true
          });
        }
      });
      defaultSteps.value.splice(0, defaultSteps.value.length, ...defaults);
    };
    const updateCurStep = (curStep) => {
      stepsProps.curStep = curStep;
    };
    const init = () => {
      var _a;
      defaultSteps.value.splice(0, defaultSteps.value.length, ...[{
        title: t2.value.step1,
        icon: 1
      }, {
        title: t2.value.step2,
        icon: 2
      }, {
        title: t2.value.step3,
        icon: 3
      }]);
      if ((_a = props2.steps) == null ? void 0 : _a.length) {
        updateSteps(props2.steps);
      }
    };
    watch(() => lang.value, () => {
      init();
    });
    const jumpTo = async (index2) => {
      try {
        if (props2.controllable && index2 !== props2.curStep) {
          if (typeof props2.beforeChange === "function") {
            await new Promise(async (resolve, reject) => {
              const confirmed = await props2.beforeChange(index2);
              confirmed ? resolve(confirmed) : reject(confirmed);
            });
          }
          emit("update:curStep", index2);
          emit("click", index2);
        }
      } catch (e) {
        console.warn(e);
      }
    };
    onMounted(init);
    watch(() => props2.steps, () => {
      updateSteps(props2.steps);
    }, {
      deep: true
    });
    watch(() => props2.curStep, () => {
      updateCurStep(props2.curStep);
    }, {
      deep: true
    });
    return {
      defaultSteps,
      jumpTo
    };
  },
  render() {
    const stepsClsPrefix = "lesscode-bk-steps";
    const stepsThemeCls = this.theme ? `${stepsClsPrefix}-${this.theme}` : "";
    const stepsSizeCls = this.size ? `${stepsClsPrefix}-${this.size}` : "";
    const stepsCls = classes({
      [`${this.extCls}`]: !!this.extCls,
      [`lesscode-bk-steps-${this.direction}`]: this.direction,
      [`lesscode-bk-steps-${this.lineType}`]: this.lineType
    }, `${stepsThemeCls} ${stepsClsPrefix} ${stepsSizeCls}`);
    const isDone = (index2) => this.curStep > index2 + 1 || this.defaultSteps[index2].status === "done";
    const isCurrent = (index2) => this.curStep === index2 + 1;
    const iconType = (step) => {
      const {
        icon
      } = step;
      if (icon) {
        return Object.prototype.toString.call(icon) === "[object Object]";
      }
      return typeof step === "string";
    };
    const isNumberIcon = (index2, step) => {
      if (!step.icon) {
        step.icon = index2;
      }
      return !isNaN(step.icon);
    };
    const isLoadingStatus = (step) => step.status === "loading";
    const isErrorStatus = (step) => step.status === "error";
    const renderIcon = (index2, step) => {
      if (isCurrent(index2) && this.status === "loading" || isLoadingStatus(step)) {
        return createVNode(circle, {
          "class": "lesscode-bk-icon lesscode-bk-steps-icon icon-loading"
        }, null);
      }
      if (isCurrent(index2) && this.status === "error" || isErrorStatus(step)) {
        return createVNode(error, {
          "class": "lesscode-bk-steps-icon"
        }, null);
      }
      if (isDone(index2)) {
        return createVNode(done, {
          "class": "lesscode-bk-steps-icon"
        }, null);
      }
      return createVNode("span", null, [isNumberIcon(index2, step) ? index2 + 1 : createVNode(step.icon, null, null)]);
    };
    return createVNode("div", {
      "class": stepsCls
    }, [this.defaultSteps.map((step, index2) => {
      var _a, _b, _c;
      return createVNode("div", {
        "class": ["lesscode-bk-step", !step.title ? "lesscode-bk-step-no-content" : "", isDone(index2) ? "done" : "", isCurrent(index2) ? "current" : "", isCurrent(index2) && this.status === "error" ? "isError" : "", step.status && isCurrent(index2) ? [`lesscode-bk-step-${step.status}`] : ""]
      }, [createVNode("span", {
        "class": ["lesscode-bk-step-indicator", `lesscode-bk-step-${iconType(step) ? "icon" : "number"}`, `lesscode-bk-step-icon${step.status}`],
        "style": {
          cursor: this.controllable ? "pointer" : ""
        },
        "onClick": () => {
          this.jumpTo(index2 + 1);
        }
      }, [(_c = (_b = (_a = this.$slots)[index2 + 1]) == null ? void 0 : _b.call(_a)) != null ? _c : renderIcon(index2, step)]), step.title ? createVNode("div", {
        "class": "lesscode-bk-step-content"
      }, [createVNode("div", {
        "class": "lesscode-bk-step-title",
        "style": {
          cursor: this.controllable ? "pointer" : ""
        },
        "onClick": () => {
          this.jumpTo(index2 + 1);
        }
      }, [step.title]), step.description && createVNode("div", {
        "class": "lesscode-bk-step-description",
        "title": step.description
      }, [step.description])]) : ""]);
    })]);
  }
});
const BkSteps = withInstall(Component$i);
var Component$h = defineComponent({
  name: "Switcher",
  props: {
    theme: PropTypes.theme(),
    size: PropTypes.size(),
    disabled: PropTypes.bool,
    showText: PropTypes.bool,
    isOutline: PropTypes.bool,
    onText: PropTypes.string.def("ON"),
    offText: PropTypes.string.def("OFF"),
    isSquare: PropTypes.bool,
    extCls: PropTypes.string,
    beforeChange: PropTypes.func.def(void 0),
    trueValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.bool]).def(true),
    falseValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.bool]).def(false),
    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.bool]).def(false),
    modelValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.bool]).def(false),
    withValidate: PropTypes.bool.def(true)
  },
  emits: ["update:modelValue", "change"],
  setup(props2, {
    emit
  }) {
    const formItem = useFormItem();
    const isLoading = ref(false);
    const isChecked = computed(() => props2.trueValue === localValue.value);
    const isModelValue = ref(props2.modelValue !== false);
    const localValue = computed(() => isModelValue.value ? props2.modelValue : props2.value);
    const classObject = computed(() => {
      const cls = {
        [props2.extCls]: !!props2.extCls,
        "lesscode-bk-switcher": true,
        "lesscode-bk-switcher-outline": props2.isOutline,
        "lesscode-bk-switcher-square": props2.isSquare,
        "show-label": props2.showText,
        "is-disabled": props2.disabled,
        "is-checked": isChecked.value,
        "is-unchecked": !isChecked.value,
        "is-loading": isLoading.value,
        "lesscode-bk-primary": props2.theme === "primary"
      };
      if (props2.size && !props2.showText) {
        const sizeStr = `lesscode-bk-switcher-${props2.size}`;
        cls[sizeStr] = true;
      }
      return cls;
    });
    watch(() => props2.modelValue, () => {
      var _a;
      isModelValue.value = true;
      if (props2.withValidate) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
      }
    });
    watch(() => props2.value, () => {
      isModelValue.value = false;
    });
    const handleChange = (event) => {
      event.stopPropagation();
      event.preventDefault();
      if (props2.disabled || isLoading.value) {
        return;
      }
      const lastValue = isChecked.value ? props2.falseValue : props2.trueValue;
      const lastChecked = !isChecked.value;
      const trigger = () => {
        emit("update:modelValue", lastValue);
        emit("change", lastChecked);
      };
      let goodJob = true;
      if (typeof props2.beforeChange === "function") {
        goodJob = props2.beforeChange(lastValue);
        if (typeof goodJob.then === "function") {
          isLoading.value = true;
          return goodJob.then(() => {
            trigger();
          }).finally(() => {
            isLoading.value = false;
          });
        }
      }
      if (goodJob) {
        trigger();
      }
    };
    const handleKeydown = (e) => {
      if (e.code === "Enter" || e.key === "Enter" || e.keyCode === 13) {
        handleChange(e);
      }
    };
    return () => createVNode("div", {
      "class": classObject.value,
      "onClick": handleChange,
      "tabindex": "0",
      "onKeydown": handleKeydown
    }, [isLoading.value ? createVNode(switcherLoading, {
      "class": "lesscode-bk-switcher-loading"
    }, null) : "", props2.showText ? createVNode("span", {
      "class": "switcher-text"
    }, [isChecked.value ? props2.onText : props2.offText]) : ""]);
  }
});
const BkSwitcher = withInstall(Component$h);
var BORDER_OPTION = /* @__PURE__ */ ((BORDER_OPTION2) => {
  BORDER_OPTION2["NONE"] = "none";
  BORDER_OPTION2["ROW"] = "row";
  BORDER_OPTION2["COL"] = "col";
  BORDER_OPTION2["OUTER"] = "outer";
  BORDER_OPTION2["HORIZONTAL"] = "horizontal";
  return BORDER_OPTION2;
})(BORDER_OPTION || {});
var ROW_HOVER = /* @__PURE__ */ ((ROW_HOVER2) => {
  ROW_HOVER2["HIGHLIGHT"] = "highlight";
  ROW_HOVER2["AUTO"] = "auto";
  return ROW_HOVER2;
})(ROW_HOVER || {});
const ROW_HOVER_OPTIONS = ["auto", "highlight"];
const BORDER_OPTIONS = [
  "none",
  "row",
  "col",
  "outer",
  "horizontal"
];
var EVENTS$1 = /* @__PURE__ */ ((EVENTS2) => {
  EVENTS2["ON_SORT_BY_CLICK"] = "onSortByClick";
  EVENTS2["ON_FILTER_CLICK"] = "onFilterClick";
  EVENTS2["ON_SETTING_CHANGE"] = "onSettingChange";
  EVENTS2["ON_ROW_EXPAND_CLICK"] = "onRowExpandClick";
  EVENTS2["ON_ROW_CHECK"] = "onRowCheck";
  return EVENTS2;
})(EVENTS$1 || {});
var EMIT_EVENTS = /* @__PURE__ */ ((EMIT_EVENTS2) => {
  EMIT_EVENTS2["COLUMN_PICK"] = "columnPick";
  EMIT_EVENTS2["COLUMN_SORT"] = "columnSort";
  EMIT_EVENTS2["COLUMN_FILTER"] = "columnFilter";
  EMIT_EVENTS2["COLUMN_FILTER_SAVE"] = "colFilterSave";
  EMIT_EVENTS2["ROW_CLICK"] = "rowClick";
  EMIT_EVENTS2["ROW_DBL_CLICK"] = "rowDblclick";
  EMIT_EVENTS2["ROW_EXPAND_CLICK"] = "rowExpand";
  EMIT_EVENTS2["ROW_MOUSE_ENTER"] = "rowMouseEnter";
  EMIT_EVENTS2["ROW_MOUSE_LEAVE"] = "rowMouseLeave";
  EMIT_EVENTS2["PAGE_LIMIT_CHANGE"] = "pageLimitChange";
  EMIT_EVENTS2["PAGE_VALUE_CHANGE"] = "pageValueChange";
  EMIT_EVENTS2["SETTING_CHANGE"] = "settingChange";
  EMIT_EVENTS2["SCROLL_BOTTOM"] = "scrollBottom";
  EMIT_EVENTS2["ROW_SELECT"] = "select";
  EMIT_EVENTS2["ROW_SELECT_ALL"] = "selectAll";
  EMIT_EVENTS2["ROW_SELECT_CHANGE"] = "selectionChange";
  EMIT_EVENTS2["CELL_CLICK"] = "cellClick";
  EMIT_EVENTS2["CELL_DBL_CLICK"] = "cellDblclick";
  EMIT_EVENTS2["NATIVE_CLICK"] = "click";
  EMIT_EVENTS2["NATIVE_DBL_CLICK"] = "dblclick";
  return EMIT_EVENTS2;
})(EMIT_EVENTS || {});
const EMPTY$1 = (..._args) => true;
const EMIT_EVENT_TYPES = {
  ["columnPick"]: EMPTY$1,
  ["columnFilter"]: EMPTY$1,
  ["columnSort"]: EMPTY$1,
  ["colFilterSave"]: EMPTY$1,
  ["rowClick"]: EMPTY$1,
  ["rowDblclick"]: EMPTY$1,
  ["rowExpand"]: EMPTY$1,
  ["select"]: EMPTY$1,
  ["selectAll"]: EMPTY$1,
  ["selectionChange"]: EMPTY$1,
  ["pageLimitChange"]: EMPTY$1,
  ["pageValueChange"]: EMPTY$1,
  ["settingChange"]: EMPTY$1,
  ["scrollBottom"]: EMPTY$1,
  ["cellClick"]: EMPTY$1,
  ["cellDblclick"]: EMPTY$1
};
const TABLE_ROW_ATTRIBUTE = {
  ROW_INDEX: "__$table_row_index",
  ROW_UID: "__$uuid",
  ROW_EXPAND: "__row_expand",
  ROW_SELECTION: "__row_selection",
  ROW_SELECTION_ALL: "__row_selection_all",
  ROW_SELECTION_INDETERMINATE: "__row_selection_indeterminate",
  ROW_SOURCE_DATA: "__row_source_data",
  ROW_SKIP_CFG: "__row_skip_config"
};
const COLUMN_ATTRIBUTE = {
  COL_UID: "__col_$uuid",
  COL_SOURCE_DATA: "__col_source_data"
};
const SCROLLY_WIDTH = 6;
const LINE_HEIGHT = 42;
const SETTING_SIZE = {
  large: 78,
  medium: 60,
  small: 42
};
const createDefaultSizeList = (t2) => [
  { value: "small", label: t2.value.setting.lineHeight.small, height: SETTING_SIZE.small },
  { value: "medium", label: t2.value.setting.lineHeight.medium, height: SETTING_SIZE.medium },
  { value: "large", label: t2.value.setting.lineHeight.large, height: SETTING_SIZE.large }
];
const PROVIDE_KEY_INIT_COL = "InitColumns";
const PROVIDE_KEY_TB_CACHE = "BKTableCahce";
const BK_COLUMN_UPDATE_DEFINE = "Bk_COlumn_Update_Define";
var SORT_OPTION = /* @__PURE__ */ ((SORT_OPTION2) => {
  SORT_OPTION2["ASC"] = "asc";
  SORT_OPTION2["DESC"] = "desc";
  SORT_OPTION2["NULL"] = "null";
  SORT_OPTION2["CUSTOM"] = "custom";
  return SORT_OPTION2;
})(SORT_OPTION || {});
const SORT_OPTIONS = ["asc", "desc", "null", "custom"];
const COL_MIN_WIDTH = 80;
var SortScope = /* @__PURE__ */ ((SortScope2) => {
  SortScope2["CURRENT"] = "current";
  SortScope2["ALL"] = "all";
  return SortScope2;
})(SortScope || {});
const overflowModeType = j("showOverflowTooltipMode", {
  default: "auto"
});
const columnType = j("columnType", {
  default: "none"
});
const TableAlign = j("columnType", {
  default: ""
});
const fullType = j("full", {
  default: "full"
});
var SettingSizeEnum = /* @__PURE__ */ ((SettingSizeEnum2) => {
  SettingSizeEnum2["SMALL"] = "small";
  SettingSizeEnum2["MEDIUM"] = "medium";
  SettingSizeEnum2["LARGE"] = "large";
  return SettingSizeEnum2;
})(SettingSizeEnum || {});
const settingSizeType = j("columnSize", {
  default: "small"
});
const fixedType = E();
const sortScopeType = j("sortScope", {}).def("current");
var ResizerWay = /* @__PURE__ */ ((ResizerWay2) => {
  ResizerWay2["DEBOUNCE"] = "debounce";
  ResizerWay2["THROTTLE"] = "throttle";
  return ResizerWay2;
})(ResizerWay || {});
const IColumnType = {
  label: PropTypes.oneOfType([PropTypes.func.def(() => ""), PropTypes.string.def("")]),
  field: PropTypes.oneOfType([PropTypes.func.def(() => ""), PropTypes.string.def("")]),
  render: PropTypes.oneOfType([PropTypes.func.def(() => ""), PropTypes.string.def("")]),
  width: PropTypes.oneOfType([PropTypes.number.def(void 0), PropTypes.string.def("auto")]),
  minWidth: PropTypes.oneOfType([PropTypes.number.def(void 0), PropTypes.string.def("auto")]).def(30),
  columnKey: PropTypes.string.def(""),
  showOverflowTooltip: PropTypes.oneOfType([PropTypes.bool, PropTypes.shape({
    content: PropTypes.string.def(""),
    disabled: PropTypes.bool.def(false),
    watchCellResize: PropTypes.bool.def(true),
    mode: overflowModeType
  })]).def(void 0),
  type: columnType,
  resizable: PropTypes.bool.def(true),
  fixed: PropTypes.oneOfType([
    PropTypes.bool,
    fixedType
  ]).def(false),
  sort: PropTypes.oneOfType([
    PropTypes.shape({
      sortFn: PropTypes.func.def(void 0),
      sortScope: sortScopeType,
      value: PropTypes.string.def(SORT_OPTION.NULL)
    }),
    PropTypes.bool,
    PropTypes.string
  ]).def(false),
  filter: PropTypes.oneOfType([
    PropTypes.shape({
      list: PropTypes.arrayOf(PropTypes.any).def([]),
      filterFn: PropTypes.func.def(void 0),
      match: fullType,
      checked: PropTypes.arrayOf(PropTypes.any).def([]),
      filterScope: sortScopeType,
      btnSave: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]).def("\u786E\u5B9A"),
      btnReset: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]).def("\u91CD\u7F6E")
    }),
    PropTypes.bool,
    PropTypes.string
  ]).def(false),
  colspan: PropTypes.oneOfType([PropTypes.func.def(() => 1), PropTypes.number.def(1)]),
  rowspan: PropTypes.oneOfType([PropTypes.func.def(() => 1), PropTypes.number.def(1)]),
  align: TableAlign,
  className: PropTypes.oneOfType([PropTypes.string, PropTypes.func])
};
const tableProps = {
  data: PropTypes.arrayOf(PropTypes.any).def([]),
  columns: PropTypes.arrayOf(PropTypes.shape(IColumnType).loose).def([]),
  activeColumn: PropTypes.oneOfType([PropTypes.number.def(-1), PropTypes.arrayOf(PropTypes.number.def(-1))]),
  columnPick: j("columnPick", {}).def("disabled"),
  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def("auto"),
  minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def(LINE_HEIGHT * 2),
  maxHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def("auto"),
  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).def(LINE_HEIGHT),
  headHeight: PropTypes.number.def(LINE_HEIGHT),
  showHead: PropTypes.bool.def(true),
  thead: PropTypes.shape({
    height: PropTypes.number.def(LINE_HEIGHT),
    isShow: PropTypes.bool.def(true),
    cellFn: PropTypes.func.def(void 0)
  }),
  virtualEnabled: PropTypes.bool.def(false),
  border: PropTypes.oneOfType([
    PropTypes.arrayOf(j("boderType", {})),
    PropTypes.string
  ]).def([BORDER_OPTION.ROW]),
  pagination: PropTypes.oneOfType([PropTypes.bool.def(false), PropTypes.object.def({})]).def(false),
  paginationHeight: PropTypes.number.def(60),
  remotePagination: PropTypes.bool.def(false),
  emptyText: PropTypes.string,
  settings: PropTypes.oneOfType([
    PropTypes.shape({
      fields: PropTypes.arrayOf(PropTypes.shape({
        label: PropTypes.string,
        field: PropTypes.string,
        disabled: PropTypes.bool
      })),
      checked: PropTypes.arrayOf(PropTypes.string),
      limit: PropTypes.number.def(0),
      size: settingSizeType,
      sizeList: PropTypes.shape([]),
      showLineHeight: PropTypes.bool.def(true)
    }),
    PropTypes.bool
  ]).def(false),
  rowClass: PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.func]).def({}),
  rowStyle: PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.func]).def({}),
  cellStyle: PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.func]).def({}),
  cellClass: PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.func]).def({}),
  scrollLoading: PropTypes.oneOfType([
    PropTypes.object,
    PropTypes.bool
  ]).def(void 0),
  reserveExpand: PropTypes.bool.def(false),
  selectionKey: PropTypes.string.def(""),
  isSelectedFn: PropTypes.func.def(void 0),
  rowKey: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.func
  ]).def(TABLE_ROW_ATTRIBUTE.ROW_INDEX),
  showOverflowTooltip: PropTypes.oneOfType([PropTypes.bool, PropTypes.shape({
    content: PropTypes.string.def(""),
    disabled: PropTypes.bool.def(false),
    watchCellResize: PropTypes.bool.def(true),
    mode: overflowModeType
  })]).def(false),
  asyncData: PropTypes.bool.def(false),
  rowHover: PropTypes.oneOf(ROW_HOVER_OPTIONS).def(ROW_HOVER.HIGHLIGHT),
  defaultSort: PropTypes.shape({}).def({}),
  isRowSelectEnable: PropTypes.oneOfType([
    PropTypes.func.def(() => true),
    PropTypes.bool.def(true)
  ]).def(true),
  resizerWay: j("ResizerWay", {
    default: "debounce"
  }),
  observerResize: PropTypes.bool.def(true),
  align: TableAlign,
  headerAlign: TableAlign
};
var Column = defineComponent({
  name: "TableColumn",
  props: __spreadProps(__spreadValues({}, IColumnType), {
    prop: PropTypes.oneOfType([PropTypes.func.def(() => ""), PropTypes.string.def("")]),
    index: PropTypes.number.def(void 0)
  }),
  setup(props2) {
    const initColumns = inject(PROVIDE_KEY_INIT_COL, (_col, _rm = false) => {
    }, false);
    const bkTableCache = inject(PROVIDE_KEY_TB_CACHE, {
      queueStack: (_2, fn2) => fn2 == null ? void 0 : fn2()
    });
    const column = reactive(__spreadProps(__spreadValues({}, props2), {
      field: props2.prop || props2.field
    }));
    return {
      initColumns,
      bkTableCache,
      column
    };
  },
  unmounted() {
    this.updateColumnDefine(true);
  },
  mounted() {
    this.updateColumnDefine();
  },
  methods: {
    updateColumnDefine(unmounted = false) {
      if (this.$props.index !== void 0 && typeof this.$props.index === "number") {
        this.updateColumnDefineByIndex(unmounted);
        return;
      }
      this.updateColumnDefineByParent();
    },
    updateColumnDefineByParent() {
      const fn2 = () => {
        const selfVnode = this._;
        const colList = selfVnode.parent.vnode.children.default() || [];
        const sortColumns = [];
        const reduceColumns = (nodes) => {
          if (!Array.isArray(nodes)) {
            return;
          }
          nodes.forEach((node) => {
            var _a, _b, _c;
            if (Array.isArray(node)) {
              reduceColumns(node);
              return;
            }
            let skipValidateKey0 = true;
            if (((_a = node.type) == null ? void 0 : _a.name) === "TableColumn") {
              skipValidateKey0 = Object.hasOwnProperty.call(node.props || {}, "key");
              const resolveProp = __spreadProps(__spreadValues({}, node.props), {
                field: node.props.prop || node.props.field,
                render: (_b = node.children) == null ? void 0 : _b.default
              });
              sortColumns.push(unref(resolveProp));
            }
            if (((_c = node.children) == null ? void 0 : _c.length) && skipValidateKey0) {
              reduceColumns(node.children);
            }
          });
        };
        reduceColumns(colList);
        this.initColumns(sortColumns);
      };
      if (typeof this.bkTableCache.queueStack === "function") {
        this.bkTableCache.queueStack(BK_COLUMN_UPDATE_DEFINE, fn2);
      }
    },
    updateColumnDefineByIndex(unmounted = false) {
      const resolveProp = __spreadProps(__spreadValues({}, this.$props), {
        field: this.$props.prop || this.$props.field,
        render: this.$slots.default
      });
      this.initColumns(unref(resolveProp), unmounted);
    }
  },
  render() {
    var _a, _b;
    return createVNode(Fragment, null, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
      row: {}
    })]);
  }
});
class BkTableCache {
  constructor() {
    this.storage = void 0;
    this.storage = {};
  }
  queueStack(methodName, fn2 = () => {
  }) {
    this.storage[methodName] && clearTimeout(this.storage[methodName]);
    this.storage[methodName] = setTimeout(() => fn2());
  }
  clearQueueStack(methodName) {
    this.storage[methodName] && clearTimeout(this.storage[methodName]);
  }
}
const resolvePaginationOption = (propPagination, defVal) => {
  if (!!propPagination) {
    if (typeof propPagination === "object") {
      let current = Object.prototype.hasOwnProperty.call(propPagination, "current") ? propPagination.current : propPagination.value;
      if (!/\d+/.test(current)) {
        current = 1;
      }
      return __spreadProps(__spreadValues(__spreadValues({}, defVal), propPagination), {
        current
      });
    }
    return defVal;
  }
  return {};
};
var usePagination = (props2, indexData) => {
  const startIndex = ref(0);
  const endIndex = ref(0);
  let pagination2 = reactive({
    count: 0,
    limit: 10,
    current: 1,
    align: "right",
    layout: ["total", "limit", "list"]
  });
  pagination2 = resolvePaginationOption(props2.pagination, pagination2);
  const localPagination = ref(null);
  const resetStartEndIndex = () => {
    if (!props2.pagination || props2.remotePagination) {
      startIndex.value = 0;
      endIndex.value = props2.data.length;
      return;
    }
    startIndex.value = (pagination2.current - 1) * pagination2.limit;
    endIndex.value = pagination2.current * pagination2.limit;
  };
  const pageData = reactive([]);
  const sort = (sourceData, sortFn) => {
    if (typeof sortFn === "function") {
      sourceData.sort(sortFn);
    }
  };
  const filter = (sourceData, filterFn) => {
    if (typeof filterFn === "function") {
      const filterVals = sourceData.filter((row, index2) => filterFn(row, index2, props2.data));
      sourceData.length = 0;
      sourceData.push(...filterVals);
    }
  };
  const resolvePageData = (filterFn, sortFn, activeSortColumn) => {
    var _a;
    const sourceData = indexData.slice();
    const {
      sortScope
    } = (_a = activeSortColumn == null ? void 0 : activeSortColumn.sort) != null ? _a : {};
    if (sortScope === SortScope.ALL) {
      sort(sourceData, sortFn);
    }
    pageData.length = 0;
    pageData.push(...sourceData.slice(startIndex.value, endIndex.value));
    filter(pageData, filterFn);
    sort(pageData, sortFn);
  };
  const watchEffectFn = (filterFn, sortFn, activeSortColumn) => {
    pagination2 = resolvePaginationOption(props2.pagination, pagination2);
    resolveLocalPagination();
    resetStartEndIndex();
    resolvePageData(filterFn, sortFn, activeSortColumn);
  };
  const resolveLocalPagination = () => {
    if (!props2.pagination) {
      return;
    }
    localPagination.value = props2.remotePagination ? pagination2 : __spreadProps(__spreadValues({}, pagination2), {
      count: props2.data.length
    });
  };
  return {
    pageData,
    localPagination,
    resolvePageData,
    watchEffectFn
  };
};
var useScrollLoading = (props2, ctx) => {
  const refScrollLoading = toRef(props2, "scrollLoading");
  const getLoadingOption = () => {
    if (typeof refScrollLoading.value === "boolean") {
      return {
        loading: !!refScrollLoading.value,
        inline: true,
        title: "",
        size: BkLoadingSize.Normal,
        mode: BkLoadingMode.Default,
        indicator: null
      };
    }
    return refScrollLoading.value;
  };
  const isRender = computed(() => refScrollLoading.value !== null && (typeof refScrollLoading.value === "boolean" && refScrollLoading.value || typeof refScrollLoading.value === "object"));
  const renderScrollLoading = () => {
    var _a, _b, _c;
    if (isRender.value) {
      const {
        loading: loading2,
        size,
        mode,
        title,
        inline: inline2,
        indicator
      } = getLoadingOption();
      return (_c = (_b = (_a = ctx.slots).fixedBottom) == null ? void 0 : _b.call(_a)) != null ? _c : createVNode(BkLoading, {
        loading: loading2,
        size,
        mode,
        title,
        inline: inline2,
        indicator
      }, null);
    }
  };
  return {
    renderScrollLoading
  };
};
function _isSlot$4(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
var useLimit = (t2) => {
  const {
    proxy
  } = getCurrentInstance();
  const localLimit = ref(proxy.limit);
  watch(() => proxy.limit, (limit) => {
    localLimit.value = limit;
  });
  watch(() => proxy.limitList, (limitList) => {
    nextTick(() => {
      if (!limitList.includes(localLimit.value)) {
        [localLimit.value] = limitList;
      }
    });
  }, {
    immediate: true
  });
  const handleLimitChange = (limit) => {
    localLimit.value = limit;
  };
  const render2 = ({
    isFirst,
    isLast
  }) => {
    let _slot;
    if (!proxy.showLimit) {
      return null;
    }
    return createVNode("div", mergeProps({
      "class": {
        "lesscode-bk-pagination-limit": true,
        "is-first": isFirst,
        "is-last": isLast
      }
    }, {
      disabled: proxy.disabled
    }), [createVNode("div", null, [t2.value.eachPage]), createVNode(BkSelect, {
      "class": "lesscode-bk-pagination-limit-select",
      "clearable": false,
      "size": "small",
      "withValidate": false,
      "modelValue": localLimit.value,
      "onChange": handleLimitChange,
      "disabled": proxy.disabled
    }, _isSlot$4(_slot = proxy.limitList.map((num, index2) => createVNode(BkOption, {
      "value": num,
      "label": `${num}`,
      "key": `${index2}_${num}`
    }, null))) ? _slot : {
      default: () => [_slot]
    }), createVNode("div", null, [t2.value.strip])]);
  };
  return {
    limit: localLimit,
    render: render2
  };
};
const PAGE_ITEMS_NUM = 5;
var useList = () => {
  const {
    proxy
  } = getCurrentInstance();
  const localCurrent = ref(1);
  const isPagePreDisabled = computed(() => localCurrent.value === 1);
  const isPageNextDisabled = computed(() => localCurrent.value === proxy.totalPageNum);
  const showPreBatch = ref(false);
  const showNextBatch = ref(false);
  const list = computed(() => {
    showPreBatch.value = false;
    showNextBatch.value = false;
    const stack = [];
    if (proxy.totalPageNum <= PAGE_ITEMS_NUM + 2) {
      for (let i2 = 2; i2 <= proxy.totalPageNum - 1; i2++) {
        stack.push(i2);
      }
      return stack;
    }
    const pageItemsNumHalf = Math.floor(PAGE_ITEMS_NUM / 2);
    if (proxy.totalPageNum > PAGE_ITEMS_NUM) {
      showPreBatch.value = localCurrent.value - pageItemsNumHalf > 2;
      showNextBatch.value = localCurrent.value + pageItemsNumHalf < proxy.totalPageNum - 1;
    }
    const start2 = Math.min(proxy.totalPageNum - PAGE_ITEMS_NUM, Math.max(2, localCurrent.value - pageItemsNumHalf));
    for (let i2 = start2; i2 < start2 + PAGE_ITEMS_NUM; i2++) {
      stack.push(i2);
    }
    return stack;
  });
  watch(() => proxy.modelValue, (modelValue) => {
    nextTick(() => {
      if (modelValue >= 1 && modelValue <= proxy.totalPageNum) {
        localCurrent.value = modelValue;
      } else if (modelValue < 1) {
        localCurrent.value = 1;
      } else {
        localCurrent.value = proxy.totalPageNum;
      }
    });
  }, {
    immediate: true
  });
  nextTick(() => {
    watch(() => proxy.totalPageNum, (totalPageNum) => {
      if (localCurrent.value > totalPageNum) {
        localCurrent.value = totalPageNum;
      }
    });
  });
  const handlePrePage = () => {
    if (isPagePreDisabled.value) {
      return;
    }
    localCurrent.value = localCurrent.value - 1;
  };
  const handleNextPage = () => {
    if (isPageNextDisabled.value) {
      return;
    }
    localCurrent.value = localCurrent.value + 1;
  };
  const handleItemClick = (totalPageNum) => {
    if (totalPageNum === localCurrent.value) {
      return;
    }
    localCurrent.value = totalPageNum;
  };
  const handlePreBatch = () => {
    localCurrent.value = Math.max(1, localCurrent.value - PAGE_ITEMS_NUM);
  };
  const handleNextBatch = () => {
    localCurrent.value = Math.min(proxy.totalPageNum, localCurrent.value + PAGE_ITEMS_NUM);
  };
  const render2 = ({
    isFirst,
    isLast
  }) => createVNode("div", {
    "class": {
      "lesscode-bk-pagination-list": true,
      "is-first": isFirst,
      "is-last": isLast
    }
  }, [createVNode("div", {
    "class": {
      "lesscode-bk-pagination-list-pre": true,
      "is-disabled": isPagePreDisabled.value
    },
    "onClick": handlePrePage
  }, [proxy.prevText || createVNode(angleLeft, null, null)]), createVNode("div", {
    "class": {
      "lesscode-bk-pagination-list-item": true,
      "is-active": localCurrent.value === 1
    },
    "key": "1",
    "onClick": () => handleItemClick(1)
  }, [createTextVNode("1")]), showPreBatch.value && createVNode("div", {
    "key": "pre-batch",
    "class": "lesscode-bk-pagination-list-pre-batch",
    "onClick": handlePreBatch
  }, [createVNode(ellipsis$1, null, null)]), list.value.map((num) => createVNode("div", {
    "class": {
      "lesscode-bk-pagination-list-item": true,
      "is-active": localCurrent.value === num
    },
    "key": num,
    "onClick": () => handleItemClick(num)
  }, [num])), showNextBatch.value && createVNode("div", {
    "key": "next-batch",
    "class": "lesscode-bk-pagination-list-next-batch",
    "onClick": handleNextBatch
  }, [createVNode(ellipsis$1, null, null)]), proxy.totalPageNum > 1 && createVNode("div", {
    "class": {
      "lesscode-bk-pagination-list-item": true,
      "is-active": localCurrent.value === proxy.totalPageNum
    },
    "key": "last",
    "onClick": () => handleItemClick(proxy.totalPageNum)
  }, [proxy.totalPageNum]), createVNode("div", {
    "class": {
      "lesscode-bk-pagination-list-pre": true,
      "is-disabled": isPageNextDisabled.value
    },
    "onClick": handleNextPage
  }, [proxy.nextText || createVNode(angleRight, null, null)])]);
  return {
    current: localCurrent,
    render: render2
  };
};
var useSmallList = () => {
  const {
    proxy
  } = getCurrentInstance();
  const inputRef = ref(null);
  const isFocused = ref(false);
  const localCurrent = ref(1);
  const isPagePreDisabled = computed(() => localCurrent.value === 1);
  const isPageNextDisabled = computed(() => localCurrent.value === proxy.totalPageNum);
  let inputMemo = 0;
  const list = computed(() => {
    const stack = [];
    for (let i2 = 1; i2 <= proxy.totalPageNum; i2++) {
      stack.push(i2);
    }
    return stack;
  });
  watch(() => proxy.modelValue, (modelValue) => {
    nextTick(() => {
      if (modelValue >= 1 && modelValue <= proxy.totalPageNum) {
        localCurrent.value = modelValue;
      } else if (modelValue < 1) {
        localCurrent.value = 1;
      } else {
        localCurrent.value = proxy.totalPageNum;
      }
      inputMemo = localCurrent.value;
    });
  }, {
    immediate: true
  });
  nextTick(() => {
    watch(() => proxy.totalPageNum, (totalPageNum) => {
      if (localCurrent.value > totalPageNum) {
        localCurrent.value = totalPageNum;
      }
    });
  });
  const handlePrePage = () => {
    if (isPagePreDisabled.value) {
      return;
    }
    localCurrent.value = localCurrent.value - 1;
  };
  const handleNextPage = () => {
    if (isPageNextDisabled.value) {
      return;
    }
    localCurrent.value = localCurrent.value + 1;
  };
  const handlePageEditorFocus = () => {
    isFocused.value = true;
  };
  const handlePageEditorBlur = () => {
    isFocused.value = false;
    inputRef.value.textContent = `${inputMemo}`;
    if (inputMemo !== localCurrent.value) {
      localCurrent.value = inputMemo;
    }
  };
  const handlePageEditorInput = (event) => {
    const $target = event.target;
    const value = Number($target.textContent);
    if (!value || value < 1 || value > proxy.totalPageNum || value === localCurrent.value) {
      return;
    }
    inputMemo = value;
  };
  const handlePageEditorKeydown = (event) => {
    if (["Enter", "NumpadEnter"].includes(event.code)) {
      event.preventDefault();
      handlePageEditorBlur();
    }
  };
  const handlePageChange = (item) => {
    inputMemo = item;
    handlePageEditorBlur();
  };
  const render2 = () => createVNode("div", {
    "class": "lesscode-bk-pagination-small-list"
  }, [createVNode("div", {
    "class": {
      "lesscode-bk-pagination-btn-pre": true,
      "is-disabled": isPagePreDisabled.value
    },
    "onClick": handlePrePage
  }, [createVNode(angleLeft, null, null)]), createVNode(BkPopover, {
    "theme": "light",
    "trigger": "click",
    "arrow": false,
    "width": 56,
    "boundary": "body",
    "placement": "bottom"
  }, {
    default: () => createVNode("div", {
      "class": {
        "lesscode-bk-pagination-picker": true,
        "is-focused": isFocused.value
      }
    }, [createVNode("span", {
      "ref": inputRef,
      "class": "lesscode-bk-pagination-editor",
      "contenteditable": true,
      "spellcheck": "false",
      "onFocus": handlePageEditorFocus,
      "onBlur": handlePageEditorBlur,
      "onInput": handlePageEditorInput,
      "onKeydown": handlePageEditorKeydown
    }, [localCurrent.value]), createVNode("span", null, [createTextVNode("/")]), createVNode("span", {
      "class": "lesscode-bk-pagination-small-list-total"
    }, [proxy.totalPageNum])]),
    content: () => createVNode("div", {
      "class": "lesscode-bk-pagination-picker-list"
    }, [list.value.map((item) => createVNode("div", {
      "class": {
        item: true,
        "is-actived": item === localCurrent.value
      },
      "key": item,
      "onClick": () => handlePageChange(item)
    }, [item]))])
  }), createVNode("div", {
    "class": {
      "lesscode-bk-pagination-btn-next": true,
      "is-disabled": isPageNextDisabled.value
    },
    "onClick": handleNextPage
  }, [createVNode(angleRight, null, null)])]);
  return {
    current: localCurrent,
    render: render2
  };
};
var useTotal = (t2) => ({
  isFirst,
  isLast
}) => {
  const {
    props: props2
  } = getCurrentInstance();
  if (!props2.showTotalCount) {
    return null;
  }
  return createVNode("div", mergeProps({
    "class": {
      "lesscode-bk-pagination-total": true,
      "is-first": isFirst,
      "is-last": isLast
    }
  }, {
    disabled: props2.disabled
  }), [t2.value.total, createVNode("div", {
    "class": "lesscode-bk-pagination-total-num"
  }, [props2.count]), t2.value.strip]);
};
const paginationProps = {
  modelValue: PropTypes.number.def(1),
  count: PropTypes.number.def(0).isRequired,
  limit: PropTypes.number.def(10),
  limitList: PropTypes.arrayOf(Number).def([10, 20, 50, 100]),
  showLimit: PropTypes.bool.def(true),
  type: PropTypes.oneOf(["default", "compact"]).def("default"),
  location: PropTypes.oneOf(["left", "right"]).def("right"),
  align: PropTypes.oneOf(["left", "center", "right"]).def("left"),
  size: PropTypes.size(),
  small: PropTypes.bool.def(false),
  showTotalCount: PropTypes.bool.def(true),
  prevText: PropTypes.string,
  nextText: PropTypes.string,
  disabled: PropTypes.bool.def(false),
  beforeChange: PropTypes.func,
  layout: PropTypes.custom((value) => {
    const layoutNameMap = {
      total: true,
      list: true,
      limit: true
    };
    return value.some((item) => layoutNameMap[item]);
  }, "layout \u7684\u503C\u53EA\u652F\u6301 * total\u3001list\u3001limit *").def(["total", "list", "limit"])
};
var Component$g = defineComponent({
  name: "Pagination",
  props: paginationProps,
  emits: ["update:modelValue", "change", "update:limit", "limitChange"],
  setup(props2, context) {
    const t2 = useLocale("pagination");
    const totalPageNum = ref(0);
    const {
      count,
      limit
    } = toRefs(props2);
    const renderTotal = useTotal(t2);
    const {
      current: listCurrent,
      render: renderList
    } = useList();
    const {
      current: smallListCurrent,
      render: renderSmallList
    } = useSmallList();
    const {
      limit: localLimit,
      render: renderLimit
    } = useLimit(t2);
    watch([count, localLimit, limit], ([count2, localLimit2]) => {
      const total2 = Math.ceil(count2 / localLimit2);
      totalPageNum.value = total2 < 1 ? 1 : total2;
    }, {
      immediate: true
    });
    watch(listCurrent, (listCurrent2) => {
      context.emit("update:modelValue", listCurrent2);
      context.emit("change", listCurrent2);
    });
    watch(smallListCurrent, (smallListCurrent2) => {
      if (!props2.small) {
        return;
      }
      context.emit("update:modelValue", smallListCurrent2);
      context.emit("change", smallListCurrent2);
    });
    watch(localLimit, (localLimit2) => {
      context.emit("limitChange", localLimit2);
    });
    return {
      totalPageNum,
      renderTotal,
      renderList,
      renderLimit,
      renderSmallList
    };
  },
  render() {
    const paginationClass = classes({
      "lesscode-bk-pagination": true,
      [`lesscode-bk-pagination--${this.size}`]: true,
      [`is-align-${this.align}`]: true
    });
    const layoutMap = {
      total: this.renderTotal,
      list: this.small ? this.renderSmallList : this.renderList,
      limit: this.renderLimit
    };
    return createVNode("div", {
      "class": paginationClass
    }, [this.layout.map((layout, index2) => layoutMap[layout]({
      isFirst: index2 === 0,
      isLast: index2 === this.layout.length - 1
    }))]);
  }
});
const BkPagination = withInstall(Component$g);
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key2) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key2) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key2) {
      var index2 = getIndex(this.__entries__, key2);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key2, value) {
      var index2 = getIndex(this.__entries__, key2);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key2, value]);
      }
    };
    class_1.prototype.delete = function(key2) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key2);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key2) {
      return !!~getIndex(this.__entries__, key2);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key2) {
      return !!~propertyName.indexOf(key2);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props2) {
  for (var _i = 0, _a = Object.keys(props2); _i < _a.length; _i++) {
    var key2 = _a[_i];
    Object.defineProperty(target, key2, {
      value: props2[key2],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$1 = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver$1.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$1;
}();
const resolvePropVal = (prop, key2, args) => {
  if (typeof key2 === "string") {
    if (Object.prototype.hasOwnProperty.call(prop, key2)) {
      if (typeof prop[key2] === "function") {
        return prop[key2].call(globalThis, ...args);
      }
      return prop[key2];
    }
    return void 0;
  }
  if (Array.isArray(key2)) {
    return key2.map((_key) => resolvePropVal(prop, _key, args)).filter((val) => val !== void 0).at(0);
  }
};
const resolveNumberToNumArray = (prop) => {
  if (/^\d+$/.test(`${prop}`)) {
    return [parseInt(`${prop}`, 10)];
  }
  return [];
};
const resolveWidth = (propWidth) => resolveNumberOrStringToPix(propWidth, "auto");
const resolveNumberOrStringToPix = (val, defaultValue = "100%", offset2 = null) => {
  let target = "";
  if (/^auto|null|undefined$/ig.test(`${val}`)) {
    target = defaultValue;
  } else {
    target = /^\d+\.?\d+$/.test(`${val}`) ? `${val}px` : val;
  }
  if (offset2) {
    target = `calc(${target} - ${offset2})`;
  }
  return target;
};
const resolvePropBorderToClassStr = (val) => {
  const defaultVal = ["row"];
  if (typeof val === "string") {
    defaultVal.push(val);
  }
  if (Array.isArray(val)) {
    defaultVal.push(...val.filter((str) => BORDER_OPTIONS.includes(str)));
  }
  return [...new Set(defaultVal)].map((item) => `bordered-${item}`).join(" ");
};
const getColumnReactWidth = (colmun, orders = ["resizeWidth", "calcWidth", "width"]) => {
  var _a, _b;
  return (_b = (_a = colmun[orders[0]]) != null ? _a : colmun[orders[1]]) != null ? _b : colmun[orders[2]];
};
const resolveColumnWidth = (root, colgroups, autoWidth = COL_MIN_WIDTH, offsetWidth = 0) => {
  const {
    width
  } = root.getBoundingClientRect() || {};
  const availableWidth = width - offsetWidth;
  let avgWidth = availableWidth;
  const avgColIndexList = [];
  const getMinWidth = (col, computedWidth) => {
    const {
      minWidth = void 0
    } = col;
    if (minWidth === void 0) {
      if (computedWidth < COL_MIN_WIDTH) {
        return COL_MIN_WIDTH;
      }
      return computedWidth;
    }
    let calcMinWidth = computedWidth;
    if (/^\d+\.?\d*$/.test(`${minWidth}`)) {
      calcMinWidth = Number(minWidth);
    }
    if (/^\d+\.?\d*%$/.test(`${minWidth}`)) {
      calcMinWidth = Number(minWidth) * availableWidth / 100;
    }
    if (/^\d+\.?\d*px$/i.test(`${minWidth}`)) {
      calcMinWidth = Number(`${minWidth}`.replace(/px/i, ""));
    }
    return calcMinWidth;
  };
  const resolveColNumberWidth = (col, numWidth, resetAvgWidth = true) => {
    const minWidth = getMinWidth(col, numWidth);
    const computedWidth = numWidth < minWidth ? minWidth : numWidth;
    Object.assign(col, {
      calcWidth: computedWidth
    });
    if (resetAvgWidth) {
      avgWidth = avgWidth - computedWidth;
      if (avgWidth < 0) {
        avgWidth = 0;
      }
    }
  };
  colgroups.forEach((col, index2) => {
    if (!col.isHidden) {
      const order2 = ["resizeWidth", "width"];
      const colWidth = String(getColumnReactWidth(col, order2));
      let isAutoWidthCol = true;
      if (/^\d+\.?\d*(px)?$/.test(colWidth)) {
        const numWidth = Number(colWidth.replace("px", ""));
        resolveColNumberWidth(col, numWidth);
        isAutoWidthCol = false;
      }
      if (/^\d+\.?\d*%$/.test(colWidth)) {
        let perWidth = autoWidth;
        if (avgWidth > 0) {
          const percent = Number(colWidth.replace("%", ""));
          perWidth = avgWidth * percent / 100;
        }
        resolveColNumberWidth(col, perWidth);
        isAutoWidthCol = false;
      }
      if (isAutoWidthCol) {
        avgColIndexList.push(index2);
      }
    }
  });
  if (avgColIndexList.length > 0) {
    let autoAvgWidth = autoWidth;
    if (avgWidth > 0) {
      avgColIndexList.forEach((idx, index2) => {
        autoAvgWidth = avgWidth / (avgColIndexList.length - index2);
        resolveColNumberWidth(colgroups[idx], autoAvgWidth, false);
        const {
          calcWidth
        } = colgroups[idx];
        avgWidth = avgWidth - calcWidth;
      });
    } else {
      avgColIndexList.forEach((idx) => {
        const calcWidth = getMinWidth(colgroups[idx], COL_MIN_WIDTH);
        Object.assign(colgroups[idx], {
          calcWidth
        });
      });
    }
  }
};
const observerResize = (root, callbackFn, delay = 60, immediate = false, resizerWay = "throttle") => {
  const resolveCallbackFn = () => {
    if (typeof callbackFn === "function") {
      callbackFn();
    }
  };
  const execFn = resizerWay === "debounce" ? lodash.exports.debounce(resolveCallbackFn, delay) : lodash.exports.throttle(resolveCallbackFn, delay);
  const callFn = () => Reflect.apply(execFn, globalThis, []);
  const resizeObserver = new index(() => {
    callFn();
  });
  if (immediate) {
    if (typeof callbackFn === "function") {
      callbackFn();
    }
  }
  return {
    start: () => {
      resizeObserver.observe(root);
    },
    disconnect: () => {
      resizeObserver.unobserve(root);
      resizeObserver.disconnect();
    }
  };
};
const resolveHeadConfig = (props2) => {
  const {
    showHead,
    headHeight,
    thead = {}
  } = props2;
  return Object.assign({}, {
    isShow: showHead,
    height: headHeight
  }, __spreadValues({}, thead));
};
const getRowText = (row, key2, column) => {
  if (column.type === "index") {
    return row[TABLE_ROW_ATTRIBUTE.ROW_INDEX] + 1;
  }
  return lodash.exports.get(row, key2);
};
const formatPropAsArray = (prop, args) => {
  if (Array.isArray(prop)) {
    return prop;
  }
  if (typeof prop === "string" || typeof prop === "object") {
    return [prop];
  }
  if (typeof prop === "function") {
    return formatPropAsArray(Reflect.apply(prop, globalThis, args), args);
  }
  return [];
};
const getRowKey = (item, props2, index2) => {
  if (typeof props2.rowKey === "string") {
    if (props2.rowKey === TABLE_ROW_ATTRIBUTE.ROW_INDEX) {
      return `__ROW_INDEX_${index2}`;
    }
    return lodash.exports.get(item, props2.rowKey);
  }
  if (typeof props2.rowKey === "function") {
    return Reflect.apply(props2.rowKey, globalThis, [item]);
  }
  return uuid_1.v4();
};
const hasRootScrollY = (root, querySelector, offsetHeight = 0) => {
  if (root) {
    const tableBody = root.querySelector(querySelector);
    if (tableBody) {
      return tableBody.offsetHeight > root.offsetHeight - offsetHeight;
    }
  }
  return false;
};
const isColumnHidden = (settingFields, column, checked) => {
  const isSettingField = (col) => settingFields.some((field) => field.field === resolvePropVal(col, ["field", "type"], [col]));
  return isSettingField(column) && checked.length && !checked.includes(resolvePropVal(column, ["field", "type"], [column]));
};
const resolveColumnSpan = (column, colIndex, row, rowIndex, key2) => {
  if (typeof column[key2] === "function") {
    return Reflect.apply(column[key2], globalThis, [{
      column,
      colIndex,
      row,
      rowIndex
    }]);
  }
  if (typeof column[key2] === "number") {
    return column[key2];
  }
  return 1;
};
const resolveCellSpan = (column, colIndex, row, rowIndex) => {
  const colspan = resolveColumnSpan(column, colIndex, row, rowIndex, "colspan");
  const rowspan = resolveColumnSpan(column, colIndex, row, rowIndex, "rowspan");
  return {
    colspan,
    rowspan
  };
};
const getSortFn = (column, sortType) => {
  var _a, _b;
  const fieldName = column.field;
  const getVal = (row) => getRowText(row, fieldName, column);
  const sortFn0 = (a2, b2) => {
    const val0 = getVal(a2) || "";
    const val1 = getVal(b2) || "";
    if (typeof val0 === "number" && typeof val1 === "number") {
      return val0 - val1;
    }
    return String.prototype.localeCompare.call(val0, val1);
  };
  const sortFn = typeof ((_a = column.sort) == null ? void 0 : _a.sortFn) === "function" ? (_b = column.sort) == null ? void 0 : _b.sortFn : sortFn0;
  return sortType === SORT_OPTION.NULL ? () => true : (_a2, _b2) => sortFn(_a2, _b2) * (sortType === SORT_OPTION.DESC ? -1 : 1);
};
const getNextSortType = (sortType) => {
  const steps2 = {
    [SORT_OPTION.NULL]: 0,
    [SORT_OPTION.ASC]: 1,
    [SORT_OPTION.DESC]: 2
  };
  if (sortType === void 0) {
    return SORT_OPTION.NULL;
  }
  return Object.keys(steps2)[(steps2[sortType] + 1) % 3];
};
const resolveSort = (sort) => {
  if (typeof sort === "string") {
    return {
      value: sort
    };
  }
  if (typeof sort === "boolean" && sort) {
    return {
      value: SORT_OPTION.NULL
    };
  }
  if (typeof sort === "object" && sort !== null) {
    if (typeof sort.sortFn) {
      return __spreadValues({
        value: "custom"
      }, sort);
    }
    return sort;
  }
  return null;
};
const isRowSelectEnable = (props2, {
  row,
  index: index2,
  isCheckAll
}) => {
  if (typeof props2.isRowSelectEnable === "boolean") {
    return props2.isRowSelectEnable !== false;
  }
  if (typeof props2.isRowSelectEnable === "function") {
    return props2.isRowSelectEnable({
      row,
      index: index2,
      isCheckAll
    });
  }
  return true;
};
const getRowId = (row, index2, props2) => {
  if (row[TABLE_ROW_ATTRIBUTE.ROW_UID] !== void 0) {
    return row[TABLE_ROW_ATTRIBUTE.ROW_UID];
  }
  const key2 = getRowKey(row, props2, index2);
  if (key2 !== void 0 && row[key2] !== void 0) {
    return row[key2];
  }
  return index2;
};
const getRowSourceData = (row) => unref(row[TABLE_ROW_ATTRIBUTE.ROW_SOURCE_DATA] || row);
const getColumnSourceData = (column) => unref(column[COLUMN_ATTRIBUTE.COL_SOURCE_DATA] || column);
var TableCell = defineComponent({
  name: "TableCell",
  props: {
    column: PropTypes.any.def({}),
    row: PropTypes.any.def({}),
    parentSetting: PropTypes.oneOfType([PropTypes.bool, PropTypes.shape({
      content: PropTypes.string.def(""),
      disabled: PropTypes.bool.def(false),
      watchCellResize: PropTypes.bool.def(true),
      mode: overflowModeType
    })]).def(void 0),
    title: PropTypes.string.def(void 0),
    observerResize: PropTypes.bool.def(true),
    resizerWay: j("ResizerWay", {
      default: ResizerWay.DEBOUNCE
    })
  },
  setup(props2, {
    slots
  }) {
    const refRoot = ref();
    const isTipsEnabled = ref(false);
    const cellStyle = computed(() => ({
      textAlign: props2.column.textAlign
    }));
    const resolveSetting = () => {
      if (/boolean|object/.test(typeof props2.column.showOverflowTooltip) && props2.column.showOverflowTooltip !== null) {
        return props2.column;
      }
      return {
        showOverflowTooltip: props2.parentSetting
      };
    };
    const {
      showOverflowTooltip = false
    } = resolveSetting();
    let bkEllipsisIns = null;
    const resolveTooltipOption = () => {
      let disabled = true;
      let {
        resizerWay
      } = props2;
      let content = refRoot.value.innerText;
      let mode = "auto";
      let watchCellResize = true;
      if (typeof showOverflowTooltip === "boolean") {
        disabled = !showOverflowTooltip;
      }
      if (typeof showOverflowTooltip === "object") {
        disabled = showOverflowTooltip.disabled;
        resizerWay = showOverflowTooltip.resizerWay || "debounce";
        content = showOverflowTooltip.content || refRoot.value.innerText;
        if (typeof showOverflowTooltip.content === "function") {
          content = showOverflowTooltip.content(props2.column, props2.row);
        }
        watchCellResize = showOverflowTooltip.watchCellResize;
        mode = showOverflowTooltip.mode || "auto";
      }
      if (typeof disabled === "function") {
        disabled = Reflect.apply(disabled, this, [props2.column, props2.row]);
      }
      return {
        disabled,
        content,
        mode,
        resizerWay,
        watchCellResize
      };
    };
    const resolveOverflowTooltip = () => {
      if (!refRoot.value || !isElement$4(refRoot.value)) {
        return;
      }
      const {
        mode,
        disabled
      } = resolveTooltipOption();
      isTipsEnabled.value = !disabled;
      if (mode === "auto") {
        isTipsEnabled.value = hasOverflowEllipsis(refRoot.value);
      }
      if (mode === "static") {
        isTipsEnabled.value = true;
      }
      if (isTipsEnabled.value) {
        const bindings = ref(resolveTooltipOption());
        if (bkEllipsisIns === null) {
          bkEllipsisIns = createInstance(refRoot.value, {
            disabled: bindings.value.disabled,
            content: bindings.value.content,
            mode: bindings.value.mode
          });
        }
      } else {
        bkEllipsisIns == null ? void 0 : bkEllipsisIns.destroyInstance(refRoot.value);
        bkEllipsisIns = null;
      }
    };
    onMounted(() => {
      const {
        disabled,
        resizerWay,
        watchCellResize
      } = resolveTooltipOption();
      if (!disabled) {
        resolveOverflowTooltip();
        if (watchCellResize !== false && props2.observerResize) {
          let observerIns = observerResize(refRoot.value, () => {
            resolveOverflowTooltip();
          }, 60, true, resizerWay);
          observerIns.start();
          onBeforeUnmount(() => {
            observerIns.disconnect();
            observerIns = null;
          });
        }
      }
    });
    onBeforeUnmount(() => {
      bkEllipsisIns == null ? void 0 : bkEllipsisIns.destroyInstance(refRoot.value);
    });
    return () => {
      var _a;
      return createVNode("div", {
        "class": ["cell", props2.column.type],
        "style": cellStyle.value,
        "ref": refRoot,
        "title": props2.title
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var TableRow = defineComponent({
  name: "TableRow",
  render() {
    var _a, _b;
    return createVNode(Fragment, null, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)]);
  }
});
class TablePlugins {
  constructor(props2, ctx) {
    __publicField(this, "props", null);
    __publicField(this, "ctx", null);
    this.props = props2;
    this.ctx = ctx;
  }
}
var BodyEmpty = defineComponent({
  name: "BodyEmpty",
  props: {
    list: PropTypes.array.def([]),
    filterList: PropTypes.array.def([]),
    emptyText: PropTypes.string
  },
  emits: ["change"],
  setup(props2) {
    const t2 = useLocale("table");
    const localEmptyText = computed(() => {
      if (props2.emptyText === void 0) {
        return t2.value.emptyText;
      }
      return props2.emptyText;
    });
    const type = computed(() => props2.list.length === 0 ? "empty" : "search-empty");
    return () => createVNode(BkException, {
      "scene": "part",
      "type": type.value,
      "description": localEmptyText.value
    }, null);
  }
});
var HeadFilter = defineComponent({
  name: "HeadFilter",
  props: {
    column: PropTypes.any.def({}),
    height: PropTypes.number.def(LINE_HEIGHT)
  },
  emits: ["change", "filterSave"],
  setup(props2, {
    emit
  }) {
    var _a, _b;
    const t2 = useLocale("table");
    const {
      column
    } = props2;
    const {
      filter
    } = toRefs(props2.column);
    const checked = ref((_b = (_a = filter.value) == null ? void 0 : _a.checked) != null ? _b : []);
    const state = reactive({
      isOpen: false,
      checked: checked.value
    });
    const headClass = computed(() => classes({
      [resolveClassName("table-head-action")]: true,
      "column-filter": true,
      "--row-height": `${props2.height}px`,
      active: state.checked.length,
      opened: state.isOpen
    }));
    const headFilterContentClass = classes({
      [resolveClassName("table-head-filter")]: true
    });
    const refVirtualRender = ref(null);
    const handlePopShow = (isOpen) => {
      state.isOpen = isOpen;
      isOpen && setTimeout(() => {
        refVirtualRender.value.reset();
      });
    };
    const theme = `light ${resolveClassName("table-head-filter")}`;
    const localData = computed(() => {
      const {
        list = []
      } = filter.value;
      return list;
    });
    const getRegExp = (searchValue, flags = "ig") => new RegExp(`${searchValue}`.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), flags);
    const defaultFilterFn = (checked2, row) => {
      const {
        match: match2
      } = filter.value;
      const matchText = getRowText(row, resolvePropVal(column, "field", [column, row]), column);
      if (match2 === "full") {
        checked2.includes(matchText);
      }
      return checked2.some((str) => getRegExp(str, "img").test(matchText));
    };
    const filterFn = typeof filter.value.filterFn === "function" ? (checked2, row, index2, data2) => filter.value.filterFn(checked2, row, props2.column, index2, data2) : (checked2, row) => checked2.length ? defaultFilterFn(checked2, row) : true;
    const handleBtnSaveClick = () => {
      handleFilterChange(true);
      emit("filterSave", [...state.checked]);
      state.isOpen = false;
    };
    const handleFilterChange = (btnSaveClick = false) => {
      const {
        disabled
      } = resolveBtnOption(btnSave, t2.value.confirm);
      if (disabled || btnSaveClick) {
        if (filter.value === "custom") {
          emit("change", [...state.checked], null);
          state.isOpen = false;
          return;
        }
        filter.value.checked = state.checked;
        emit("change", [...state.checked], filterFn);
      }
    };
    const handleBtnResetClick = () => {
      if (state.checked.length) {
        state.checked.length = 0;
        state.isOpen = false;
        nextTick(() => emit("change", state.checked, filterFn));
      }
    };
    const resolveBtnOption = (opt, defText) => {
      const disabled = opt === "disabled" || opt === false;
      const text = typeof opt === "string" ? opt : defText;
      return {
        disabled,
        text
      };
    };
    const {
      btnSave,
      btnReset
    } = filter.value;
    const renderSaveBtn = () => {
      const {
        disabled,
        text
      } = resolveBtnOption(btnSave, t2.value.confirm);
      if (disabled) {
        return createVNode("span", {
          "class": "btn-filter-save disabled"
        }, [text]);
      }
      return createVNode("span", {
        "class": "btn-filter-save",
        "onClick": handleBtnSaveClick
      }, [text]);
    };
    const renderResetBtn = () => {
      const {
        disabled,
        text
      } = resolveBtnOption(btnReset, t2.value.reset);
      if (disabled) {
        return "";
      }
      return createVNode("span", {
        "class": ["btn-filter-reset", state.checked.length ? "" : "disable"],
        "onClick": handleBtnResetClick
      }, [text]);
    };
    const handleValueChange = (val, item) => {
      const setValue = new Set(state.checked);
      if (val) {
        setValue.add(item.value);
      } else {
        setValue.delete(item.value);
      }
      state.checked.length = 0;
      state.checked.push(...Array.from(setValue));
      handleFilterChange();
    };
    const renderFilterList = (scope) => {
      if (scope.data.length) {
        return scope.data.map((item) => createVNode("div", {
          "class": "list-item"
        }, [createVNode(BkCheckbox, {
          "label": item.value,
          "key": item.$index,
          "immediateEmitChange": false,
          "checked": state.checked.includes(item.value),
          "modelValue": state.checked.includes(item.value),
          "onChange": (val) => handleValueChange(val, item)
        }, {
          default: () => [`${item.text}`]
        })]));
      }
      return createVNode("div", {
        "class": "list-item is-empty"
      }, [t2.value.emptyText]);
    };
    return () => createVNode(BkPopover, mergeProps({
      "trigger": "click",
      "isShow": state.isOpen,
      "placement": "bottom-start",
      "renderType": RenderType.SHOWN,
      "arrow": false,
      "offset": 0
    }, {
      theme
    }, {
      "onAfterShow": () => handlePopShow(true),
      "onAfterHidden": () => handlePopShow(false)
    }), {
      default: () => createVNode(funnel, {
        "class": headClass.value
      }, null),
      content: () => createVNode("div", {
        "class": headFilterContentClass
      }, [createVNode(BkCheckboxGroup, {
        "class": "content-list"
      }, {
        default: () => [createVNode(BkVirtualRender, {
          "lineHeight": 32,
          "list": localData.value,
          "throttleDelay": 0,
          "scrollEvent": true,
          "ref": refVirtualRender,
          "className": "content-items"
        }, {
          default: renderFilterList
        })]
      }), createVNode("div", {
        "class": "content-footer"
      }, [renderSaveBtn(), createVNode("span", {
        "class": "btn-filter-split"
      }, null), renderResetBtn()])])
    });
  }
});
var HeadSort = defineComponent({
  name: "HeadSort",
  props: {
    column: PropTypes.any.def({}),
    defaultSort: PropTypes.oneOf(SORT_OPTIONS).def(SORT_OPTION.NULL),
    active: PropTypes.bool
  },
  emits: ["change"],
  setup(props2, {
    emit
  }) {
    var _a, _b;
    const defSort = ((_b = (_a = props2.column) == null ? void 0 : _a.sort) == null ? void 0 : _b.value) || props2.defaultSort || SORT_OPTION.NULL;
    const sortType = ref(defSort);
    watch(() => [props2.defaultSort], ([val]) => {
      sortType.value = val;
    });
    const handleSortClick = (e, type) => {
      var _a2;
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
      let currentSort = type;
      if (type === SORT_OPTION.NULL) {
        currentSort = getNextSortType(type);
      }
      if (sortType.value === type) {
        currentSort = SORT_OPTION.NULL;
      }
      const execFn = getSortFn(props2.column, currentSort);
      const sort = resolveSort(props2.column.sort);
      if ((sort == null ? void 0 : sort.value) === "custom") {
        emit("change", (_a2 = sort == null ? void 0 : sort.sortFn) != null ? _a2 : execFn, currentSort);
        return;
      }
      emit("change", execFn, currentSort);
    };
    return () => createVNode("span", {
      "class": resolveClassName("head-cell-sort"),
      "onClick": (e) => handleSortClick(e, SORT_OPTION.NULL)
    }, [createVNode(angleDownFill, {
      "class": ["sort-action", "sort-asc", props2.active && sortType.value === SORT_OPTION.ASC ? "active" : ""],
      "style": "align-items: flex-end;",
      "onClick": (e) => handleSortClick(e, SORT_OPTION.ASC)
    }, null), createVNode(angleUpFill, {
      "class": ["sort-action", "sort-desc", props2.active && sortType.value === SORT_OPTION.DESC ? "active" : ""],
      "style": "align-items: flex-start;",
      "onClick": (e) => handleSortClick(e, SORT_OPTION.DESC)
    }, null)]);
  }
});
function _isSlot$3(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
var Settings = defineComponent({
  name: "Settings",
  props: {
    settings: PropTypes.oneOfType([PropTypes.shape({
      fields: PropTypes.arrayOf(PropTypes.shape({
        label: PropTypes.string,
        field: PropTypes.string,
        disabled: PropTypes.bool
      })),
      checked: PropTypes.arrayOf(PropTypes.string),
      limit: PropTypes.number.def(0),
      size: settingSizeType.def(SettingSizeEnum.SMALL),
      sizeList: PropTypes.shape([]),
      showLineHeight: PropTypes.bool.def(true)
    }), PropTypes.bool]).def(false),
    columns: PropTypes.array.def([]),
    rowHeight: PropTypes.number.def(LINE_HEIGHT)
  },
  emits: ["change"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("table");
    const defaultSizeList = createDefaultSizeList(t2);
    const resolvedColVal = (item, index2) => resolvePropVal(item, ["field", "type"], [item, index2]);
    const checkAll = ref(false);
    const isShow = ref(false);
    const localSettings = computed(() => {
      if (typeof props2.settings === "boolean") {
        return {
          fields: props2.columns.map((col) => __spreadProps(__spreadValues({}, col), {
            field: col.field || col.type
          })),
          checked: [],
          limit: 0,
          size: "small",
          sizeList: defaultSizeList,
          showLineHeight: true
        };
      }
      return props2.settings;
    });
    const activeSize = ref(localSettings.value.size || "small");
    const activeHeight = ref(props2.rowHeight);
    const checkedFields = ref(localSettings.value.checked || []);
    const className = resolveClassName("table-settings");
    const theme = `light ${className}`;
    const renderFields = computed(() => localSettings.value.fields || props2.columns || []);
    const cachedValue = {
      checkAll: checkAll.value,
      activeSize: activeSize.value,
      activeHeight: activeHeight.value,
      checkedFields: localSettings.value.checked || []
    };
    const handleSaveClick = () => {
      Object.assign(cachedValue, {
        checkAll: checkAll.value,
        activeSize: activeSize.value,
        activeHeight: activeHeight.value,
        checkedFields: checkedFields.value
      });
      emit("change", {
        checked: checkedFields.value,
        size: activeSize.value,
        height: activeHeight.value,
        fields: unref(renderFields)
      });
      isShow.value = false;
    };
    const handleCancelClick = () => {
      checkAll.value = cachedValue.checkAll;
      activeSize.value = cachedValue.activeSize;
      activeHeight.value = cachedValue.activeHeight;
      checkedFields.value = cachedValue.checkedFields;
      isShow.value = false;
    };
    const handleSettingClick = () => {
      isShow.value = true;
    };
    const handleCheckAllClick = (e) => {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
      checkAll.value = !checkAll.value;
      const fields = localSettings.value.fields || props2.columns || [];
      const readonlyFields = fields.filter((f2, index2) => f2.disabled && checkedFields.value.includes(resolvedColVal(f2, index2))).map((item, index2) => resolvedColVal(item, index2));
      if (checkAll.value) {
        const allFields = fields.filter((f2) => !f2.disabled).map((item, index2) => resolvedColVal(item, index2));
        checkedFields.value.splice(0, checkedFields.value.length, ...allFields, ...readonlyFields);
      } else {
        checkedFields.value.splice(0, checkedFields.value.length, ...readonlyFields);
      }
    };
    const isLimit = computed(() => {
      var _a;
      return ((_a = localSettings.value.limit) != null ? _a : 0) > 0;
    });
    const sizeList = localSettings.value.sizeList || defaultSizeList;
    const isFiledDisabled = computed(() => isLimit.value && (localSettings.value.limit ? localSettings.value.limit : 0) <= checkedFields.value.length);
    const isItemReadonly = (item, index2) => item.disabled || isFiledDisabled.value && !checkedFields.value.includes(resolvedColVal(item, index2));
    const handleSizeItemClick = (item) => {
      activeSize.value = item.value;
      activeHeight.value = item.height;
    };
    const getItemClass = (item) => ({
      "line-size": true,
      "is-medium": activeSize.value === "medium",
      active: item.value === activeSize.value
    });
    const buttonStyle = {
      marginRight: "12px"
    };
    const renderSize = () => sizeList.map((item) => createVNode("span", {
      "class": getItemClass(item),
      "onClick": () => handleSizeItemClick(item)
    }, [item.label]));
    const indeterminate = computed(() => checkedFields.value.length > 0 && !renderFields.value.every((field, index2) => checkedFields.value.includes(resolvePropVal(field, "field", [field, index2]))));
    const showLineHeight = computed(() => typeof localSettings.value.showLineHeight === "boolean" ? localSettings.value.showLineHeight : true);
    watch(() => [checkedFields.value], () => {
      if (!checkedFields.value.length) {
        checkAll.value = false;
      }
      if (checkedFields.value.length && renderFields.value.every((field, index2) => checkedFields.value.includes(resolvedColVal(field, index2)))) {
        checkAll.value = true;
      }
    }, {
      immediate: true,
      deep: true
    });
    watch(() => [props2.settings.checked], () => {
      checkedFields.value.splice(0, checkedFields.value.length, ...localSettings.value.checked);
    }, {
      immediate: true,
      deep: true
    });
    return () => props2.settings ? createVNode(BkPopover, mergeProps({
      "trigger": "manual",
      "isShow": isShow.value,
      "placement": "bottom-end",
      "arrow": true
    }, {
      theme
    }), {
      default: () => createVNode("span", {
        "class": "table-head-settings",
        "onClick": handleSettingClick
      }, [createVNode(cogShape, {
        "style": "color: #c4c6cc;"
      }, null)]),
      content: () => {
        let _slot2;
        return createVNode("div", {
          "class": "setting-content"
        }, [createVNode("div", {
          "class": "setting-head"
        }, [createVNode("span", {
          "class": "head-title"
        }, [t2.value.setting.title]), createVNode(closeLine, {
          "class": "icon-close-action",
          "onClick": handleCancelClick
        }, null)]), createVNode("div", {
          "class": "setting-body"
        }, [createVNode("div", {
          "class": "setting-body-title"
        }, [createVNode("div", null, [createVNode("span", {
          "class": "field-setting-label"
        }, [t2.value.setting.fields.title]), isLimit.value ? createVNode("span", {
          "class": "limit"
        }, [t2.value.setting.fields.subtitle(localSettings.value.limit)]) : ""]), isLimit.value ? "" : createVNode("span", {
          "class": "check-all",
          "onClick": handleCheckAllClick
        }, [createVNode(BkCheckbox, {
          "label": t2.value.setting.fields.selectAll,
          "indeterminate": Boolean(indeterminate.value),
          "modelValue": checkedFields.value.length > 0
        }, {
          default: () => [t2.value.setting.fields.selectAll]
        })])]), createVNode(BkCheckboxGroup, {
          "class": "setting-body-fields",
          "modelValue": checkedFields.value,
          "onUpdate:modelValue": ($event) => checkedFields.value = $event
        }, _isSlot$3(_slot2 = renderFields.value.map((item, index2) => {
          let _slot;
          return createVNode("div", {
            "class": "field-item"
          }, [createVNode(BkCheckbox, {
            "checked": checkedFields.value.includes(resolvedColVal(item, index2)),
            "label": resolvedColVal(item, index2),
            "disabled": isItemReadonly(item, index2)
          }, _isSlot$3(_slot = resolvePropVal(item, "label", [item, index2])) ? _slot : {
            default: () => [_slot]
          })]);
        })) ? _slot2 : {
          default: () => [_slot2]
        }), showLineHeight.value ? createVNode("div", {
          "class": "setting-body-line-height"
        }, [t2.value.setting.lineHeight.title, createTextVNode("\uFF1A"), renderSize()]) : ""]), createVNode("div", {
          "class": "setting-footer"
        }, [createVNode(BkButton, {
          "theme": "primary",
          "style": buttonStyle,
          "onClick": handleSaveClick
        }, {
          default: () => [t2.value.setting.options.ok]
        }), createVNode(BkButton, {
          "style": buttonStyle,
          "onClick": handleCancelClick
        }, {
          default: () => [t2.value.setting.options.cancel]
        })])]);
      }
    }) : "";
  }
});
var useFixedColumn = (_props, colgroups, hasScrollY) => {
  const resolveColumnClass = (column, scrollX, offsetRight) => ({
    column_fixed: !!column.fixed,
    column_fixed_left: column.fixed !== "right",
    column_fixed_right: column.fixed === "right",
    shadow: column.fixed === "right" ? offsetRight - scrollX > 2 : scrollX > 0
  });
  const resolveFixColPos = (column) => column.fixed === "right" ? "right" : "left";
  const resolveFixOffset = {
    left: (ignoreFirst = true) => colgroups.filter((col) => !col.isHidden && col.fixed && col.fixed !== "right").reduce((offset2, curr, index2) => {
      const outOffset = ignoreFirst && index2 === 0 ? offset2 : offset2 + getColumnReactWidth(curr);
      return outOffset;
    }, 0),
    right: (ignoreFirst = true) => colgroups.filter((col) => !col.isHidden && col.fixed === "right").reduce((offset2, curr, index2) => {
      const outOffset = ignoreFirst && index2 === 0 ? offset2 : offset2 + getColumnReactWidth(curr);
      return outOffset;
    }, hasScrollY ? SCROLLY_WIDTH : 0)
  };
  const getPreColumnOffset = (fixedPos, column, offset2 = 0) => {
    const sourceId = column[COLUMN_ATTRIBUTE.COL_UID];
    const opt = fixedPos === "right" ? -1 : 1;
    const filterColumns = colgroups.filter((col) => !col.isHidden);
    const {
      length
    } = filterColumns;
    let start2 = fixedPos === "right" ? length * opt : 1;
    let preOffset = 0;
    for (start2; ; ) {
      start2 = start2 + -1 * opt;
      const index2 = Math.abs(start2);
      const current = filterColumns[index2];
      const curFixedPos = resolveFixColPos(current);
      const id = current[COLUMN_ATTRIBUTE.COL_UID];
      if (curFixedPos === fixedPos && sourceId !== id) {
        const width = getColumnReactWidth(current);
        preOffset = preOffset + width;
      }
      if (sourceId === id) {
        break;
      }
    }
    return preOffset + offset2;
  };
  const resolveFixedColumnStyle = (column, hasScrollY2 = false) => {
    if (!column.fixed || column.isHidden) {
      return {};
    }
    const fixedOffset = {
      left: 0,
      right: hasScrollY2 ? SCROLLY_WIDTH : -1
    };
    const fixedPos = resolveFixColPos(column);
    fixedOffset[fixedPos] = getPreColumnOffset(fixedPos, column, fixedOffset[fixedPos]);
    return {
      [fixedPos]: `${fixedOffset[fixedPos]}px`
    };
  };
  const resolveColumnStyle = (colPos) => ({
    width: `${resolveFixOffset[colPos](false)}px`,
    bottom: "0px"
  });
  const fixedColumns = computed(() => {
    const colPosExist = {
      left: false,
      right: false
    };
    return colgroups.filter((col) => !col.isHidden && col.fixed).map((col) => {
      const colPos = resolveFixColPos(col);
      const isExist = colPosExist[colPos];
      colPosExist[colPos] = true;
      return {
        isExist,
        colPos,
        column: col
      };
    });
  });
  const fixedWrapperClass = resolveClassName("table-fixed");
  return {
    fixedWrapperClass,
    resolveFixedColumnStyle,
    fixedColumns,
    resolveColumnStyle,
    resolveColumnClass
  };
};
function _isSlot$2(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
class TableRender {
  constructor(props2, ctx, reactiveProp, colgroups, styleRef, t2) {
    __publicField(this, "getRowHeight", (row, rowIndex) => {
      const {
        size,
        height
      } = this.setting;
      if (height !== null && height !== void 0) {
        return resolvePropVal(this.setting, "height", ["tbody", row, rowIndex, size]);
      }
      return resolvePropVal(this.props, "rowHeight", ["tbody", row, rowIndex]);
    });
    __publicField(this, "getColumnClass", (column, colIndex) => ({
      [`${this.uuid}-column-${colIndex}`]: true,
      column_fixed: !!column.fixed,
      column_fixed_left: !!column.fixed,
      column_fixed_right: column.fixed === "right"
    }));
    __publicField(this, "getHeadColumnClass", (column, colIndex) => __spreadProps(__spreadValues({}, this.getColumnClass(column, colIndex)), {
      active: this.isColActive(colIndex)
    }));
    this.props = props2;
    this.context = ctx;
    this.reactiveProp = reactiveProp;
    this.colgroups = colgroups;
    this.plugins = new TablePlugins(props2, ctx);
    this.uuid = uuid_1.v4();
    this.events = /* @__PURE__ */ new Map();
    this.styleRef = styleRef;
    this.t = t2;
    this.activeSortIndex = ref(-1);
  }
  get propActiveCols() {
    return this.reactiveProp.activeColumns;
  }
  renderTableHeadSchema() {
    const {
      isShow = true
    } = resolveHeadConfig(this.props);
    if (!isShow) {
      return null;
    }
    const handleSettingsChanged = (arg) => {
      var _a;
      const {
        checked = [],
        size,
        height
      } = arg;
      this.reactiveProp.setting.size = size;
      this.reactiveProp.setting.height = height;
      const settingFields = ((_a = this.props.settings) == null ? void 0 : _a.fields) || [];
      if (checked.length) {
        this.colgroups.forEach((col) => {
          col.isHidden = isColumnHidden(settingFields, col, checked);
        });
      }
      this.emitEvent(EVENTS$1.ON_SETTING_CHANGE, [arg]);
    };
    return [this.props.settings ? createVNode(Settings, {
      "class": "table-head-settings",
      "settings": this.reactiveProp.settings,
      "columns": this.colgroups,
      "rowHeight": this.props.rowHeight,
      "onChange": handleSettingsChanged
    }, null) : "", createVNode("table", {
      "cellpadding": 0,
      "cellspacing": 0
    }, [this.renderColGroup(), this.renderHeader()])];
  }
  renderTableBodySchema(rows) {
    var _a, _b, _c;
    const localEmptyText = computed(() => {
      if (this.props.emptyText === void 0) {
        return this.t.value.emptyText;
      }
      return this.props.emptyText;
    });
    if (!rows.length) {
      return (_c = (_b = (_a = this.context.slots).empty) == null ? void 0 : _b.call(_a)) != null ? _c : createVNode(BodyEmpty, {
        "filterList": rows,
        "list": this.props.data,
        "emptyText": localEmptyText.value
      }, null);
    }
    return createVNode("table", {
      "cellpadding": 0,
      "cellspacing": 0,
      "data-table-uuid": this.uuid
    }, [this.renderColGroup(), this.renderTBody(rows)]);
  }
  renderTableFooter(options) {
    return createVNode(BkPagination, mergeProps(options, {
      "modelValue": options.current,
      "onLimitChange": (limit) => this.handlePageLimitChange(limit),
      "onChange": (current) => this.handlePageChange(current)
    }), null);
  }
  on(eventName, watcher) {
    if (!this.events.has(eventName)) {
      this.events.set(eventName, []);
    }
    this.events.get(eventName).push(watcher);
    return this;
  }
  destroy() {
    this.events.clear();
    this.events = null;
  }
  emitEvent(eventName, args) {
    if (this.events.has(eventName)) {
      this.events.get(eventName).forEach((event) => {
        if (typeof event === "function") {
          Reflect.apply(event, this, args);
        }
      });
    }
  }
  handlePageLimitChange(limit) {
    Object.assign(this.props.pagination, {
      limit
    });
    this.context.emit(EMIT_EVENTS.PAGE_LIMIT_CHANGE, limit);
  }
  handlePageChange(current) {
    Object.assign(this.props.pagination, {
      current,
      value: current
    });
    this.context.emit(EMIT_EVENTS.PAGE_VALUE_CHANGE, current);
  }
  setColumnActive(index2, single = false) {
    const col = this.propActiveCols.find((item) => item.index === index2);
    Object.assign(col, {
      active: !col.active
    });
    if (single) {
      this.propActiveCols.filter((item) => item.index !== index2 && item.active).forEach((col2) => {
        Object.assign(col2, {
          active: false
        });
      });
    }
  }
  handleColumnHeadClick(index2, column) {
    if (this.props.columnPick !== "disabled") {
      this.setColumnActive(index2, this.props.columnPick === "single");
      this.context.emit(EMIT_EVENTS.COLUMN_PICK, this.propActiveCols);
    }
    if (column.sort && !column.filter) {
      const columnName = resolvePropVal(column, ["field", "type"], [column, index2]);
      const nextSort = getNextSortType(this.reactiveProp.defaultSort[columnName]);
      Object.assign(this.reactiveProp.defaultSort, {
        [columnName]: nextSort
      });
      const sortFn = getSortFn(column, nextSort);
      this.activeSortIndex.value = index2;
      this.emitEvent(EVENTS$1.ON_SORT_BY_CLICK, [{
        sortFn,
        column,
        index: index2,
        type: nextSort
      }]);
    }
  }
  getSortCell(column, index2) {
    const columnName = resolvePropVal(column, ["field", "type"], [column, index2]);
    const handleSortClick = (sortFn, type) => {
      Object.assign(this.reactiveProp.defaultSort, {
        [columnName]: type
      });
      this.activeSortIndex.value = index2;
      this.emitEvent(EVENTS$1.ON_SORT_BY_CLICK, [{
        sortFn,
        column,
        index: index2,
        type
      }]);
    };
    const nextSort = this.reactiveProp.defaultSort[columnName];
    return createVNode(HeadSort, {
      "column": column,
      "defaultSort": nextSort,
      "active": this.activeSortIndex.value === index2,
      "onChange": handleSortClick
    }, null);
  }
  getFilterCell(column, index2) {
    const handleFilterChange = (checked, filterFn) => {
      const filterFn0 = (row, index3) => filterFn(checked, row, index3);
      this.emitEvent(EVENTS$1.ON_FILTER_CLICK, [{
        filterFn: filterFn0,
        checked,
        column,
        index: index2
      }]);
    };
    const filterSave = (values) => {
      this.context.emit(EMIT_EVENTS.COLUMN_FILTER_SAVE, {
        column,
        values
      });
    };
    return createVNode(HeadFilter, {
      "column": column,
      "height": this.props.headHeight,
      "onChange": handleFilterChange,
      "onFilterSave": filterSave
    }, null);
  }
  renderHeader() {
    const config = resolveHeadConfig(this.props);
    const {
      cellFn
    } = config;
    const rowStyle = {
      "--row-height": `${resolvePropVal(config, "height", ["thead"])}px`
    };
    const getHeadCellText = (column, index2) => {
      if (typeof cellFn === "function") {
        return cellFn(column, index2);
      }
      return resolvePropVal(column, "label", [column, index2]);
    };
    const renderHeadCell = (column, index2) => {
      if (column.type === "selection") {
        const selectAll = this.reactiveProp.rowActions.get(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_ALL);
        return this.renderCheckboxColumn({
          [TABLE_ROW_ATTRIBUTE.ROW_SELECTION]: !!selectAll
        }, 0, true);
      }
      const cells = [];
      if (column.sort) {
        cells.push(this.getSortCell(column, index2));
      }
      if (column.filter) {
        cells.push(this.getFilterCell(column, index2));
      }
      const cellText = getHeadCellText(column, index2);
      cells.unshift(createVNode("span", {
        "class": "head-text"
      }, [cellText]));
      const showTitle = typeof cellText === "string" ? cellText : void 0;
      const headClass = {
        "has-sort": !!column.sort,
        "has-filter": !!column.filter
      };
      return createVNode(TableCell, {
        "class": headClass,
        "title": showTitle,
        "observerResize": this.props.observerResize,
        "resizerWay": this.props.resizerWay
      }, _isSlot$2(cells) ? cells : {
        default: () => [cells]
      });
    };
    const resolveEventListener = (col) => Array.from(col.listeners.keys()).reduce((handle, key2) => {
      const eventName = key2.split("_").slice(-1)[0];
      return Object.assign(handle, {
        [eventName]: (e) => {
          col.listeners.get(key2).forEach((fn2) => Reflect.apply(fn2, this, [e, col, this]));
        }
      });
    }, {});
    const {
      resolveFixedColumnStyle
    } = useFixedColumn(this.props, this.colgroups);
    const getScrollFix = () => {
      if (this.styleRef.value.hasScrollY) {
        const fixStyle = {
          width: `${SCROLLY_WIDTH + 2}px`,
          right: "-1px"
        };
        return createVNode("th", {
          "style": fixStyle,
          "class": "column_fixed"
        }, null);
      }
    };
    return createVNode(Fragment, null, [createVNode("thead", {
      "style": rowStyle
    }, [createVNode(TableRow, null, {
      default: () => [createVNode("tr", null, [this.filterColGroups.map((column, index2) => createVNode("th", mergeProps({
        "colspan": 1,
        "rowspan": 1,
        "class": [this.getHeadColumnClass(column, index2), this.getColumnCustomClass(column), column.align || this.props.headerAlign || this.props.align],
        "style": resolveFixedColumnStyle(column, this.styleRef.value.hasScrollY),
        "onClick": () => this.handleColumnHeadClick(index2, column)
      }, resolveEventListener(column)), [renderHeadCell(column, index2)])), getScrollFix()])]
    })])]);
  }
  getColumnCustomClass(column, row) {
    const rowClass = column.className;
    if (rowClass) {
      if (typeof rowClass === "function") {
        return rowClass(row);
      }
      if (typeof rowClass === "string") {
        return rowClass;
      }
    }
    return "";
  }
  renderTBody(rows) {
    const {
      resolveFixedColumnStyle
    } = useFixedColumn(this.props, this.colgroups);
    const rowLength = rows.length;
    return createVNode("tbody", null, [rows.map((row, rowIndex) => {
      const rowStyle = [...formatPropAsArray(this.props.rowStyle, [row, rowIndex, this]), {
        "--row-height": `${this.getRowHeight(row, rowIndex)}px`
      }];
      const rowClass = [...formatPropAsArray(this.props.rowClass, [row, rowIndex, this]), `hover-${this.props.rowHover}`];
      const rowKey = getRowId(row, rowIndex, this.props);
      return [createVNode(TableRow, {
        "key": rowKey
      }, {
        default: () => [createVNode("tr", {
          "style": rowStyle,
          "class": rowClass,
          "onClick": (e) => this.handleRowClick(e, row, rowIndex, rows),
          "onDblclick": (e) => this.handleRowDblClick(e, row, rowIndex, rows),
          "onMouseenter": (e) => this.handleRowEnter(e, row, rowIndex, rows),
          "onMouseleave": (e) => this.handleRowLeave(e, row, rowIndex, rows)
        }, [this.filterColGroups.map((column, index2) => {
          var _a, _b;
          const cellStyle = [resolveFixedColumnStyle(column), ...formatPropAsArray(this.props.cellStyle, [column, index2, row, rowIndex, this])];
          const tdCtxClass = {
            "expand-cell": column.type === "expand"
          };
          const cellKey = `__CELL_${rowIndex}_${index2}`;
          const {
            colspan,
            rowspan
          } = resolveCellSpan(column, index2, row, rowIndex);
          const skipRowKey = TABLE_ROW_ATTRIBUTE.ROW_SKIP_CFG;
          const columnIdKey = column[COLUMN_ATTRIBUTE.COL_UID];
          const {
            skipRow = false,
            skipCol = false
          } = (_b = (_a = row[skipRowKey]) == null ? void 0 : _a[columnIdKey]) != null ? _b : {};
          if (!skipRow && !skipCol) {
            let _slot;
            const cellClass = [this.getColumnClass(column, index2), this.getColumnCustomClass(column, row), column.align || this.props.align, ...formatPropAsArray(this.props.cellClass, [column, index2, row, rowIndex, this]), {
              "expand-row": row[TABLE_ROW_ATTRIBUTE.ROW_EXPAND],
              "is-last": rowIndex + rowspan >= rowLength
            }];
            const handleEmit = (event, type) => {
              const args = {
                event,
                row: getRowSourceData(row),
                column: getColumnSourceData(column),
                cell: {
                  getValue: () => this.renderCell(row, column, rowIndex, rows)
                },
                rowIndex,
                columnIndex: index2
              };
              this.context.emit(type, args);
            };
            return createVNode("td", {
              "class": cellClass,
              "style": cellStyle,
              "key": cellKey,
              "colspan": colspan,
              "rowspan": rowspan,
              "onClick": (event) => handleEmit(event, EMIT_EVENTS.CELL_CLICK),
              "onDblclick": (event) => handleEmit(event, EMIT_EVENTS.CELL_DBL_CLICK)
            }, [createVNode(TableCell, {
              "class": tdCtxClass,
              "column": column,
              "row": row,
              "parentSetting": this.props.showOverflowTooltip,
              "observerResize": this.props.observerResize
            }, _isSlot$2(_slot = this.renderCell(row, column, rowIndex, rows)) ? _slot : {
              default: () => [_slot]
            })]);
          }
          return null;
        })])]
      }), this.renderExpandRow(row, rowClass, rowIndex)];
    })]);
  }
  renderExpandRow(row, rowClass, rowIndex) {
    const isExpand = !!row[TABLE_ROW_ATTRIBUTE.ROW_EXPAND];
    if (isExpand) {
      const resovledClass = [...rowClass, {
        row_expend: true
      }];
      const rowId = getRowId(row, rowIndex, this.props);
      const rowKey = `${rowId}_expand`;
      return createVNode(TableRow, {
        "key": rowKey
      }, {
        default: () => {
          var _a, _b, _c;
          return [createVNode("tr", {
            "class": resovledClass
          }, [createVNode("td", {
            "colspan": this.filterColGroups.length,
            "rowspan": 1
          }, [(_c = (_b = (_a = this.context.slots).expandRow) == null ? void 0 : _b.call(_a, getRowSourceData(row))) != null ? _c : createVNode("div", {
            "class": "expand-cell-ctx"
          }, [createTextVNode("Expand Row")])])])];
        }
      });
    }
  }
  handleRowClick(e, row, index2, rows) {
    this.context.emit(EMIT_EVENTS.ROW_CLICK, e, row, index2, rows, this);
  }
  handleRowDblClick(e, row, index2, rows) {
    this.context.emit(EMIT_EVENTS.ROW_DBL_CLICK, e, row, index2, rows, this);
  }
  handleRowEnter(e, row, index2, rows) {
    this.context.emit(EMIT_EVENTS.ROW_MOUSE_ENTER, e, row, index2, rows, this);
  }
  handleRowLeave(e, row, index2, rows) {
    this.context.emit(EMIT_EVENTS.ROW_MOUSE_LEAVE, e, row, index2, rows, this);
  }
  getExpandCell(row) {
    const isExpand = !!row[TABLE_ROW_ATTRIBUTE.ROW_EXPAND];
    return isExpand ? createVNode(downShape, null, null) : createVNode(rightShape, null, null);
  }
  handleRowExpandClick(row, column, index2, rows, e) {
    this.emitEvent(EVENTS$1.ON_ROW_EXPAND_CLICK, [{
      row,
      column,
      index: index2,
      rows,
      e
    }]);
  }
  renderCellCallbackFn(row, column, index2, rows) {
    const cell = getRowText(row, resolvePropVal(column, "field", [column, row]), column);
    const attrIndex = row[TABLE_ROW_ATTRIBUTE.ROW_INDEX];
    const rowIndex = typeof attrIndex === "number" ? attrIndex : index2;
    const data2 = this.props.data[rowIndex];
    return column.render({
      cell,
      data: data2,
      row,
      column,
      index: index2,
      rows
    });
  }
  renderCheckboxColumn(row, index2, isAll = false) {
    const handleChecked = (value) => {
      this.emitEvent(EVENTS$1.ON_ROW_CHECK, [{
        row,
        index: index2,
        isAll,
        value
      }]);
    };
    const indeterminate = isAll && !!this.reactiveProp.rowActions.get(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_INDETERMINATE);
    const isEnable = isRowSelectEnable(this.props, {
      row,
      index: index2,
      isCheckAll: isAll
    });
    return createVNode(BkCheckbox, {
      "onChange": handleChecked,
      "disabled": !isEnable,
      "modelValue": row[TABLE_ROW_ATTRIBUTE.ROW_SELECTION],
      "indeterminate": indeterminate
    }, null);
  }
  renderExpandColumn(row, column, index2, rows) {
    const renderExpandSlot = () => {
      var _a, _b, _c;
      if (typeof column.render === "function") {
        return this.renderCellCallbackFn(row, column, index2, rows);
      }
      return (_c = (_b = (_a = this.context.slots).expandCell) == null ? void 0 : _b.call(_a, {
        row,
        column,
        index: index2,
        rows
      })) != null ? _c : this.getExpandCell(row);
    };
    return createVNode("span", {
      "class": "expand-btn-action",
      "onClick": (e) => this.handleRowExpandClick(row, column, index2, rows, e)
    }, [renderExpandSlot()]);
  }
  renderCell(row, column, index2, rows) {
    var _a, _b;
    const defaultFn = () => {
      const cell = getRowText(row, resolvePropVal(column, "field", [column, row]), column);
      if (typeof column.render === "function") {
        return this.renderCellCallbackFn(row, column, index2, rows);
      }
      if (typeof cell === "object") {
        return JSON.stringify(unref(cell));
      }
      return cell;
    };
    const renderFn = {
      expand: (row2, column2, index3, rows2) => this.renderExpandColumn(row2, column2, index3, rows2),
      selection: (row2, _column, index3, _rows) => this.renderCheckboxColumn(row2, index3)
    };
    return (_b = (_a = renderFn[column.type]) == null ? void 0 : _a.call(renderFn, row, column, index2, rows)) != null ? _b : defaultFn();
  }
  isColActive(colIndex) {
    return this.props.columnPick !== "disabled" && this.propActiveCols.some((col) => col.index === colIndex && col.active);
  }
  renderColGroup() {
    return createVNode("colgroup", null, [(this.filterColGroups || []).map((column, index2) => {
      const colCls = classes({
        active: this.isColActive(index2)
      });
      const width = `${resolveWidth(getColumnReactWidth(column))}`.replace(/px$/i, "");
      return createVNode("col", {
        "class": colCls,
        "width": width
      }, null);
    })]);
  }
  get filterColGroups() {
    return this.colgroups.filter((col) => !col.isHidden);
  }
  get setting() {
    return this.reactiveProp.setting;
  }
}
var useColumn = (props2, targetColumns) => {
  const initColumns = (column, remove = false) => {
    let resolveColumns = [];
    if (!Array.isArray(column)) {
      resolveColumns = [column];
    } else {
      resolveColumns = column;
    }
    if (!remove) {
      let needToSort = false;
      resolveColumns.forEach((col) => {
        if (col.index !== void 0 && col.index >= 0) {
          needToSort = true;
          const oldIndex = targetColumns.findIndex((tc) => tc.label === col.label && tc.field === col.field);
          if (oldIndex >= 0) {
            targetColumns.splice(oldIndex, 1);
          }
          targetColumns.push(col);
        } else {
          const index2 = targetColumns.findIndex((tc) => tc.label === col.label && tc.field === col.field);
          if (index2 >= 0) {
            targetColumns.splice(index2, 1, col);
          } else {
            targetColumns.push(col);
          }
        }
      });
      if (needToSort) {
        targetColumns.sort((col1, col2) => col1.index - col2.index);
      }
    } else {
      resolveColumns.forEach((col) => {
        const matchColIndex = targetColumns.findIndex((c2) => c2.label === col.label && c2.field === col.field);
        if (remove) {
          if (matchColIndex >= 0) {
            targetColumns.splice(matchColIndex, 1);
          }
          return;
        }
      });
    }
  };
  const getColumns = () => {
    var _a;
    if (targetColumns == null ? void 0 : targetColumns.length) {
      return targetColumns;
    }
    if ((_a = props2.columns) == null ? void 0 : _a.length) {
      return props2.columns;
    }
    return [];
  };
  return {
    initColumns,
    getColumns
  };
};
const resolveActiveColumns = (props2) => {
  if (props2.columnPick !== "disabled") {
    if (props2.columnPick === "multi") {
      return Array.isArray(props2.activeColumn) ? props2.activeColumn : resolveNumberToNumArray(props2.activeColumn);
    }
    return Array.isArray(props2.activeColumn) ? resolveNumberToNumArray(props2.activeColumn[0]) : resolveNumberToNumArray(props2.activeColumn);
  }
  return [];
};
var useActiveColumns = (props2, targetColumns) => {
  let activeColumns = reactive([]);
  const {
    getColumns
  } = useColumn(props2, targetColumns);
  if (props2.columnPick === "disabled") {
    return {
      activeColumns
    };
  }
  const activeCols = reactive(resolveActiveColumns(props2));
  const getActiveColumns = () => getColumns().map((_column, index2) => ({
    index: index2,
    active: activeCols.some((colIndex) => colIndex === index2),
    _column
  }));
  watchEffect(() => {
    activeColumns = getActiveColumns();
    const cols = resolveActiveColumns(props2);
    activeColumns.forEach((col, index2) => {
      Object.assign(col, {
        active: cols.some((colIndex) => colIndex === index2)
      });
    });
  });
  return {
    activeColumns
  };
};
var useColumnResize = (colgroups, immediate = true) => {
  const pluginName = "HeadColumnResize";
  let EVENTS2;
  (function(EVENTS3) {
    EVENTS3["MOUSE_MOVE"] = "onMousemove";
    EVENTS3["MOUSE_OUT"] = "onMouseout";
    EVENTS3["MOUSE_DOWN"] = "onMousedown";
  })(EVENTS2 || (EVENTS2 = {}));
  let isInDragSection = false;
  let isMouseDown = false;
  let isDraging = false;
  let startX = 0;
  let dragColumn = null;
  let dragStartOffsetX = 0;
  const dragOffsetX = ref(-1e3);
  const handleMouseUp = (e) => {
    var _a;
    isMouseDown = false;
    isDraging = false;
    const bodyStyle = document.body.style;
    bodyStyle.cursor = "";
    const diff3 = e.clientX - startX;
    const resolveWidth2 = ((_a = dragColumn.resizeWidth) != null ? _a : dragColumn.calcWidth) + diff3;
    const minWidth = Number(dragColumn.minWidth);
    dragColumn.resizeWidth = resolveWidth2 > minWidth ? resolveWidth2 : minWidth;
    document.removeEventListener("mouseup", handleMouseUp);
    document.removeEventListener("mousemove", handleMouseMove);
    startX = 0;
    dragOffsetX.value = -1e3;
    dragColumn = null;
    const targetTable = e.target.closest("table");
    targetTable.querySelectorAll("th").forEach((th) => th.style.setProperty("user-select", "inherit"));
  };
  const updateOffsetX = (e) => lodash.exports.throttle(() => {
    var _a;
    const diff3 = e.clientX - startX;
    const resolveWidth2 = ((_a = dragColumn.resizeWidth) != null ? _a : dragColumn.calcWidth) + diff3;
    const minWidth = Number(dragColumn.minWidth);
    if (minWidth < resolveWidth2) {
      dragOffsetX.value = e.clientX - startX + dragStartOffsetX;
    }
  }, 60);
  const handleMouseMove = (e) => {
    const bodyStyle = document.body.style;
    bodyStyle.setProperty("cursor", "");
    updateOffsetX(e)();
  };
  const handler = {
    [EVENTS2.MOUSE_DOWN]: (e, column) => {
      if (!isInDragSection) {
        return;
      }
      isMouseDown = true;
      const bodyStyle = document.body.style;
      bodyStyle.setProperty("cursor", "col-resize");
      dragColumn = column;
      startX = e.clientX;
      const targetTable = e.target.closest("table");
      dragStartOffsetX = startX - targetTable.getBoundingClientRect().left;
      document.addEventListener("mouseup", handleMouseUp);
      document.addEventListener("mousemove", handleMouseMove);
    },
    [EVENTS2.MOUSE_MOVE]: (e, _column) => {
      if (isMouseDown && !isDraging) {
        isDraging = true;
      }
      const target = e.target.closest("th");
      if (isDraging) {
        target.style.setProperty("user-select", "none");
      }
      if (!isDraging) {
        if (!target) {
          return;
        }
        const rect = target.getBoundingClientRect();
        if (rect.width > 12 && rect.right - e.pageX < 8) {
          isInDragSection = true;
          target.style.setProperty("cursor", "col-resize");
        } else {
          target.style.setProperty("cursor", "");
          isInDragSection = false;
        }
      }
    },
    [EVENTS2.MOUSE_OUT]: (e, _column) => {
      const target = e.target;
      if (!isDraging) {
        target.style.setProperty("cursor", "");
      }
    }
  };
  const getEventName = (event) => `${pluginName}_${event}`;
  const registerResizeEvent = () => {
    colgroups.forEach((col) => {
      if (col.resizable !== false) {
        Object.keys(handler).forEach((event) => {
          const name = getEventName(event);
          if (!col.listeners.has(name)) {
            col.listeners.set(name, []);
          }
          col.listeners.get(name).push(handler[event]);
        });
      }
    });
  };
  const resetResizeEvents = () => {
    colgroups.forEach((col) => {
      Object.keys(handler).forEach((event) => {
        const name = getEventName(event);
        if (col.listeners.has(name)) {
          const listeners = col.listeners.get(name);
          listeners.length = 0;
        }
      });
    });
  };
  if (immediate) {
    registerResizeEvent();
  }
  const dragOffsetXStyle = computed(() => ({
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    width: "1px",
    "background-color": "#ebeef5"
  }));
  return {
    registerResizeEvent,
    resetResizeEvents,
    dragOffsetX,
    dragOffsetXStyle
  };
};
const useClass = (props2, targetColumns, root, reactiveProp, pageData) => {
  const { getColumns } = useColumn(props2, targetColumns);
  const autoHeight = ref(200);
  const hasScrollY = ref(false);
  const hasFooter = computed(() => props2.pagination && props2.data.length);
  const hasScrollYRef = computed(() => hasScrollY.value);
  const tableClass = computed(() => classes({
    [resolveClassName("table")]: true,
    "has-footer": hasFooter.value,
    "has-scroll-y": hasScrollY.value || props2.virtualEnabled
  }, resolvePropBorderToClassStr(props2.border)));
  const headClass = classes({
    [resolveClassName("table-head")]: true,
    "has-settings": !!props2.settings
  });
  const resolvedColumns = computed(() => getColumns());
  const config = resolveHeadConfig(props2);
  const headStyle = computed(() => ({
    "--row-height": `${resolvePropVal(config, "height", ["thead"])}px`,
    "--scroll-head-left": `-${reactiveProp.scrollTranslateX}px`,
    "--scroll-left": `${reactiveProp.scrollTranslateX}px`
  }));
  const contentClass = {
    [resolveClassName("table-body")]: true
  };
  const footerClass = computed(() => classes({
    [resolveClassName("table-footer")]: true,
    ["is-hidden"]: !props2.pagination || !props2.data.length
  }));
  const getTableHeight = () => {
    if (props2.height === "number") {
      return `${props2.height}px`;
    }
    if (typeof props2.height === "string") {
      return props2.height;
    }
    return "";
  };
  const resolveWidth2 = () => {
    if (resolvedColumns.value.every((col) => /^\d+\.?\d*(px)?$/ig.test(`${col.width}`))) {
      const rectWidth = resolvedColumns.value.reduce((width, col) => width + Number(`${col.width}`.replace(/px/ig, "")), 0);
      const offset2 = hasScrollY.value ? SCROLLY_WIDTH : 0;
      return `${rectWidth + offset2}px`;
    }
    return "100%";
  };
  const wrapperStyle = computed(() => ({
    minHeight: resolveNumberOrStringToPix(props2.minHeight, "auto"),
    width: resolveWidth2(),
    maxWidth: "100%",
    height: getTableHeight()
  }));
  const resolvePropHeight = (height, defaultValue) => {
    const strHeight = String(height);
    if (/^\d+\.?\d*$/.test(strHeight)) {
      return Number(strHeight);
    }
    if (/^\d+\.?\d*px$/ig.test(strHeight)) {
      return Number(strHeight.replace("px", ""));
    }
    if (/^\d+\.?\d*%$/ig.test(strHeight) && typeof defaultValue === "number") {
      const percent = Number(strHeight.replace("%", ""));
      return defaultValue * percent / 100;
    }
    return defaultValue;
  };
  const contentStyle = reactive({
    display: "",
    "min-height": "",
    height: "",
    maxHeight: ""
  });
  const getHeadHeight = () => props2.showHead ? resolvePropHeight(props2.headHeight, LINE_HEIGHT) : 0;
  const resolveContentStyle = () => {
    const resolveHeight = resolvePropHeight(props2.height, autoHeight.value);
    const resolveHeadHeight = getHeadHeight();
    const resolveMinHeight = resolvePropHeight(props2.minHeight, autoHeight.value);
    const resolveFooterHeight = props2.pagination && props2.data.length ? props2.paginationHeight : 0;
    const contentHeight = resolveHeight - resolveHeadHeight - resolveFooterHeight;
    const height = props2.height !== "auto" ? `${contentHeight}px` : false;
    const minHeight = resolveMinHeight - resolveHeadHeight - resolveFooterHeight;
    const resolveMaxHeight = resolvePropHeight(props2.maxHeight, void 0);
    const maxHeight = typeof resolveMaxHeight === "number" ? `${resolveMaxHeight - resolveHeadHeight - resolveFooterHeight}px` : false;
    Object.assign(contentStyle, {
      display: (pageData == null ? void 0 : pageData.length) ? "block" : false,
      "min-height": `${minHeight}px`,
      height,
      maxHeight
    });
  };
  onMounted(() => {
    resetTableHeight(root == null ? void 0 : root.value);
  });
  const resetTableHeight = (rootEl) => {
    if (rootEl) {
      const { height } = rootEl.parentElement.getBoundingClientRect();
      autoHeight.value = height;
      resolveContentStyle();
      updateBorderClass(rootEl);
    }
  };
  const updateBorderClass = (root2) => {
    if (!root2) {
      return;
    }
    const querySelector = props2.virtualEnabled ? `.${resolveClassName("virtual-section")}` : `.${resolveClassName("table-body-content")}`;
    const rootBody = root2.querySelector(`.${resolveClassName("table-body")}`);
    hasScrollY.value = hasRootScrollY(rootBody, querySelector, 0);
  };
  const getColumnsWidthOffsetWidth = () => {
    let offsetWidth = 0;
    if (hasScrollY.value) {
      offsetWidth = offsetWidth + SCROLLY_WIDTH;
    }
    if (props2.border.includes(BORDER_OPTION.OUTER) && !props2.border.includes(BORDER_OPTION.NONE)) {
      offsetWidth = offsetWidth + 2;
    }
    return offsetWidth;
  };
  return {
    tableClass,
    headClass,
    contentClass,
    footerClass,
    wrapperStyle,
    contentStyle,
    headStyle,
    resetTableHeight,
    updateBorderClass,
    getColumnsWidthOffsetWidth,
    hasFooter,
    hasScrollY,
    hasScrollYRef
  };
};
const useInit = (props2, targetColumns) => {
  var _a, _b;
  const colgroups = reactive([]);
  const { getColumns } = useColumn(props2, targetColumns);
  const resolveMinWidth = (col) => {
    if (/^\d+/.test(`${col.minWidth}`)) {
      return col.minWidth;
    }
    let minWidth = COL_MIN_WIDTH;
    if (col.sort) {
      minWidth = minWidth + 18;
    }
    if (col.filter) {
      minWidth = minWidth + 28;
    }
    return minWidth;
  };
  const resolvedColumns = computed(() => getColumns());
  const updateColGroups = (settings) => {
    var _a2, _b2;
    const checked = (settings == null ? void 0 : settings.checked) || ((_a2 = props2.settings) == null ? void 0 : _a2.checked) || [];
    const settingFields = (settings == null ? void 0 : settings.fields) || ((_b2 = props2.settings) == null ? void 0 : _b2.fields) || [];
    colgroups.length = 0;
    colgroups.push(...resolvedColumns.value.map((col) => __spreadProps(__spreadValues({}, col), {
      calcWidth: null,
      resizeWidth: null,
      minWidth: resolveMinWidth(col),
      listeners: /* @__PURE__ */ new Map(),
      isHidden: isColumnHidden(settingFields, col, checked),
      [COLUMN_ATTRIBUTE.COL_UID]: uuid_1.v4(),
      [COLUMN_ATTRIBUTE.COL_SOURCE_DATA]: col
    })));
  };
  if (typeof props2.settings === "object") {
    updateColGroups(props2.settings);
  }
  const { dragOffsetXStyle, dragOffsetX, resetResizeEvents, registerResizeEvent } = useColumnResize(colgroups, true);
  const { activeColumns } = useActiveColumns(props2, targetColumns);
  watch(() => [props2.settings], () => {
    var _a2;
    if ((((_a2 = props2.settings) == null ? void 0 : _a2.checked) || []).length) {
      updateColGroups();
    }
  });
  const debounceColUpdate = lodash.exports.debounce(() => {
    updateColGroups();
    resetResizeEvents();
    registerResizeEvent();
  }, 120);
  watch(() => resolvedColumns, () => {
    debounceColUpdate();
  }, { immediate: true, deep: true });
  const defSort = props2.columns.reduce((out, col, index2) => {
    const columnName = resolvePropVal(col, ["field", "type"], [col, index2]);
    const sort = resolveSort(col.sort);
    if (sort) {
      return __spreadProps(__spreadValues({}, out || {}), { [columnName]: sort == null ? void 0 : sort.value });
    }
    return out;
  }, null);
  const reactiveSchema = reactive({
    rowActions: /* @__PURE__ */ new Map(),
    scrollTranslateY: 0,
    scrollTranslateX: 0,
    pos: {
      bottom: 1
    },
    activeColumns,
    settings: props2.settings,
    setting: {
      size: (_a = props2.settings) == null ? void 0 : _a.size,
      height: SETTING_SIZE[(_b = props2.settings) == null ? void 0 : _b.size]
    },
    defaultSort: defSort || props2.defaultSort
  });
  const isRowExpand = (rowId) => {
    var _a2;
    if (reactiveSchema.rowActions.has(rowId)) {
      return (_a2 = reactiveSchema.rowActions.get(rowId)) == null ? void 0 : _a2.isExpand;
    }
    return false;
  };
  const clearSort = () => {
    if (Array.isArray(reactiveSchema.defaultSort)) {
      reactiveSchema.defaultSort.splice(0);
    }
    reactiveSchema.defaultSort = defSort || props2.defaultSort;
  };
  const setRowExpand = (row, expand = void 0) => {
    var _a2;
    const rowId = row[TABLE_ROW_ATTRIBUTE.ROW_UID];
    const isExpand = typeof expand === "boolean" ? expand : !isRowExpand(rowId);
    reactiveSchema.rowActions.set(rowId, Object.assign({}, (_a2 = reactiveSchema.rowActions.get(rowId)) != null ? _a2 : {}, { isExpand }));
    updateIndexData();
  };
  const isSelectionAll = () => {
    if (reactiveSchema.rowActions.has(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_ALL)) {
      return reactiveSchema.rowActions.get(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_ALL);
    }
    if (!!props2.selectionKey) {
      return indexData.every((row) => resolveSelectionRow(row));
    }
    return false;
  };
  const validateSelectionFn = (row) => {
    const rowId = row[TABLE_ROW_ATTRIBUTE.ROW_UID];
    const { isSelected = false } = reactiveSchema.rowActions.get(rowId) || {};
    return isSelected;
  };
  const updateSelectionAll = (validateFn = validateSelectionFn) => {
    let hasUnchecked = false;
    let hasChecked = false;
    indexData.forEach((row) => {
      const isSelected = validateFn(row);
      if (!hasUnchecked && !isSelected) {
        hasUnchecked = true;
      }
      if (!hasChecked && isSelected) {
        hasChecked = true;
      }
    });
    reactiveSchema.rowActions.set(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_INDETERMINATE, hasChecked && hasUnchecked);
    reactiveSchema.rowActions.set(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_ALL, hasChecked && !hasUnchecked);
  };
  const isSelectionEnable = () => props2.columns.some((col) => col.type === "selection");
  const initSelectionAllByData = () => {
    if (isSelectionEnable()) {
      updateSelectionAll((row) => resolveSelectionRow(row));
    }
  };
  const toggleAllSelection = (checked = void 0) => {
    const isChecked = typeof checked === "boolean" ? checked : !isSelectionAll();
    reactiveSchema.rowActions.set(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_ALL, isChecked);
    reactiveSchema.rowActions.set(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_INDETERMINATE, false);
    indexData.forEach((row, index2) => {
      var _a2;
      if (isRowSelectEnable(props2, { row, index: index2, isCheckAll: false })) {
        const rowId = row[TABLE_ROW_ATTRIBUTE.ROW_UID];
        const target = Object.assign({}, (_a2 = reactiveSchema.rowActions.get(rowId)) != null ? _a2 : {}, { isSelected: isChecked });
        reactiveSchema.rowActions.set(rowId, target);
      }
    });
    updateSelectionAll();
    updateIndexData(isChecked);
    asyncSelection(null, checked, true);
  };
  const clearSelection = () => {
    toggleAllSelection(false);
  };
  const toggleRowSelection = (row, selected) => {
    var _a2;
    const rowId = row[TABLE_ROW_ATTRIBUTE.ROW_UID];
    if (rowId) {
      const isSelected = typeof selected === "boolean" ? selected : !resolveSelection(row, rowId);
      const target = Object.assign({}, (_a2 = reactiveSchema.rowActions.get(rowId)) != null ? _a2 : {}, { isSelected });
      reactiveSchema.rowActions.set(rowId, target);
      if (!selected) {
        reactiveSchema.rowActions.set(TABLE_ROW_ATTRIBUTE.ROW_SELECTION_ALL, false);
      }
      updateSelectionAll();
      updateIndexData();
      asyncSelection(row, selected, false);
    }
  };
  const resolveSelectionRow = (row, thenFn = (row2) => validateSelectionFn(row2)) => {
    if (typeof props2.isSelectedFn === "function") {
      return Reflect.apply(props2.isSelectedFn, globalThis, [{ row, data: props2.data }]);
    }
    if (typeof props2.selectionKey === "string" && props2.selectionKey.length) {
      return lodash.exports.get(row, props2.selectionKey);
    }
    return thenFn(row);
  };
  const resolveSelection = (row, _rowId, index2) => resolveSelectionRow(row, () => {
    var _a2;
    const rowId = _rowId === void 0 ? row[TABLE_ROW_ATTRIBUTE.ROW_UID] : _rowId;
    if (isRowSelectEnable(props2, { row, index: index2, isCheckAll: false }) && isSelectionAll()) {
      return true;
    }
    if (reactiveSchema.rowActions.has(rowId)) {
      return (_a2 = reactiveSchema.rowActions.get(rowId)) == null ? void 0 : _a2.isSelected;
    }
    return false;
  });
  const indexData = reactive([]);
  const neepColspanOrRowspan = computed(() => colgroups.some((col) => typeof col.rowspan === "function" || /^\d$/.test(`${col.rowspan}`) || typeof col.colspan === "function" || /^\d$/.test(`${col.colspan}`)));
  const needSelection = computed(() => colgroups.some((col) => col.type === "selection"));
  const needExpand = computed(() => colgroups.some((col) => col.type === "expand"));
  const needIndexColumn = computed(() => colgroups.some((col) => col.type === "index"));
  const initIndexData = (keepLocalAction = false) => {
    let preRowId = null;
    const skipConfig = {};
    if (neepColspanOrRowspan.value || needSelection.value || needExpand.value || needIndexColumn.value) {
      const copyData = props2.data.map((item, index2) => {
        const rowId = getRowKey(item, props2, index2);
        preRowId = rowId;
        const target = __spreadProps(__spreadValues({}, item), {
          [TABLE_ROW_ATTRIBUTE.ROW_UID]: rowId,
          [TABLE_ROW_ATTRIBUTE.ROW_SOURCE_DATA]: __spreadValues({}, item)
        });
        if (neepColspanOrRowspan.value) {
          const cfg = getSkipConfig(item, rowId, index2, skipConfig, preRowId);
          Object.assign(target, { [TABLE_ROW_ATTRIBUTE.ROW_SKIP_CFG]: cfg });
        }
        if (needSelection.value) {
          Object.assign(target, { [TABLE_ROW_ATTRIBUTE.ROW_SELECTION]: resolveSelection(item, rowId, index2) });
        }
        if (needIndexColumn.value) {
          Object.assign(target, { [TABLE_ROW_ATTRIBUTE.ROW_INDEX]: index2 });
        }
        if (needExpand.value) {
          Object.assign(target, { [TABLE_ROW_ATTRIBUTE.ROW_EXPAND]: keepLocalAction ? isRowExpand(rowId) : false });
        }
        return target;
      });
      indexData.length = 0;
      indexData.push(...copyData);
      if (needSelection.value) {
        initSelectionAllByData();
      }
      return;
    }
    indexData.length = 0;
    indexData.push(...props2.data);
  };
  const isRowChecked = (isRowCheckEnable, selectedAll, item, index2) => {
    const isChecked = resolveSelection(item, item[TABLE_ROW_ATTRIBUTE.ROW_UID], index2);
    if (isRowCheckEnable) {
      return typeof selectedAll === "boolean" ? selectedAll : isChecked;
    }
    return isChecked;
  };
  const updateIndexData = (selectedAll) => {
    if (neepColspanOrRowspan.value || needSelection.value || needExpand.value || needIndexColumn.value) {
      let preRowId = null;
      const skipConfig = {};
      indexData.forEach((item, index2) => {
        const rowId = item[TABLE_ROW_ATTRIBUTE.ROW_UID];
        if (needExpand.value) {
          Object.assign(item, {
            [TABLE_ROW_ATTRIBUTE.ROW_EXPAND]: isRowExpand(item[TABLE_ROW_ATTRIBUTE.ROW_UID])
          });
        }
        if (neepColspanOrRowspan.value) {
          const cfg = getSkipConfig(item, rowId, index2, skipConfig, preRowId);
          preRowId = item[TABLE_ROW_ATTRIBUTE.ROW_UID];
          Object.assign(item, {
            [TABLE_ROW_ATTRIBUTE.ROW_SKIP_CFG]: cfg
          });
        }
        if (needIndexColumn.value) {
          Object.assign(item, { [TABLE_ROW_ATTRIBUTE.ROW_INDEX]: index2 });
        }
        if (needSelection.value) {
          const isRowCheckEnable = isRowSelectEnable(props2, { row: item, index: index2, isCheckAll: false });
          Object.assign(item, {
            [TABLE_ROW_ATTRIBUTE.ROW_SELECTION]: isRowChecked(isRowCheckEnable, selectedAll, item, index2)
          });
        }
      });
      if (needSelection.value && typeof selectedAll !== "boolean") {
        initSelectionAllByData();
      }
      return;
    }
  };
  const getSkipConfig = (row, rowId, rowIndex, skipCfg, preRowId) => {
    var _a2;
    let skipColumnNum = 0;
    const preRowConfig = (_a2 = skipCfg[preRowId]) != null ? _a2 : {};
    if (!skipCfg[rowId]) {
      skipCfg[rowId] = {};
    }
    colgroups.forEach((column, index2) => {
      var _a3, _b2;
      const { colspan, rowspan } = resolveCellSpan(column, index2, row, rowIndex);
      const colId = column[COLUMN_ATTRIBUTE.COL_UID];
      const preRowColSkipLen = (_b2 = (_a3 = preRowConfig[colId]) == null ? void 0 : _a3.skipRowLen) != null ? _b2 : 0;
      const target = {
        [colId]: {
          skipRowLen: 0,
          skipRow: false,
          skipCol: false,
          skipColLen: 0
        }
      };
      if (skipColumnNum > 0) {
        target[colId].skipColLen = skipColumnNum;
        target[colId].skipCol = true;
        skipColumnNum = skipColumnNum - 1;
      }
      if (preRowColSkipLen > 1) {
        target[colId].skipRowLen = preRowColSkipLen - 1;
        target[colId].skipRow = true;
      } else {
        if (rowspan > 1) {
          target[colId].skipRowLen = rowspan;
          target[colId].skipRow = false;
        }
      }
      if (colspan > 1) {
        target[colId].skipColLen = colspan;
        skipColumnNum = colspan - 1;
      }
      Object.assign(skipCfg[rowId], __spreadValues({}, target));
    });
    return skipCfg[rowId];
  };
  const debounceUpdate = lodash.exports.debounce(updateIndexData, 120);
  watch([neepColspanOrRowspan, needSelection, needExpand, needIndexColumn], () => {
    debounceUpdate();
  });
  const asyncSelection = (row, value, all = false) => {
    if (props2.asyncData && props2.rowKey) {
      if (all) {
        props2.data.forEach((item) => {
          if (lodash.exports.has(item, props2.selectionKey)) {
            lodash.exports.set(item, props2.selectionKey, !!value);
          }
        });
      } else {
        if (lodash.exports.has(row, props2.selectionKey)) {
          const target = props2.data.find((item) => lodash.exports.get(item, props2.rowKey) === lodash.exports.get(row, props2.rowKey));
          lodash.exports.set(target, props2.selectionKey, !!value);
        }
      }
    }
  };
  const {
    fixedColumns,
    resolveColumnStyle,
    resolveColumnClass,
    fixedWrapperClass
  } = useFixedColumn(props2, colgroups, false);
  const getSelection = () => indexData.filter((row) => resolveSelection(row));
  return {
    colgroups,
    dragOffsetXStyle,
    dragOffsetX,
    reactiveSchema,
    indexData,
    fixedWrapperClass,
    fixedColumns,
    resolveColumnStyle,
    resolveColumnClass,
    initIndexData,
    updateIndexData,
    setRowExpand,
    updateColGroups,
    clearSelection,
    toggleAllSelection,
    toggleRowSelection,
    getSelection,
    clearSort
  };
};
var Component$f = defineComponent({
  name: "Table",
  props: tableProps,
  emits: EMIT_EVENT_TYPES,
  setup(props2, ctx) {
    const t2 = useLocale("table");
    let columnSortFn = null;
    let activeSortColumn = null;
    let columnFilterFn = null;
    const bkTableCache = new BkTableCache();
    const targetColumns = reactive([]);
    const {
      initColumns
    } = useColumn(props2, targetColumns);
    provide(PROVIDE_KEY_INIT_COL, initColumns);
    provide(PROVIDE_KEY_TB_CACHE, bkTableCache);
    const root = ref();
    const refVirtualRender = ref();
    const tableOffsetRight = ref(0);
    const {
      colgroups,
      dragOffsetXStyle,
      dragOffsetX,
      reactiveSchema,
      indexData,
      fixedColumns,
      resolveColumnStyle,
      resolveColumnClass,
      setRowExpand,
      initIndexData,
      fixedWrapperClass,
      clearSelection,
      toggleAllSelection,
      toggleRowSelection,
      getSelection,
      clearSort,
      updateColGroups
    } = useInit(props2, targetColumns);
    const {
      pageData,
      localPagination,
      resolvePageData,
      watchEffectFn
    } = usePagination(props2, indexData);
    const {
      tableClass,
      headClass,
      contentClass,
      footerClass,
      wrapperStyle,
      contentStyle,
      headStyle,
      hasScrollYRef,
      updateBorderClass,
      resetTableHeight,
      getColumnsWidthOffsetWidth,
      hasFooter
    } = useClass(props2, targetColumns, root, reactiveSchema, pageData);
    const styleRef = computed(() => ({
      hasScrollY: hasScrollYRef.value
    }));
    const tableRender = new TableRender(props2, ctx, reactiveSchema, colgroups, styleRef, t2);
    const updateOffsetRight = () => {
      const $tableContent = root.value.querySelector(".lesscode-bk-table-body-content");
      const $table = $tableContent.querySelector("table");
      if ($table) {
        const $tableScrollWidth = $table.scrollWidth;
        const $contentWidth = $tableContent.clientWidth;
        tableOffsetRight.value = $tableScrollWidth - $contentWidth;
      }
    };
    watch(() => [props2.data, props2.pagination, props2.height, props2.maxHeight, props2.minHeight], () => {
      initIndexData(props2.reserveExpand);
      watchEffectFn(columnFilterFn, columnSortFn, activeSortColumn);
      nextTick(() => {
        resetTableHeight(root.value);
        updateBorderClass(root.value);
      });
    }, {
      immediate: true,
      deep: true
    });
    watchEffect(() => {
      if ((root == null ? void 0 : root.value) instanceof HTMLElement) {
        const offset2 = getColumnsWidthOffsetWidth();
        resolveColumnWidth(root.value, colgroups, 20, offset2);
        updateOffsetRight();
      }
    });
    tableRender.on(EVENTS$1.ON_SORT_BY_CLICK, (args) => {
      var _a, _b;
      const {
        sortFn,
        column,
        index: index2,
        type
      } = args;
      if (typeof sortFn === "function") {
        columnSortFn = sortFn;
        activeSortColumn = column;
        resolvePageData(columnFilterFn, columnSortFn, activeSortColumn);
        (_b = (_a = refVirtualRender.value) == null ? void 0 : _a.reset) == null ? void 0 : _b.call(_a);
      }
      ctx.emit(EMIT_EVENTS.COLUMN_SORT, {
        column: unref(column[COLUMN_ATTRIBUTE.COL_SOURCE_DATA]),
        index: index2,
        type
      });
    }).on(EVENTS$1.ON_FILTER_CLICK, (args) => {
      var _a, _b;
      const {
        filterFn,
        checked,
        column,
        index: index2
      } = args;
      if (typeof filterFn === "function") {
        columnFilterFn = filterFn;
        resolvePageData(columnFilterFn, columnSortFn, activeSortColumn);
        (_b = (_a = refVirtualRender.value) == null ? void 0 : _a.reset) == null ? void 0 : _b.call(_a);
      }
      ctx.emit(EMIT_EVENTS.COLUMN_FILTER, {
        checked,
        column: unref(column[COLUMN_ATTRIBUTE.COL_SOURCE_DATA]),
        index: index2
      });
    }).on(EVENTS$1.ON_SETTING_CHANGE, (args) => {
      const {
        checked = [],
        size,
        height,
        fields
      } = args;
      nextTick(() => {
        var _a, _b;
        updateColGroups({
          checked,
          fields
        });
        updateBorderClass(root.value);
        const offset2 = getColumnsWidthOffsetWidth();
        checked.length && resolveColumnWidth(root.value, colgroups, COL_MIN_WIDTH, offset2);
        (_b = (_a = refVirtualRender.value) == null ? void 0 : _a.reset) == null ? void 0 : _b.call(_a);
        ctx.emit(EMIT_EVENTS.SETTING_CHANGE, {
          checked,
          size,
          height,
          fields
        });
      });
    }).on(EVENTS$1.ON_ROW_EXPAND_CLICK, (args) => {
      const {
        row,
        column,
        index: index2,
        rows,
        e
      } = args;
      ctx.emit(EMIT_EVENTS.ROW_EXPAND_CLICK, {
        row: getRowSourceData(row),
        column: getColumnSourceData(column),
        index: index2,
        rows,
        e
      });
      setRowExpand(row, !row[TABLE_ROW_ATTRIBUTE.ROW_EXPAND]);
    }).on(EVENTS$1.ON_ROW_CHECK, ({
      row,
      isAll,
      index: index2,
      value
    }) => {
      if (isAll) {
        toggleAllSelection(value);
        ctx.emit(EMIT_EVENTS.ROW_SELECT_ALL, {
          checked: value,
          data: props2.data
        });
      } else {
        toggleRowSelection(row, value);
        ctx.emit(EMIT_EVENTS.ROW_SELECT, {
          row: getRowSourceData(row),
          index: index2,
          checked: value,
          data: props2.data
        });
      }
      ctx.emit(EMIT_EVENTS.ROW_SELECT_CHANGE, {
        row: getRowSourceData(row),
        isAll,
        index: index2,
        checked: value,
        data: props2.data
      });
    });
    const handleScrollChanged = (args) => {
      var _a;
      const preBottom = (_a = reactiveSchema.pos.bottom) != null ? _a : 0;
      const pagination2 = args[1];
      const {
        translateX,
        translateY,
        pos = {}
      } = pagination2;
      reactiveSchema.scrollTranslateY = translateY;
      reactiveSchema.scrollTranslateX = translateX;
      reactiveSchema.pos = pos;
      const {
        bottom: bottom2
      } = pos;
      if (bottom2 <= 2 && preBottom > bottom2) {
        debounce(60, () => {
          ctx.emit(EMIT_EVENTS.SCROLL_BOTTOM, __spreadProps(__spreadValues({}, pos), {
            translateX,
            translateY
          }));
        }, true)();
      }
      updateOffsetRight();
    };
    const scrollTo = (option = {
      left: 0,
      top: 0
    }) => {
      var _a, _b;
      (_b = (_a = refVirtualRender.value) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, option);
    };
    onMounted(() => {
      if (props2.observerResize) {
        let observerIns = observerResize(root.value, () => {
          if (!root.value) {
            return;
          }
          if (props2.height === "100%" || props2.height === "auto") {
            resetTableHeight(root.value);
          }
          updateBorderClass(root.value);
          const offset2 = getColumnsWidthOffsetWidth();
          resolveColumnWidth(root.value, colgroups, 20, offset2);
        }, 180, true, props2.resizerWay);
        observerIns.start();
        onBeforeUnmount(() => {
          observerIns.disconnect();
          observerIns = null;
        });
      }
    });
    onBeforeUnmount(() => {
      tableRender.destroy();
    });
    const getRoot = () => root.value;
    ctx.expose({
      setRowExpand,
      clearSelection,
      toggleAllSelection,
      toggleRowSelection,
      getSelection,
      clearSort,
      scrollTo,
      getRoot
    });
    const tableBodyClass = computed(() => __spreadProps(__spreadValues({}, contentClass), {
      "__is-empty": !pageData.length
    }));
    const tableBodyContentClass = computed(() => ({
      [resolveClassName("table-body-content")]: true,
      "with-virtual-render": props2.virtualEnabled
    }));
    const resizeColumnClass = {
      column_drag_line: true,
      "offset-x": true
    };
    const resizeColumnStyle = computed(() => __spreadProps(__spreadValues({}, dragOffsetXStyle.value), {
      left: `${dragOffsetX.value - reactiveSchema.scrollTranslateX}px`
    }));
    const loadingRowClass = {
      "scroll-loading": true,
      _bottom: true
    };
    const fixedBottomBorder = computed(() => ({
      [resolveClassName("fixed-bottom-border")]: true,
      "_is-empty": !props2.data.length
    }));
    const columnGhostStyle = {
      zIndex: -1,
      width: 0,
      height: 0,
      display: "none"
    };
    const footerStyle = computed(() => ({
      "--footer-height": hasFooter.value ? `${props2.paginationHeight}px` : "0"
    }));
    const fixedContainerStyle = computed(() => __spreadValues({
      right: hasScrollYRef.value ? `${SCROLLY_WIDTH}px` : 0
    }, footerStyle.value));
    const {
      renderScrollLoading
    } = useScrollLoading(props2, ctx);
    const scrollClass = computed(() => props2.virtualEnabled ? {} : {
      scrollXName: "",
      scrollYName: ""
    });
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": tableClass.value,
        "style": wrapperStyle.value,
        "ref": root
      }, [
        createVNode("div", {
          "class": headClass,
          "style": headStyle.value
        }, [tableRender.renderTableHeadSchema()]),
        createVNode(BkVirtualRender, mergeProps({
          "ref": refVirtualRender,
          "lineHeight": tableRender.getRowHeight,
          "class": tableBodyClass.value,
          "style": contentStyle,
          "list": pageData
        }, scrollClass.value, {
          "contentClassName": tableBodyContentClass.value,
          "onContentScroll": handleScrollChanged,
          "throttleDelay": 0,
          "scrollEvent": true,
          "rowKey": props2.rowKey,
          "enabled": props2.virtualEnabled
        }), {
          default: (scope) => tableRender.renderTableBodySchema(scope.data || props2.data),
          afterSection: () => createVNode("div", {
            "class": fixedBottomBorder.value
          }, null)
        }),
        createVNode("div", {
          "class": fixedWrapperClass,
          "style": fixedContainerStyle.value
        }, [fixedColumns.value.map(({
          isExist,
          colPos,
          column
        }) => isExist ? "" : createVNode("div", {
          "class": resolveColumnClass(column, reactiveSchema.scrollTranslateX, tableOffsetRight.value),
          "style": resolveColumnStyle(colPos)
        }, null)), createVNode("div", {
          "class": resizeColumnClass,
          "style": resizeColumnStyle.value
        }, null), createVNode("div", {
          "class": loadingRowClass
        }, [renderScrollLoading()])]),
        createVNode("div", {
          "class": footerClass.value,
          "style": footerStyle.value
        }, [hasFooter.value && tableRender.renderTableFooter(localPagination.value)]),
        createVNode("div", {
          "style": columnGhostStyle
        }, [(_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a)])
      ]);
    };
  }
});
const BkTable = withInstall(Component$f);
withInstall(Column);
const BkTableColumn = withInstall(Column);
const INPUT_MIN_WIDTH = 12;
function usePage(pageSize) {
  const state = reactive({
    curPage: 1,
    totalSize: 0,
    totalPage: 0,
    pageSize,
    isPageLoading: false,
    curPageList: [],
    renderListPaged: []
  });
  const initPage = (allList = []) => {
    state.curPage = 1;
    state.totalSize = allList.length;
    state.totalPage = Math.ceil(state.totalSize / state.pageSize) || 1;
    const list = [];
    if (state.pageSize > 0) {
      for (let i2 = 0; i2 < state.totalSize; i2 += state.pageSize) {
        list.push(allList.slice(i2, i2 + state.pageSize));
      }
    }
    state.renderListPaged.splice(0, state.renderListPaged.length, ...list);
    state.curPageList.splice(0, state.curPageList.length, ...state.renderListPaged[state.curPage - 1] || []);
  };
  const pageChange = (page) => {
    state.curPage = page;
    state.curPageList.splice(state.curPageList.length, 0, ...state.renderListPaged[state.curPage - 1] || []);
    state.isPageLoading = false;
  };
  return {
    pageState: state,
    initPage,
    pageChange
  };
}
function useFlatList(props2) {
  const {
    useGroup,
    saveKey,
    displayKey,
    list
  } = toRefs(props2);
  const flatList = ref([]);
  const saveKeyMap = ref({});
  watch([useGroup, saveKey, displayKey, list], () => {
    flatList.value = [];
    let formatList = markRaw(list.value);
    if (useGroup.value) {
      formatList = formatList.reduce((formatList2, item) => {
        let children = [];
        if (item.children) {
          children = item.children.map((child) => __spreadValues({
            group: {
              groupId: item[saveKey.value],
              groupName: item[displayKey.value]
            }
          }, child));
        }
        return formatList2.concat(children);
      }, []);
    }
    flatList.value = formatList;
    saveKeyMap.value = formatList.reduce((acc, item) => {
      acc[item[saveKey.value]] = item;
      return acc;
    }, {});
  }, { immediate: true, deep: true });
  return {
    flatList,
    saveKeyMap
  };
}
const getCharLength = (str) => {
  const len = str.length;
  let bitLen = 0;
  for (let i2 = 0; i2 < len; i2++) {
    if ((str.charCodeAt(i2) & 65280) !== 0) {
      bitLen += 1;
    }
    bitLen += 1;
  }
  return bitLen;
};
const useTagsOverflow = (tagInputRef, collapseTags, selectedTagList) => {
  watch([selectedTagList, collapseTags], () => {
    calcOverflow();
  }, { flush: "post" });
  const overflowTagIndex = ref(null);
  const calcOverflow = () => {
    if (!collapseTags.value)
      return;
    overflowTagIndex.value = null;
    setTimeout(() => {
      const tags = Array.from(tagInputRef.value.querySelectorAll(".tag-item"));
      const tagIndexInSecondRow = tags.findIndex((currentTag, index2) => {
        if (!index2) {
          return false;
        }
        const previousTag = tags[index2 - 1];
        return previousTag.offsetTop !== currentTag.offsetTop;
      });
      overflowTagIndex.value = tagIndexInSecondRow > 0 ? tagIndexInSecondRow - 1 : null;
    });
  };
  return {
    overflowTagIndex
  };
};
var ListTagRender = defineComponent({
  name: "ListTagRender",
  props: {
    node: PropTypes.object,
    searchKey: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),
    displayKey: PropTypes.string,
    searchKeyword: PropTypes.string,
    tpl: {
      type: Function
    }
  },
  render() {
    const highlightKeyword = (value) => {
      if (this.searchKeyword) {
        const keywordReg = new RegExp(`(${this.searchKeyword})`, "i");
        return value.replace(keywordReg, '<strong class="highlight-text">$1</strong>');
      }
      return value;
    };
    if (this.tpl) {
      return this.tpl(this.node, highlightKeyword, h$1, this);
    }
    const displayText = this.node[this.displayKey];
    return createVNode("div", {
      "class": "lesscode-bk-selector-node"
    }, [createVNode("span", {
      "class": "text",
      "innerHTML": highlightKeyword(displayText)
    }, [displayText])]);
  }
});
const tagProps = () => ({
  modelValue: PropTypes.arrayOf(PropTypes.string).def([]),
  placeholder: PropTypes.string.def(""),
  list: PropTypes.arrayOf(PropTypes.object).def([]),
  disabled: PropTypes.bool.def(false),
  tooltipKey: PropTypes.string.def(""),
  saveKey: PropTypes.string.def("id"),
  displayKey: PropTypes.string.def("name"),
  hasDeleteIcon: PropTypes.bool.def(false),
  clearable: PropTypes.bool.def(true),
  trigger: j("treeTriggerType", {}).def("search"),
  searchKey: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).def("name"),
  useGroup: PropTypes.bool.def(false),
  allowCreate: PropTypes.bool.def(false),
  maxData: PropTypes.number.def(-1),
  maxResult: PropTypes.number.def(10),
  contentMaxHeight: PropTypes.number.def(300),
  contentWidth: PropTypes.number.def(190),
  separator: PropTypes.string.def(""),
  allowNextFocus: PropTypes.bool.def(true),
  allowAutoMatch: PropTypes.bool.def(false),
  showClearOnlyHover: PropTypes.bool.def(false),
  isAsyncList: PropTypes.bool.def(false),
  leftSpace: PropTypes.number.def(0),
  createTagValidator: {
    type: Function
  },
  filterCallback: {
    type: Function
  },
  tagTpl: {
    type: Function
  },
  tpl: {
    type: Function
  },
  pasteFn: {
    type: Function
  },
  withValidate: {
    type: Boolean,
    default: true
  },
  popoverProps: {
    type: Object,
    default: () => ({})
  },
  collapseTags: {
    type: Boolean,
    default: false
  },
  tagOverflowTips: {
    type: Object,
    default: () => ({})
  }
});
var TagRender = defineComponent({
  name: "TagRender",
  directives: {
    bkTooltips: tooltips
  },
  props: {
    node: PropTypes.object,
    displayKey: PropTypes.string,
    tpl: {
      type: Function
    },
    hasTips: {
      type: Boolean,
      default: false
    },
    tagOverflowTips: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props2) {
    const tagRef = ref();
    const isOverflow = ref(false);
    const overflowTips = computed(() => __spreadValues({
      boundary: "window",
      theme: "light",
      distance: 12,
      content: props2.node[props2.displayKey],
      disabled: props2.hasTips || !isOverflow.value
    }, props2.tagOverflowTips));
    onMounted(() => {
      isOverflow.value = checkOverflow(tagRef.value);
    });
    return {
      overflowTips,
      tagRef
    };
  },
  render() {
    if (this.tpl) {
      return this.tpl(this.node, h$1, this);
    }
    return withDirectives(createVNode("div", {
      "class": "tag",
      "ref": "tagRef"
    }, [createVNode("span", {
      "class": "text"
    }, [this.node[this.displayKey]])]), [[resolveDirective("bk-tooltips"), this.overflowTips]]);
  }
});
var Component$e = defineComponent({
  name: "TagInput",
  directives: {
    bkTooltips: tooltips
  },
  props: tagProps(),
  emits: ["update:modelValue", "change", "select", "focus", "blur", "remove", "removeAll", "input"],
  setup(props2, {
    emit
  }) {
    const formItem = useFormItem();
    const t2 = useLocale("tagInput");
    const state = reactive({
      isEdit: false,
      isHover: false,
      focusItemIndex: props2.allowCreate ? -1 : 0
    });
    const popoverProps = reactive(__spreadValues({
      isShow: false,
      width: 190,
      offset: {
        mainAxis: 4,
        crossAxis: 0
      }
    }, props2.popoverProps));
    const {
      maxResult
    } = toRefs(props2);
    const {
      pageState,
      initPage,
      pageChange
    } = usePage(maxResult);
    const curInputValue = ref("");
    const tagInputRef = ref(null);
    const bkTagSelectorRef = ref(null);
    const tagListRef = ref(null);
    const tagInputItemRef = ref(null);
    const selectorListRef = ref(null);
    const timer = ref(null);
    const showTagClose = computed(() => !props2.disabled && props2.hasDeleteIcon);
    const isSingleSelect = computed(() => props2.maxData === 1);
    const isShowPlaceholder = computed(() => listState.selectedTagList.length === 0 && curInputValue.value === "" && !state.isEdit);
    const placeholderText = computed(() => props2.placeholder || t2.value.placeholder);
    const isShowClear = computed(() => props2.clearable && !props2.disabled && listState.selectedTagList.length !== 0 && (props2.showClearOnlyHover ? state.isHover : true));
    const triggerClass = computed(() => ({
      "lesscode-bk-tag-input-trigger": true,
      active: state.isEdit,
      disabled: props2.disabled
    }));
    const listState = reactive({
      localList: [],
      tagListCache: [],
      selectedTagList: [],
      selectedTagListCache: []
    });
    const tagList = computed(() => listState.selectedTagList.map((tag2) => tag2[props2.saveKey]));
    const {
      flatList,
      saveKeyMap
    } = useFlatList(props2);
    const renderList = computed(() => {
      if (props2.useGroup) {
        const groupMap = {};
        pageState.curPageList.forEach((item, index2) => {
          item.__index__ = index2;
          if (!groupMap[item.group.groupId]) {
            groupMap[item.group.groupId] = {
              id: item.group.groupId,
              name: item.group.groupName,
              children: []
            };
          }
          groupMap[item.group.groupId].children.push(item);
        });
        return Object.keys(groupMap).map((key2) => groupMap[key2]);
      }
      return pageState.curPageList;
    });
    watch([() => flatList.value], () => {
      nextTick(() => {
        initData();
      });
    }, {
      deep: true
    });
    watch(() => props2.modelValue, (val) => {
      var _a;
      if (!shallowCompareArray(tagList.value, val)) {
        nextTick(() => {
          initData();
        });
        if (props2.withValidate) {
          (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
        }
      }
    });
    watch(curInputValue, lodash.exports.debounce(() => {
      const hasShowCount = pageState.curPageList.length !== 0;
      const {
        value
      } = curInputValue;
      if (value !== "" && hasShowCount || value === "" && props2.trigger === "focus" && hasShowCount) {
        popoverProps.isShow = true;
      } else if (props2.trigger !== "focus" || !hasShowCount) {
        popoverProps.isShow = false;
      }
    }, 150));
    watch(() => popoverProps.isShow, (show2) => {
      changePopoverOffset();
      if (show2) {
        if (selectorListRef.value) {
          nextTick(() => {
            selectorListRef.value.scrollTop = 0;
          });
          selectorListRef.value.removeEventListener("scroll", scrollHandler);
          selectorListRef.value.addEventListener("scroll", scrollHandler);
        }
      }
    });
    onMounted(() => {
      initData();
    });
    const changePopoverOffset = () => {
      var _a;
      popoverProps.offset.crossAxis = isSingleSelect.value ? 0 : (_a = tagInputItemRef.value) == null ? void 0 : _a.offsetLeft;
    };
    const scrollHandler = () => {
      if (pageState.isPageLoading || selectorListRef.value.scrollTop === 0) {
        return;
      }
      const {
        scrollTop: scrollTop2,
        offsetHeight,
        scrollHeight
      } = selectorListRef.value;
      if (scrollTop2 + offsetHeight >= scrollHeight) {
        const curPage = pageState.curPage + 1;
        if (curPage <= pageState.totalPage) {
          pageState.isPageLoading = true;
          setTimeout(() => {
            pageChange(curPage);
          }, 500);
        }
      }
    };
    const getSelectedTagNodes = () => {
      var _a;
      const nodes = Array.from(((_a = tagListRef.value) == null ? void 0 : _a.childNodes) || []);
      return nodes.filter((node) => ![Node.TEXT_NODE, Node.COMMENT_NODE].includes(node.nodeType));
    };
    const focusInputTrigger = (e) => {
      if (props2.disabled)
        return;
      if (e == null ? void 0 : e.target) {
        const {
          className
        } = e.target;
        if (className.indexOf("lesscode-bk-tag-input-trigger") > -1 || className.indexOf("tag-list") > -1) {
          tagListRef.value.appendChild(tagInputItemRef.value);
        }
      }
      clearTimeout(timer.value);
      if (isSingleSelect.value && tagList.value.length) {
        listState.tagListCache = [...tagList.value];
        listState.selectedTagListCache = [...listState.selectedTagList];
        curInputValue.value = listState.selectedTagListCache[0][props2.saveKey];
        removeTag(listState.selectedTagList[0], 0);
        handleInput();
      }
      state.isEdit = true;
      nextTick(() => {
        var _a;
        (_a = tagInputRef.value) == null ? void 0 : _a.focus();
        if (props2.trigger === "focus" && listState.localList.length !== 0) {
          filterData();
          if (popoverProps.isShow) {
            changePopoverOffset();
          } else {
            popoverProps.isShow = true;
          }
        }
      });
    };
    const initData = () => {
      const {
        saveKey,
        modelValue,
        displayKey,
        allowCreate,
        trigger,
        isAsyncList
      } = props2;
      listState.selectedTagList = [];
      listState.localList = flatList.value;
      if (modelValue.length) {
        const modelValueMap = {};
        listState.selectedTagList = modelValue.map((tag2) => {
          const item = saveKeyMap.value[tag2];
          modelValueMap[tag2] = 1;
          if (!item && allowCreate) {
            return {
              [saveKey]: tag2,
              [displayKey]: tag2
            };
          }
          return item;
        }).filter((item) => item);
        if (!isSingleSelect.value) {
          listState.localList = listState.localList.filter((val) => !modelValueMap[val[saveKey]]);
        }
      }
      if (isAsyncList && curInputValue.value) {
        filterData(curInputValue.value);
        if (pageState.curPageList.length) {
          popoverProps.isShow = true;
        }
        return;
      }
      if (trigger === "focus") {
        filterData();
      }
    };
    const filterData = (value = "") => {
      const {
        searchKey,
        filterCallback
      } = props2;
      const lowerCaseValue = value.toLowerCase().trim();
      if (lowerCaseValue === "") {
        initPage(listState.localList);
        return;
      }
      let filterData2 = [];
      if (typeof filterCallback === "function") {
        filterData2 = filterCallback(lowerCaseValue, searchKey, listState.localList) || [];
      } else {
        if (Array.isArray(searchKey)) {
          filterData2 = listState.localList.filter((item) => searchKey.some((keyword) => item[keyword].toLowerCase().indexOf(lowerCaseValue) > -1));
        } else {
          filterData2 = listState.localList.filter((item) => item[searchKey].toLowerCase().indexOf(lowerCaseValue) > -1);
        }
      }
      initPage(filterData2);
    };
    const activeClass = (data2, index2) => {
      const style2 = {
        "lesscode-bk-selector-actived": false,
        "lesscode-bk-selector-selected": tagList.value.includes(data2[props2.saveKey])
      };
      if (props2.useGroup) {
        style2["lesscode-bk-selector-actived"] = data2.__index__ === state.focusItemIndex;
      } else {
        style2["lesscode-bk-selector-actived"] = index2 === state.focusItemIndex;
      }
      return style2;
    };
    function shallowCompareArray(arr1, arr2) {
      if (arr1.length !== arr2.length)
        return false;
      return arr2.every((item, index2) => arr1[index2] === item);
    }
    const clearSingleCache = () => {
      listState.tagListCache = [];
      listState.selectedTagListCache = [];
      listState.selectedTagList = [];
    };
    const clearInput = () => {
      curInputValue.value = "";
    };
    const getTagInputItemSite = () => {
      if (isSingleSelect.value) {
        return 0;
      }
      const childNodes = getSelectedTagNodes();
      const index2 = childNodes.findIndex(({
        id
      }) => id === "tagInputItem");
      return index2 >= 0 ? index2 : 0;
    };
    const swapElementPositions = (newNode, referenceNode, isNextElementSibling = false) => {
      if (!referenceNode || !newNode)
        return;
      let swap = referenceNode;
      if (isNextElementSibling) {
        swap = referenceNode.nextElementSibling || null;
      }
      referenceNode.parentNode.insertBefore(newNode, swap);
    };
    const handleInput = (e) => {
      const {
        maxData,
        trigger,
        allowCreate
      } = props2;
      if (maxData === -1 || maxData > tagList.value.length) {
        const {
          value
        } = (e == null ? void 0 : e.target) ? e.target : curInputValue;
        const charLen = getCharLength(value);
        if (charLen) {
          filterData(value);
          tagInputRef.value.style.width = `${charLen * INPUT_MIN_WIDTH}px`;
        } else {
          if (trigger === "focus") {
            filterData();
          }
        }
      } else {
        handleBlur();
        curInputValue.value = "";
        popoverProps.isShow = false;
      }
      state.isEdit = true;
      state.focusItemIndex = allowCreate ? -1 : 0;
      emit("input", curInputValue.value);
    };
    const handleFocus = () => {
      var _a;
      popoverProps.width = isSingleSelect.value ? (_a = bkTagSelectorRef.value) == null ? void 0 : _a.clientWidth : props2.contentWidth;
      emit("focus");
    };
    const handleBlur = () => {
      timer.value = setTimeout(() => {
        var _a;
        const inputValue = curInputValue.value;
        clearInput();
        state.isEdit = false;
        if (isSingleSelect.value) {
          const [oldValue] = listState.tagListCache;
          if (inputValue && inputValue === oldValue && listState.selectedTagListCache.length) {
            addTag(listState.selectedTagListCache[0], "select");
          } else {
            handleChange("remove");
          }
        } else if (props2.allowAutoMatch && inputValue) {
          const matchItem = pageState.curPageList.find((item) => {
            if (Array.isArray(props2.searchKey)) {
              const searchValue = props2.searchKey.map((key2) => item[key2]);
              return searchValue.includes(inputValue);
            }
            return item[props2.searchKey] === inputValue;
          });
          if (matchItem) {
            handleTagSelected(matchItem, "select");
          } else if (props2.allowCreate) {
            handleTagSelected(inputValue, "custom");
          }
        }
        popoverProps.isShow = false;
        emit("blur", inputValue, tagList.value);
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "blur");
      }, 200);
    };
    const handleTagSelected = (item, type, e) => {
      e == null ? void 0 : e.stopPropagation();
      if (!item || item.disabled) {
        return;
      }
      if (isSingleSelect.value) {
        clearSingleCache();
      }
      addTag(item, type);
      handleChange("select");
      clearInput();
      popoverProps.isShow = false;
    };
    const handleTagRemove = (data2, index2, e) => {
      e == null ? void 0 : e.stopPropagation();
      removeTag(data2, index2);
      clearInput();
      handleChange("remove", data2);
      tagInputRef.value.style.width = `${INPUT_MIN_WIDTH}px`;
    };
    const handleChange = (type, data2) => {
      emit(type, data2);
      emit("update:modelValue", tagList.value);
      emit("change", tagList.value);
    };
    const handleClear = (e) => {
      e.stopPropagation();
      const removeList = listState.selectedTagList;
      listState.selectedTagList = [];
      const existList = removeList.filter((item) => saveKeyMap.value[item[props2.saveKey]]);
      if ((props2.allowCreate && existList.length !== 0 || !props2.allowCreate) && !isSingleSelect.value) {
        listState.localList.push(...existList);
      }
      handleChange("removeAll");
    };
    const updateScrollTop = () => {
      const panelInfo = {
        height: selectorListRef.value.clientHeight,
        yAxis: selectorListRef.value.getBoundingClientRect().y
      };
      nextTick(() => {
        const activeObj = selectorListRef.value.querySelector(".lesscode-bk-selector-actived");
        if (!activeObj) {
          return;
        }
        const activeInfo = {
          height: activeObj.clientHeight,
          yAxis: activeObj.getBoundingClientRect().y
        };
        if (activeInfo.yAxis < panelInfo.yAxis) {
          selectorListRef.value.scrollTop = selectorListRef.value.scrollTop - (panelInfo.yAxis - activeInfo.yAxis);
        }
        const distanceToBottom = activeInfo.yAxis + activeInfo.height - panelInfo.yAxis;
        if (distanceToBottom > panelInfo.height) {
          selectorListRef.value.scrollTop = selectorListRef.value.scrollTop + distanceToBottom - panelInfo.height;
        }
      });
    };
    const backspaceHandler = (index2, target) => {
      const nodes = getSelectedTagNodes();
      swapElementPositions(tagInputItemRef.value, nodes[index2 - 1]);
      listState.selectedTagList.splice(index2 - 1, 1);
      focusInputTrigger();
      const isExistInit = saveKeyMap.value[target[props2.saveKey]];
      if ((props2.allowCreate && isExistInit || !props2.allowCreate) && !isSingleSelect.value) {
        listState.localList.push(target);
      }
      tagInputRef.value = `${INPUT_MIN_WIDTH}px`;
      handleChange("remove");
    };
    const handleKeydown = (e) => {
      if (pageState.isPageLoading) {
        return;
      }
      let target;
      const val = e.target.value;
      const valLen = getCharLength(val);
      const tagInputItemIndex = getTagInputItemSite();
      const nodes = getSelectedTagNodes();
      switch (e.code) {
        case "ArrowUp":
          e.preventDefault();
          if (!popoverProps.isShow) {
            return;
          }
          state.focusItemIndex = state.focusItemIndex - 1;
          state.focusItemIndex = state.focusItemIndex < 0 ? -1 : state.focusItemIndex;
          if (state.focusItemIndex === -1) {
            state.focusItemIndex = pageState.curPageList.length - 1;
          }
          updateScrollTop();
          break;
        case "ArrowDown":
          e.preventDefault();
          if (!popoverProps.isShow) {
            return;
          }
          state.focusItemIndex = state.focusItemIndex + 1;
          state.focusItemIndex = state.focusItemIndex > pageState.curPageList.length - 1 ? pageState.curPageList.length : state.focusItemIndex;
          if (state.focusItemIndex === pageState.curPageList.length) {
            state.focusItemIndex = 0;
          }
          updateScrollTop();
          break;
        case "ArrowLeft":
          state.isEdit = true;
          if (!valLen) {
            if (tagInputItemIndex < 1) {
              return;
            }
            swapElementPositions(tagInputItemRef.value, nodes[tagInputItemIndex - 1]);
            focusInputTrigger();
          }
          break;
        case "ArrowRight":
          state.isEdit = true;
          if (!valLen) {
            if (tagInputItemIndex === nodes.length - 1) {
              return;
            }
            swapElementPositions(nodes[tagInputItemIndex + 1], tagInputItemRef.value);
            focusInputTrigger();
          }
          break;
        case "Enter":
        case "NumpadEnter":
          if (!props2.allowCreate && popoverProps.isShow || props2.allowCreate && state.focusItemIndex >= 0 && popoverProps.isShow) {
            handleTagSelected(pageState.curPageList[state.focusItemIndex], "select", e);
          } else if (props2.allowCreate && curInputValue.value.trim()) {
            handleTagSelected(curInputValue.value, "custom", e);
          }
          e.preventDefault();
          break;
        case "Backspace":
          if (tagInputItemIndex !== 0 && !curInputValue.value) {
            target = listState.selectedTagList[tagInputItemIndex - 1];
            backspaceHandler(tagInputItemIndex, target);
          }
          break;
      }
    };
    const defaultPasteFn = (value) => {
      const target = [];
      const textArr = value.split(";");
      const regx = /^[a-zA-Z][a-zA-Z_]*/g;
      textArr.forEach((item) => {
        const matchValue = item.match(regx);
        if (matchValue) {
          const finalItem = matchValue.join("");
          target.push({
            [props2.saveKey]: finalItem,
            [props2.displayKey]: finalItem
          });
        }
      });
      return target;
    };
    const handlePaste = (e) => {
      e.preventDefault();
      if (isSingleSelect.value) {
        return false;
      }
      const {
        maxData,
        saveKey,
        displayKey,
        pasteFn,
        allowCreate
      } = props2;
      const value = e.clipboardData.getData("text");
      const valArr = pasteFn ? pasteFn(value) : defaultPasteFn(value);
      let tags = valArr.map((value2) => value2[saveKey]);
      if (tags.length) {
        const nodes = getSelectedTagNodes();
        const index2 = getTagInputItemSite();
        const localInitData = listState.localList.map((data2) => data2[saveKey]);
        tags = tags.filter((tag2) => {
          const canSelected = (tag2 == null ? void 0 : tag2.trim()) && !tagList.value.includes(tag2);
          return allowCreate ? canSelected : canSelected && localInitData.includes(tag2);
        });
        if (maxData !== -1) {
          const selectedLength = listState.selectedTagList.length;
          if (selectedLength < maxData) {
            const differ = maxData - selectedLength;
            if (tags.length > differ) {
              tags = [...tags.slice(0, differ)];
            }
          } else {
            tags = [];
          }
        }
        const localTags = allowCreate ? tags.map((tag2) => {
          const localTag = listState.localList.find((localTag2) => localTag2[saveKey] === tag2);
          return localTag != null ? localTag : {
            [saveKey]: tag2,
            [displayKey]: tag2
          };
        }) : listState.localList.filter((tag2) => tags.includes(tag2[saveKey]));
        if (tags.length) {
          listState.selectedTagList.splice(index2, 0, ...localTags);
          swapElementPositions(tagInputItemRef.value, nodes[index2]);
          tagInputRef.value.style.width = `${INPUT_MIN_WIDTH}px`;
          listState.localList = listState.localList.filter((val) => !tags.includes(val[saveKey]));
          handleChange("select");
          focusInputTrigger();
        }
      }
    };
    const tagFocus = (e) => {
      if (props2.disabled) {
        return;
      }
      swapElementPositions(tagInputItemRef.value, e.currentTarget, true);
      tagInputRef.value.style.width = `${INPUT_MIN_WIDTH}px`;
      popoverProps.isShow && changePopoverOffset();
    };
    const addTag = (item, type) => {
      if (listState.selectedTagList.length >= props2.maxData && props2.maxData !== -1)
        return;
      const {
        separator: separator2,
        saveKey,
        displayKey,
        createTagValidator
      } = props2;
      const targetIndex = getTagInputItemSite();
      let moveCount = 1;
      let isSelected = false;
      let newValue;
      const validateTag = (value) => {
        if (typeof createTagValidator === "function") {
          return createTagValidator(value);
        }
        return true;
      };
      if (type === "custom") {
        if (separator2) {
          let tags = item.split(separator2);
          tags = tags.filter((tag2) => (tag2 == null ? void 0 : tag2.trim()) && !tagList.value.includes(tag2) && validateTag(tag2));
          const localTags = tags.map((tag2) => saveKeyMap.value[tag2] || {
            [saveKey]: tag2,
            [displayKey]: tag2
          });
          if (tags.length) {
            listState.selectedTagList.splice(targetIndex, 0, ...localTags);
            moveCount = localTags.length;
            isSelected = true;
          }
        } else {
          const isObject2 = typeof item === "object";
          newValue = isObject2 ? item[saveKey] : item.trim();
          newValue = newValue.replace(/\s+/g, "");
          if (newValue !== void 0 && !tagList.value.includes(newValue) && validateTag(newValue)) {
            const localItem = saveKeyMap.value[newValue] || (isObject2 ? item : {
              [saveKey]: newValue,
              [displayKey]: newValue
            });
            listState.selectedTagList.splice(targetIndex, 0, localItem);
            isSelected = true;
          }
        }
      } else if (item) {
        newValue = item[saveKey];
        if (newValue !== void 0 && !tagList.value.includes(newValue)) {
          listState.selectedTagList.splice(targetIndex, 0, item);
          isSelected = true;
        }
      }
      if (isSelected) {
        nextTick(() => {
          for (let count = 1; count <= moveCount; count++) {
            const nodes = getSelectedTagNodes();
            const site = nodes[targetIndex + count];
            swapElementPositions(site, tagInputItemRef.value);
          }
          tagInputRef.value.style.width = `${INPUT_MIN_WIDTH}px`;
          if (!isSingleSelect.value) {
            props2.allowNextFocus && focusInputTrigger();
            const selectedMap = tagList.value.reduce((acc, tag2) => {
              acc[tag2] = 1;
              return acc;
            }, {});
            listState.localList = listState.localList.filter((val) => !selectedMap[val[saveKey]]);
          }
        });
      }
    };
    const removeTag = (data2, index2) => {
      listState.selectedTagList.splice(index2, 1);
      const isExistInit = saveKeyMap.value[data2[props2.saveKey]];
      if ((props2.allowCreate && isExistInit || !props2.allowCreate) && !isSingleSelect.value) {
        listState.localList.push(data2);
      }
    };
    const localCollapseTags = computed(() => props2.collapseTags ? props2.collapseTags && !state.isEdit : props2.collapseTags);
    const {
      overflowTagIndex
    } = useTagsOverflow(bkTagSelectorRef, localCollapseTags, tagList);
    return __spreadProps(__spreadValues(__spreadValues(__spreadValues({
      popoverProps
    }, toRefs(state)), toRefs(listState)), toRefs(pageState)), {
      isShowPlaceholder,
      isShowClear,
      placeholderText,
      curInputValue,
      renderList,
      showTagClose,
      tagInputRef,
      bkTagSelectorRef,
      tagListRef,
      tagInputItemRef,
      selectorListRef,
      triggerClass,
      overflowTagIndex,
      localCollapseTags,
      focusInputTrigger,
      activeClass,
      handleInput,
      handleFocus,
      handleBlur,
      handleTagSelected,
      handleTagRemove,
      handleClear,
      tagFocus,
      handleKeydown,
      handlePaste
    });
  },
  render() {
    return createVNode("div", {
      "class": "lesscode-bk-tag-input",
      "ref": "bkTagSelectorRef",
      "onClick": this.focusInputTrigger,
      "onMouseenter": () => this.isHover = true,
      "onMouseleave": () => this.isHover = false
    }, [createVNode(BkPopover, mergeProps({
      "theme": "light lesscode-bk-tag-input-popover-content",
      "trigger": "manual",
      "placement": "bottom-start",
      "arrow": false
    }, this.popoverProps), {
      default: () => {
        var _a, _b, _c;
        return createVNode("div", {
          "class": this.triggerClass
        }, [createVNode("ul", {
          "class": "tag-list",
          "ref": "tagListRef",
          "style": {
            marginLeft: `${this.leftSpace}px`
          }
        }, [this.selectedTagList.map((item, index2) => {
          const tooltips2 = {
            boundary: "window",
            theme: "light",
            distance: 12,
            content: item[this.tooltipKey],
            disabled: !this.tooltipKey
          };
          const isOverflow = this.localCollapseTags && this.overflowTagIndex && index2 >= this.overflowTagIndex;
          return withDirectives(createVNode("li", {
            "class": "tag-item",
            "style": {
              display: isOverflow ? "none" : ""
            },
            "onClick": this.tagFocus
          }, [createVNode(TagRender, {
            "node": item,
            "tpl": this.tagTpl,
            "displayKey": this.displayKey,
            "hasTips": !!this.tooltipKey,
            "tagOverflowTips": this.tagOverflowTips
          }, null), this.showTagClose ? createVNode(error, {
            "class": "remove-tag",
            "onClick": this.handleTagRemove.bind(this, item, index2)
          }, null) : null]), [[resolveDirective("bk-tooltips"), tooltips2]]);
        }), withDirectives(createVNode("li", {
          "ref": "tagInputItemRef",
          "id": "tagInputItem",
          "class": "tag-input-item",
          "role": "input"
        }, [withDirectives(createVNode("input", {
          "type": "text",
          "class": "tag-input",
          "ref": "tagInputRef",
          "onUpdate:modelValue": ($event) => this.curInputValue = $event,
          "onInput": this.handleInput,
          "onFocus": this.handleFocus,
          "onBlur": this.handleBlur,
          "onKeydown": this.handleKeydown,
          "onPaste": this.handlePaste
        }, null), [[vModelText, this.curInputValue]])]), [[vShow, this.isEdit]]), !!this.overflowTagIndex && this.localCollapseTags && createVNode("li", {
          "class": "tag-item"
        }, [createVNode("div", {
          "class": "tag"
        }, [createVNode("span", {
          "class": "text"
        }, [createTextVNode("+"), this.selectedTagList.length - this.overflowTagIndex])])])]), withDirectives(createVNode("p", {
          "class": "placeholder"
        }, [this.placeholderText]), [[vShow, this.isShowPlaceholder]]), (_c = (_b = (_a = this.$slots) == null ? void 0 : _a.suffix) == null ? void 0 : _b.call(_a)) != null ? _c : this.isShowClear && createVNode(close$1, {
          "class": "clear-icon",
          "onClick": this.handleClear
        }, null)]);
      },
      content: () => createVNode("div", {
        "class": "lesscode-bk-selector-list"
      }, [createVNode("ul", {
        "ref": "selectorListRef",
        "style": {
          "max-height": `${this.contentMaxHeight}px`
        },
        "class": "outside-ul"
      }, [this.renderList.map((group, index2) => this.useGroup ? createVNode("li", {
        "class": "lesscode-bk-selector-group-item"
      }, [createVNode("span", {
        "class": "group-name"
      }, [group.name, createTextVNode(" ("), group.children.length, createTextVNode(")")]), createVNode("ul", {
        "class": "lesscode-bk-selector-group-list-item"
      }, [group.children.map((item, index3) => createVNode("li", {
        "class": ["lesscode-bk-selector-list-item", {
          disabled: item.disabled
        }, this.activeClass(item, index3)],
        "onClick": this.handleTagSelected.bind(this, item, "select")
      }, [createVNode(ListTagRender, {
        "node": item,
        "displayKey": this.displayKey,
        "tpl": this.tpl,
        "searchKey": this.searchKey,
        "searchKeyword": this.curInputValue
      }, null)]))])]) : createVNode("li", {
        "class": ["lesscode-bk-selector-list-item", {
          disabled: group.disabled
        }, this.activeClass(group, index2)],
        "onClick": this.handleTagSelected.bind(this, group, "select")
      }, [createVNode(ListTagRender, {
        "node": group,
        "displayKey": this.displayKey,
        "tpl": this.tpl,
        "searchKey": this.searchKey,
        "searchKeyword": this.curInputValue
      }, null)])), this.isPageLoading ? createVNode("li", {
        "class": "lesscode-bk-selector-list-item loading"
      }, [createVNode(BkLoading, {
        "theme": "primary",
        "size": BkLoadingSize.Small
      }, null)]) : null])])
    })]);
  }
});
const TagInput = withInstall(Component$e);
const dividerProps = {
  direction: directionType(),
  align: alignType().def(AlignEnum.CENTER),
  color: PropTypes.string.def("#dde4eb"),
  width: PropTypes.number.def(1),
  type: lineStyleType()
};
var bkDivider = defineComponent({
  name: "Divider",
  props: dividerProps,
  render() {
    const styles = () => {
      if (this.direction === "vertical") {
        return {
          borderRight: `${this.width}px ${this.type} ${this.color}`
        };
      }
      return {
        borderBottom: `${this.width}px ${this.type} ${this.color}`
      };
    };
    let slots;
    if (this.$slots.default) {
      slots = createVNode("div", {
        "class": [resolveClassName("divider-info"), resolveClassName(`divider-info-${this.align}`)]
      }, [this.$slots.default()]);
    }
    return createVNode("div", {
      "class": [resolveClassName("divider"), resolveClassName(`divider-${this.direction}`)],
      "style": styles()
    }, [slots]);
  }
});
const BkDivider = withInstall(bkDivider);
var TabTypeEnum = /* @__PURE__ */ ((TabTypeEnum2) => {
  TabTypeEnum2["CARD"] = "card";
  TabTypeEnum2["BORDER_CARD"] = "border-card";
  TabTypeEnum2["UNBORDER_CARD"] = "unborder-card";
  TabTypeEnum2["CARD_TAB"] = "card-tab";
  TabTypeEnum2["CARD_GRID"] = "card-grid";
  return TabTypeEnum2;
})(TabTypeEnum || {});
var PositionEnum = /* @__PURE__ */ ((PositionEnum2) => {
  PositionEnum2["LEFT"] = "left";
  PositionEnum2["RIGHT"] = "right";
  PositionEnum2["TOP"] = "top";
  return PositionEnum2;
})(PositionEnum || {});
const TabPositionType = j("position", {}).def("top");
var SortTypeEnum = /* @__PURE__ */ ((SortTypeEnum2) => {
  SortTypeEnum2["REPLACE"] = "replace";
  SortTypeEnum2["INSERT"] = "insert";
  return SortTypeEnum2;
})(SortTypeEnum || {});
const SortTypeUnion = j("sortType", {}).def("replace");
const tabNavEventProps = {
  tabAdd: {
    type: Function,
    default: () => ({})
  },
  tabChange: {
    type: Function,
    default: (name) => name
  },
  tabRemove: {
    type: Function,
    default: (name) => name
  },
  tabSort: {
    type: Function,
    default: () => ({})
  },
  tabDrag: {
    type: Function,
    default: () => ({})
  }
};
const tabPanelProps = {
  name: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def(""),
  label: PropTypes.string || PropTypes.func,
  tips: PropTypes.string,
  closable: PropTypes.bool,
  visible: PropTypes.bool.def(true),
  disabled: PropTypes.bool,
  sortable: PropTypes.bool,
  renderDirective: renderDirectiveType(),
  panel: PropTypes.string || PropTypes.func
};
const tabProps = {
  active: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def(""),
  type: j("type", {}).def("border-card"),
  tabPosition: TabPositionType,
  closable: Boolean,
  addable: Boolean,
  sortable: Boolean,
  sortType: SortTypeUnion,
  labelHeight: PropTypes.number.def(50),
  scrollStep: PropTypes.number.def(200),
  extCls: PropTypes.string.def(""),
  validateActive: PropTypes.bool.def(true),
  showHeader: PropTypes.bool.def(true),
  changeOnHover: PropTypes.bool.def(false),
  changeOnHoverDelay: PropTypes.number.def(1e3),
  activeBarSize: PropTypes.number.def(2),
  activeBarColor: PropTypes.string.def("#3a84ff")
};
const tabNavProps = __spreadValues({
  active: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def(""),
  type: j("type", {}).def("border-card"),
  activeBarColor: PropTypes.string.def("#3a84ff"),
  activeBarSize: PropTypes.number.def(2),
  panels: {
    type: Array,
    default: () => []
  },
  tabPosition: TabPositionType,
  closable: Boolean,
  addable: Boolean,
  sortable: Boolean,
  sortType: SortTypeUnion,
  labelHeight: PropTypes.number.def(50),
  scrollStep: PropTypes.number.def(200),
  validateActive: PropTypes.bool.def(true),
  changeOnHover: PropTypes.bool.def(false),
  changeOnHoverDelay: PropTypes.number.def(1e3)
}, tabNavEventProps);
var TabNav = defineComponent({
  name: "TabNav",
  directives: {
    bkTooltips: tooltips
  },
  props: tabNavProps,
  setup(props2) {
    const activeRef = ref(null);
    const activeBarStyle = computed(() => {
      const initStyle = {
        width: 0,
        height: 0,
        bottom: 0,
        left: 0
      };
      if (!activeRef.value) {
        return initStyle;
      }
      if ([PositionEnum.LEFT, PositionEnum.RIGHT].includes(props2.tabPosition)) {
        const {
          clientHeight,
          offsetTop
        } = activeRef.value;
        const style2 = {
          width: `${props2.activeBarSize}px`,
          height: `${clientHeight}px`,
          top: `${offsetTop}px`,
          background: props2.activeBarColor
        };
        if (props2.tabPosition === PositionEnum.LEFT) {
          style2.right = 0;
        } else {
          style2.left = 0;
        }
        return style2;
      }
      if (props2.type === TabTypeEnum.UNBORDER_CARD) {
        const {
          clientWidth,
          offsetLeft
        } = activeRef.value;
        return {
          width: `${clientWidth}px`,
          height: `${props2.activeBarSize}px`,
          left: `${offsetLeft}px`,
          bottom: 0,
          background: props2.activeBarColor
        };
      }
      return initStyle;
    });
    const navs = computed(() => {
      if (!Array.isArray(props2.panels) || !props2.panels.length) {
        return [];
      }
      const list = [];
      let hasFindActive = false;
      props2.panels.filter((item, index2) => {
        if (!item.props) {
          return null;
        }
        const {
          name,
          label,
          closable,
          visible,
          disabled,
          sortable,
          tips
        } = item.props;
        if (!visible) {
          return false;
        }
        if (props2.active === name) {
          hasFindActive = true;
        }
        const renderLabel = (label2) => {
          if (item.slots.label) {
            return h$1(item.slots.label);
          }
          if ([void 0, ""].includes(label2)) {
            return `\u9009\u9879\u5361${index2 + 1}`;
          }
          if (typeof label2 === "string") {
            return label2;
          }
          if (typeof label2 === "function") {
            return h$1(label2);
          }
          return label2;
        };
        list.push({
          name,
          closable,
          visible,
          disabled,
          sortable,
          tips,
          tabLabel: renderLabel(label)
        });
        return true;
      });
      if (!hasFindActive && props2.validateActive) {
        props2.panels[0].props && props2.tabChange(props2.panels[0].props.name);
      }
      return list;
    });
    const dragenterIndex = ref(-1);
    const dragStartIndex = ref(-1);
    const draggingEle = ref("");
    const distinctRoots = (el1, el2) => el1 === el2;
    const methods = {
      handleTabAdd(e) {
        props2.tabAdd(e);
      },
      dragstart(index2, $event) {
        dragStartIndex.value = index2;
        draggingEle.value = props2.guid;
        Object.assign($event.dataTransfer, {
          effectAllowed: "move"
        });
        props2.tabDrag(index2, $event);
      },
      dragenter(index2) {
        if (distinctRoots(draggingEle.value, props2.guid)) {
          dragenterIndex.value = index2;
        }
      },
      dragend() {
        dragenterIndex.value = -1;
        dragStartIndex.value = -1;
        draggingEle.value = null;
      },
      drop(index2, sortType) {
        if (!distinctRoots(draggingEle.value, props2.guid)) {
          return false;
        }
        props2.tabSort(dragStartIndex.value, index2, sortType);
      },
      handleTabChange(name) {
        props2.tabChange(name);
      },
      handleTabRemove(index2, panel) {
        props2.tabRemove(index2, panel);
      }
    };
    return __spreadProps(__spreadValues({}, methods), {
      activeRef,
      activeBarStyle,
      navs,
      dragenterIndex,
      dragStartIndex,
      draggingEle,
      guid: Math.random().toString(16).substr(4) + Math.random().toString(16).substr(4)
    });
  },
  render() {
    const {
      active,
      closable,
      addable,
      sortable,
      sortType,
      labelHeight,
      dragstart,
      dragenter,
      dragend,
      drop
    } = this;
    const renderNavs = () => this.navs.map((item, index2) => {
      if (!item) {
        return null;
      }
      const {
        name,
        disabled,
        tabLabel
      } = item;
      const getNavItemClass = () => {
        const classNames = [resolveClassName("tab-header-item")];
        if (disabled) {
          classNames.push(resolveClassName("tab-header--disabled"));
        }
        if (active === name) {
          classNames.push(resolveClassName("tab-header--active"));
        }
        return classNames.join(" ");
      };
      const getValue = (curentValue, parentValue) => !disabled && (curentValue || parentValue);
      return withDirectives(createVNode("div", {
        "key": name,
        "onClick": () => !disabled && this.handleTabChange(name),
        "draggable": getValue(item.sortable, sortable),
        "onDragstart": (e) => dragstart(index2, e),
        "ref": active === name ? "activeRef" : "",
        "onDragenter": (e) => {
          e.preventDefault();
          dragenter(index2);
        },
        "onDragleave": (e) => {
          e.preventDefault();
        },
        "onDragover": (e) => {
          e.preventDefault();
        },
        "onDragend": (e) => {
          e.preventDefault();
          dragend();
        },
        "onDrop": (e) => {
          e.preventDefault();
          drop(index2, sortType);
        },
        "class": getNavItemClass()
      }, [createVNode("div", null, [tabLabel]), getValue(item.closable, closable) ? createVNode("span", {
        "class": resolveClassName("tab-header--close"),
        "onClick": () => this.handleTabRemove(index2, item)
      }, [createVNode(close$1, null, null)]) : ""]), [[resolveDirective("bk-tooltips"), {
        content: item.tips,
        disabled: !item.tips
      }]]);
    });
    const renderOperation = () => {
      var _a, _b;
      const list = [];
      if (typeof this.$slots.add === "function") {
        list.push((_b = (_a = this.$slots).add) == null ? void 0 : _b.call(_a, h$1));
      } else if (addable) {
        list.push(createVNode("div", {
          "onClick": this.handleTabAdd
        }, [createVNode(plus, {
          "style": "display:flex;",
          "width": 26,
          "height": 26
        }, null)]));
      }
      if (list.length) {
        return createVNode("div", {
          "class": resolveClassName("tab-header-operation")
        }, [list.map((item, index2) => createVNode("div", {
          "class": resolveClassName("tab-header-item"),
          "key": index2
        }, [item]))]);
      }
      return null;
    };
    const renderActiveBar = () => {
      if (this.type === TabTypeEnum.UNBORDER_CARD) {
        return createVNode("div", {
          "style": this.activeBarStyle,
          "class": resolveClassName("tab-header-active-bar")
        }, null);
      }
      return "";
    };
    const setting = typeof this.$slots.setting === "function" ? createVNode("div", {
      "class": resolveClassName("tab-header-setting")
    }, [this.$slots.setting()]) : null;
    const operations = renderOperation();
    return createVNode("div", {
      "style": {
        lineHeight: `${labelHeight}px`
      },
      "class": resolveClassName("tab-header")
    }, [createVNode("div", {
      "class": [resolveClassName("tab-header-nav"), operations || setting ? "tab-header-auto" : ""]
    }, [renderActiveBar(), renderNavs()]), operations, setting]);
  }
});
var Tab = defineComponent({
  name: "Tab",
  components: {
    TabNav
  },
  props: tabProps,
  emits: [
    "add-panel",
    "tab-change",
    "remove-panel",
    "sort-change",
    "on-drag-tab",
    "add",
    "change",
    "remove",
    "update:active",
    "sort",
    "drag"
  ],
  setup(_props, {
    slots,
    emit
  }) {
    const isMounted = ref(false);
    const panels = ref([]);
    const instance = getCurrentInstance();
    const getPaneInstanceFromSlot = (vnode, panelInstanceList = []) => {
      const {
        children
      } = vnode;
      (children || []).forEach((node) => {
        let {
          type
        } = node;
        type = type.name || type;
        if (type === "TabPanel" && node.component) {
          panelInstanceList.push(node.component);
        } else if (type === Fragment || type === "template") {
          getPaneInstanceFromSlot(node, panelInstanceList);
        }
      });
      return panelInstanceList;
    };
    const setPanelInstances = () => {
      if (slots.default) {
        const {
          children
        } = instance.subTree.children[1];
        if (!children)
          return;
        const content = children[0];
        const panelInstanceList = getPaneInstanceFromSlot(content);
        const isChanged = panelInstanceList.length !== panels.value.length;
        if (isChanged) {
          panels.value = panelInstanceList;
        }
      }
    };
    onMounted(() => {
      setPanelInstances();
      isMounted.value = true;
      onUpdated(() => {
        setPanelInstances();
      });
    });
    const methods = {
      tabAdd(e) {
        emit("add", {
          e
        });
        emit("add-panel", {
          e
        });
      },
      tabChange(name) {
        emit("change", name);
        emit("tab-change", name);
        emit("update:active", name);
      },
      tabRemove(index2, panel) {
        emit("remove", index2, panel);
        emit("remove-panel", index2, panel);
      },
      tabSort(dragTabIndex, dropTabIndex, sortType) {
        const list = panels.value;
        if (sortType === SortTypeEnum.INSERT) {
          if (dragTabIndex < dropTabIndex) {
            list.splice(dropTabIndex + 1, 0, panels[dragTabIndex]);
            list.splice(dragTabIndex, 1);
          } else if (dragTabIndex > dropTabIndex) {
            list.splice(dropTabIndex, 0, panels[dragTabIndex]);
            list.splice(dragTabIndex + 1, 1);
          } else {
            return false;
          }
        } else {
          const swap = list[dropTabIndex];
          list[dropTabIndex] = list[dragTabIndex];
          list[dragTabIndex] = swap;
        }
        panels.value = [...list];
        emit("sort", dragTabIndex, dropTabIndex, sortType);
        emit("sort-change", dragTabIndex, dropTabIndex, sortType);
      },
      tabDrag(dragTabIndex, dragEvent) {
        emit("drag", dragTabIndex, dragEvent);
        emit("on-drag-tab", dragTabIndex, dragEvent);
      }
    };
    return __spreadProps(__spreadValues({}, methods), {
      isMounted,
      panels
    });
  },
  render() {
    var _a, _b;
    const getTabBoxClass = () => {
      const arr = [resolveClassName("tab"), this.extCls];
      if (this.tabPosition === PositionEnum.TOP) {
        arr.push(resolveClassName(`tab--${this.tabPosition}`), resolveClassName(`tab--${this.type}`));
      } else {
        arr.push(resolveClassName(`tab--${this.tabPosition}`));
        if (this.type === TabTypeEnum.CARD_TAB) {
          arr.push(resolveClassName("tab--vertical-tab"));
        }
      }
      return arr;
    };
    const getTabHeader = () => {
      const {
        panels,
        active,
        type,
        closable,
        addable,
        sortable,
        sortType,
        labelHeight,
        scrollStep,
        validateActive,
        changeOnHover,
        changeOnHoverDelay,
        tabPosition,
        activeBarSize,
        activeBarColor,
        tabAdd,
        tabChange,
        tabRemove,
        tabSort,
        tabDrag
      } = this;
      const props2 = {
        panels,
        active,
        type,
        closable,
        addable,
        sortable,
        sortType,
        labelHeight,
        scrollStep,
        validateActive,
        changeOnHover,
        changeOnHoverDelay,
        tabPosition,
        activeBarSize,
        activeBarColor,
        tabAdd,
        tabChange,
        tabRemove,
        tabSort,
        tabDrag
      };
      if (!panels || !Array.isArray(panels)) {
        return null;
      }
      return createVNode(TabNav, props2, this.$slots);
    };
    return createVNode("div", {
      "class": getTabBoxClass()
    }, [getTabHeader(), createVNode("div", {
      "class": resolveClassName("tab-content")
    }, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)])]);
  }
});
var TabPanel = defineComponent({
  name: "TabPanel",
  props: tabPanelProps,
  render() {
    const active = this.name === this.$parent.active;
    const getContent = () => {
      if (!this.visible || this.renderDirective === "if" && !active) {
        return null;
      }
      if (typeof this.panel === "function") {
        return this.panel(h$1);
      }
      if (typeof this.$slots.default === "function") {
        return this.$slots.default(null);
      }
      if (typeof this.$slots.panel === "function") {
        return this.$slots.panel(null);
      }
      return null;
    };
    return withDirectives(createVNode("div", {
      "ref": "content",
      "class": resolveClassName("tab-panel")
    }, [getContent()]), [[vShow, active]]);
  }
});
const BkTab = withInstallProps(Tab, { TabPanel });
const instances = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
};
let seed = 1;
const Message$1 = (constructor, options) => {
  let opts = options;
  const position = opts.position || "top-right";
  if (typeof options === "string") {
    opts = {
      message: options
    };
  }
  const userOnClose = options.onClose;
  const horizontalOffset = opts.offsetX || 10;
  let verticalOffset = opts.offsetY || 30;
  const { spacing = 10 } = opts;
  instances[position].forEach((vm2) => {
    verticalOffset += (vm2.el.offsetHeight || 0) + spacing;
  });
  seed += 1;
  const id = `message_${seed}`;
  opts = __spreadProps(__spreadValues({}, opts), {
    offsetX: horizontalOffset,
    offsetY: verticalOffset,
    id
  });
  const container2 = document.createElement("div");
  const vm = createVNode(constructor, opts);
  vm.props.onDestroy = (id2) => {
    close(id2, position, spacing, userOnClose);
    render$1(null, container2);
  };
  render$1(vm, container2);
  instances[position].push(vm);
  let target;
  if (vm.props.getContainer && isElement$4(vm.props.getContainer)) {
    target = vm.props.getContainer;
  } else {
    target = document.body;
  }
  target.appendChild(container2.firstElementChild);
};
function close(id, position, spacing, userOnClose) {
  userOnClose == null ? void 0 : userOnClose();
  const verticalProperty = position.startsWith("top") ? "top" : "bottom";
  let instanceIndex = -1;
  instances[position].forEach((item, index2) => {
    if (item.props.id === id) {
      instanceIndex = index2;
    }
  });
  const vm = instances[position][instanceIndex];
  const removeHeight = vm.el.offsetHeight;
  const len = instances[position].length;
  for (let i2 = instanceIndex; i2 < len; i2++) {
    const pos = parseInt(instances[position][i2].el.style[verticalProperty], 10) - removeHeight - spacing;
    instances[position][i2].component.props.offsetY = pos;
  }
  instances[position].splice(instanceIndex, 1);
}
var MessageThemeEnum;
(function(MessageThemeEnum2) {
  MessageThemeEnum2["PRIMARY"] = "primary";
  MessageThemeEnum2["WARNING"] = "warning";
  MessageThemeEnum2["SUCCESS"] = "success";
  MessageThemeEnum2["ERROR"] = "error";
})(MessageThemeEnum || (MessageThemeEnum = {}));
const messageProps = {
  id: PropTypes.string.def(""),
  message: PropTypes.string.def(""),
  theme: j("messageTheme", {}).def(MessageThemeEnum.PRIMARY),
  delay: PropTypes.number.def(3e3),
  dismissable: PropTypes.bool.def(true),
  offsetY: PropTypes.number.def(30),
  spacing: PropTypes.number.def(10),
  extCls: PropTypes.string.def(""),
  onClose: PropTypes.func,
  getContainer: PropTypes.instanceOf(HTMLElement)
};
var MessageConstructor = defineComponent({
  name: "Message",
  props: messageProps,
  emits: ["destroy"],
  setup(props2, {
    emit
  }) {
    const classNames = computed(() => ["lesscode-bk-message", `lesscode-bk-message-${props2.theme}`, `${props2.extCls}`]);
    const zIndex = bkZIndexManager.getMessageNextIndex();
    const isGetContainer = computed(() => props2.getContainer && isElement$4(props2.getContainer));
    const styles = computed(() => ({
      top: `${props2.offsetY}px`,
      zIndex,
      position: isGetContainer.value ? "absolute" : "fixed"
    }));
    const visible = ref(false);
    let timer = null;
    const startTimer = () => {
      timer = setTimeout(() => {
        visible.value = false;
      }, props2.delay);
    };
    const close2 = (e) => {
      e.preventDefault();
      e.stopPropagation();
      visible.value = false;
    };
    onMounted(() => {
      props2.delay && startTimer();
      visible.value = true;
    });
    onUnmounted(() => {
      clearTimeout(timer);
    });
    watch(visible, () => {
      if (!visible.value) {
        emit("destroy", props2.id);
      }
    });
    return {
      classNames,
      styles,
      visible,
      close: close2
    };
  },
  render() {
    const renderIcon = () => {
      const iconMap = {
        primary: createVNode(info, null, null),
        warning: createVNode(warn, null, null),
        success: createVNode(success, null, null),
        error: createVNode(close$1, null, null)
      };
      return iconMap[this.theme];
    };
    return createVNode(Transition, {
      "name": "lesscode-bk-message-fade"
    }, {
      default: () => [withDirectives(createVNode("div", {
        "class": this.classNames,
        "style": this.styles
      }, [createVNode("div", {
        "class": "lesscode-bk-message-content"
      }, [createVNode("div", {
        "class": "lesscode-bk-message-icon"
      }, [renderIcon()]), this.message]), this.dismissable && createVNode(error, {
        "class": "lesscode-bk-message-close",
        "onClick": this.close
      }, null)]), [[vShow, this.visible]])]
    });
  }
});
const Message = (options) => {
  Message$1(MessageConstructor, options);
};
const InfoBox = (config) => {
  const container2 = document.createElement("div");
  const isShow = ref(false);
  const modalFuncProps = shallowRef(config);
  const dialog2 = defineComponent({
    name: "DialogConfirm",
    setup(_props, {
      expose
    }) {
      onMounted(() => {
        const dom = document.activeElement || document.body;
        dom.blur();
        if (modalFuncProps.value.isShow !== false) {
          isShow.value = true;
        }
      });
      const onClosed = async () => {
        var _a, _b;
        if (typeof ((_a = modalFuncProps.value) == null ? void 0 : _a.onClosed) === "function") {
          await ((_b = modalFuncProps.value) == null ? void 0 : _b.onClosed());
        }
        isShow.value = false;
      };
      const onConfirm = async () => {
        var _a, _b;
        if (typeof ((_a = modalFuncProps.value) == null ? void 0 : _a.onConfirm) === "function") {
          await ((_b = modalFuncProps.value) == null ? void 0 : _b.onConfirm());
        }
        isShow.value = false;
      };
      function update(newValue) {
        modalFuncProps.value = newValue;
      }
      expose({
        update
      });
      const getContent = () => {
        const children = [];
        const subTitleBox = [];
        if (modalFuncProps.value.subTitle) {
          switch (typeof modalFuncProps.value.subTitle) {
            case "string":
              children.push(modalFuncProps.value.subTitle);
              break;
            case "function":
              children.push(modalFuncProps.value.subTitle());
              break;
            default:
              children.push(modalFuncProps.value.subTitle);
              break;
          }
        }
        if (children.length) {
          subTitleBox.push(h$1("div", {
            class: resolveClassName("info-sub-title"),
            style: `text-Align:${modalFuncProps.value.contentAlign || "center"}`
          }, children));
        }
        return subTitleBox;
      };
      return () => createVNode(Dialog, __spreadProps(__spreadValues({
        class: resolveClassName("info-wrapper"),
        headerAlign: "center",
        footerAlign: "center"
      }, modalFuncProps.value), {
        isShow: isShow.value,
        onClosed,
        onConfirm
      }), getContent());
    }
  });
  let app = createApp(dialog2).mount(container2);
  return {
    show: () => {
      isShow.value = true;
    },
    hide: () => {
      isShow.value = false;
    },
    update: (config2) => {
      app.update(config2);
    },
    destroy: () => {
      app.unmount();
      app = null;
    }
  };
};
const BkInfoBox = withInstall(InfoBox);
var NotifyThemeEnum;
(function(NotifyThemeEnum2) {
  NotifyThemeEnum2["PRIMARY"] = "primary";
  NotifyThemeEnum2["WARNING"] = "warning";
  NotifyThemeEnum2["SUCCESS"] = "success";
  NotifyThemeEnum2["ERROR"] = "error";
})(NotifyThemeEnum || (NotifyThemeEnum = {}));
const notifyProps = {
  id: PropTypes.string.def(""),
  title: PropTypes.string.def(""),
  message: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).def(""),
  theme: j("notifyTheme", {}).def(NotifyThemeEnum.PRIMARY),
  position: PropTypes.position().def("top-right"),
  delay: PropTypes.number.def(5e3),
  dismissable: PropTypes.bool.def(true),
  offsetX: PropTypes.number.def(100),
  offsetY: PropTypes.number.def(30),
  spacing: PropTypes.number.def(10),
  extCls: PropTypes.string.def(""),
  onClose: PropTypes.func
};
var NotifyConstructor = defineComponent({
  name: "Notify",
  props: notifyProps,
  emits: ["destroy"],
  setup(props2, {
    emit
  }) {
    const zIndex = bkZIndexManager.getMessageNextIndex();
    const horizontalClass = computed(() => props2.position.indexOf("right") > 1 ? "right" : "left");
    const verticalProperty = computed(() => props2.position.startsWith("top") ? "top" : "bottom");
    const styles = computed(() => ({
      [horizontalClass.value]: `${props2.offsetX}px`,
      [verticalProperty.value]: `${props2.offsetY}px`,
      zIndex
    }));
    const classNames = computed(() => ["lesscode-bk-notify", `lesscode-bk-notify-${props2.theme}`, horizontalClass.value]);
    const renderMessage = computed(() => {
      if (typeof props2.message === "function") {
        return props2.message();
      }
      return props2.message;
    });
    const visible = ref(false);
    let timer = null;
    const startTimer = () => {
      timer = setTimeout(() => {
        visible.value = false;
      }, props2.delay);
    };
    const handleClose = () => {
      visible.value = false;
    };
    onMounted(() => {
      props2.delay && startTimer();
      visible.value = true;
    });
    onUnmounted(() => {
      clearTimeout(timer);
    });
    watch(visible, () => {
      if (!visible.value) {
        emit("destroy", props2.id);
      }
    });
    return {
      classNames,
      styles,
      visible,
      renderMessage,
      handleClose
    };
  },
  render() {
    const renderIcon = () => {
      const iconMap = {
        primary: createVNode(info, null, null),
        warning: createVNode(warn, null, null),
        success: createVNode(success, null, null),
        error: createVNode(close$1, null, null)
      };
      return iconMap[this.theme];
    };
    return createVNode(Transition, {
      "name": "lesscode-bk-notify-fade"
    }, {
      default: () => [withDirectives(createVNode("div", {
        "class": this.classNames,
        "style": this.styles
      }, [createVNode("div", {
        "class": "lesscode-bk-notify-content"
      }, [createVNode("div", {
        "class": "lesscode-bk-notify-icon"
      }, [renderIcon()]), this.title ? createVNode("div", {
        "class": "lesscode-bk-notify-content-header"
      }, [this.title]) : "", createVNode("div", {
        "class": "lesscode-bk-notify-content-text"
      }, [this.renderMessage])]), this.dismissable && createVNode(error, {
        "class": "lesscode-bk-notify-icon lesscode-bk-notify-close",
        "onClick": this.handleClose
      }, null)]), [[vShow, this.visible]])]
    });
  }
});
const Notify = (options) => {
  Message$1(NotifyConstructor, options);
};
const MENU_PROVIDER_KEY = Symbol("MENU_PROVIDER_KEY");
const MENU_PROVIDER_KEY_PATH = Symbol("MENU_PROVIDER_KEY_PATH");
const useMenuProvider = (data2) => {
  provide(MENU_PROVIDER_KEY, data2);
};
const useMenuPathProvider = (key2) => {
  const { parentKeys, parentInfo } = useMenuPathInject();
  const keys = computed(() => [...parentKeys.value, key2]);
  provide(MENU_PROVIDER_KEY_PATH, { parentInfo: { key: key2, parentKey: parentInfo == null ? void 0 : parentInfo.key }, parentKeys: keys });
};
const useMenuInject = () => inject(MENU_PROVIDER_KEY);
const useMenuPathInject = () => {
  var _a;
  const instance = getCurrentInstance();
  const provides = !instance.parent ? (_a = instance.vnode.appContext) == null ? void 0 : _a.provides : instance.parent.provides;
  if (provides && MENU_PROVIDER_KEY_PATH in provides) {
    return inject(MENU_PROVIDER_KEY_PATH);
  }
  return { parentInfo: void 0, parentKeys: ref([]) };
};
const trimArr = function(s2) {
  return (s2 || "").split(" ").filter((item) => !!item.trim());
};
function removeClass(el, cls) {
  if (!el || !cls)
    return;
  const classes2 = trimArr(cls);
  let curClass = el.getAttribute("class") || "";
  if (el.classList) {
    el.classList.remove(...classes2);
    return;
  }
  classes2.forEach((item) => {
    curClass = curClass.replace(` ${item} `, " ");
  });
  const className = trimArr(curClass).join(" ");
  el.setAttribute("class", className);
}
function addClass(el, cls) {
  if (!el)
    return;
  let className = el.getAttribute("class") || "";
  const curClass = trimArr(className);
  const classes2 = (cls || "").split(" ").filter((item) => !curClass.includes(item) && !!item.trim());
  if (el.classList) {
    el.classList.add(...classes2);
  } else {
    className += ` ${classes2.join(" ")}`;
    el.setAttribute("class", className);
  }
}
const collapseMotion = () => ({
  css: true,
  onBeforeEnter: (el) => {
    addClass(el, "collapse-transition");
    if (!el.dataset)
      el.dataset = {};
    el.style.height = "0px";
    el.style.maxHeight = "0px";
  },
  onEnter: (el) => {
    el.dataset.oldOverflow = el.style.overflow;
    if (el.scrollHeight !== 0) {
      el.style.height = `${el.scrollHeight}px`;
      el.style.maxHeight = `${el.scrollHeight}px`;
    } else {
      el.style.height = "0px";
      el.style.maxHeight = "0px";
    }
    el.style.overflow = "hidden";
  },
  onAfterEnter: (el) => {
    el.style.height = "";
    el.style.maxHeight = "";
    el.style.overflow = el.dataset.oldOverflow;
    removeClass(el, "collapse-transition");
  },
  onBeforeLeave: (el) => {
    if (!el.dataset)
      el.dataset = {};
    el.dataset.oldOverflow = el.style.overflow;
    el.style.height = `${el.scrollHeight}px`;
    el.style.maxHeight = `${el.scrollHeight}px`;
    el.style.overflow = "hidden";
  },
  onLeave: (el) => {
    if (el.scrollHeight !== 0) {
      addClass(el, "collapse-transition");
      el.style.transitionProperty = "height";
      el.style.height = "0px";
      el.style.maxHeight = "0px";
    }
  },
  onAfterLeave: (el) => {
    removeClass(el, "collapse-transition");
    el.style.height = "";
    el.style.maxHeight = "";
    el.style.overflow = el.dataset.oldOverflow;
  }
});
const menuProps = {
  activeKey: String,
  collapse: Boolean,
  openedKeys: {
    type: Array
  },
  mode: {
    type: String,
    default: "vertical"
  },
  uniqueOpen: {
    type: Boolean,
    default: true
  }
};
var Component$d = defineComponent({
  name: "Menu",
  props: menuProps,
  emits: ["update:activeKey", "update:openKeys", "click", "openChange"],
  setup(props2, {
    slots,
    emit,
    expose
  }) {
    const activeKey = ref("");
    const openedKeys = ref([]);
    const menuStore = ref({});
    const mode = computed(() => props2.mode);
    const collapse2 = ref(props2.collapse);
    const oldOpenKeys = ref([]);
    watchEffect(() => {
      if (props2.activeKey !== void 0) {
        activeKey.value = props2.activeKey;
      }
    });
    watch(() => props2.collapse, () => {
      collapse2.value = props2.collapse;
      const oldKeys = [...oldOpenKeys.value];
      const openKeys = [...openedKeys.value];
      openedKeys.value = collapse2.value ? [] : oldKeys;
      oldOpenKeys.value = collapse2.value ? openKeys : [];
    }, {
      immediate: true
    });
    watch(() => props2.openedKeys, (keys = openedKeys.value) => {
      openedKeys.value = keys;
    }, {
      immediate: true
    });
    const registerMenuInfo = (key2, info2) => {
      menuStore.value = __spreadProps(__spreadValues({}, menuStore.value), {
        [key2]: info2
      });
    };
    const unregisterMenuInfo = (key2) => {
      delete menuStore.value[key2];
      menuStore.value = __spreadValues({}, menuStore.value);
    };
    const handleOpenChange = (key2, opened) => {
      if (opened) {
        if (props2.uniqueOpen) {
          openedKeys.value = [key2];
        } else
          openedKeys.value.push(key2);
      } else {
        openedKeys.value = openedKeys.value.filter((v2) => v2 !== key2);
      }
      emit("openChange", opened, menuStore.value[key2]);
      emit("update:openKeys", [...openedKeys.value]);
    };
    const handleActiveChange = (key2) => {
      activeKey.value = key2;
      emit("click", menuStore.value[key2]);
      emit("update:activeKey", key2, menuStore.value[key2]);
    };
    useMenuProvider({
      activeKey,
      menuStore,
      registerMenuInfo,
      unregisterMenuInfo,
      mode: mode.value,
      openedKeys,
      collapse: collapse2,
      handleOpenChange,
      handleActiveChange
    });
    expose({
      activeKey,
      openedKeys,
      menuStore
    });
    return () => {
      var _a;
      return createVNode("div", {
        "class": {
          "lesscode-bk-menu": true,
          "is-collapse": collapse2.value
        }
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});
var Group = defineComponent({
  name: "MenuGroup",
  props: {
    name: {
      type: String,
      default: ""
    }
  },
  setup(props2, {
    slots
  }) {
    return () => {
      var _a;
      return createVNode("div", {
        "class": "lesscode-bk-menu-group"
      }, [createVNode("div", {
        "class": "group-name"
      }, [props2.name]), createVNode("ul", {
        "class": "group-wrap"
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)])]);
    };
  }
});
var Item = defineComponent({
  name: "MenuItem",
  props: {
    needIcon: {
      type: Boolean,
      default: true
    }
  },
  emits: ["click"],
  slots: ["icon"],
  setup(props2, {
    slots,
    emit
  }) {
    var _a, _b;
    const {
      registerMenuInfo,
      unregisterMenuInfo,
      activeKey,
      handleActiveChange
    } = useMenuInject();
    const instance = getCurrentInstance();
    const {
      parentInfo
    } = useMenuPathInject();
    const key2 = ((_b = (_a = instance.vnode.key) == null ? void 0 : _a.toString) == null ? void 0 : _b.call(_a)) || String(instance.uid);
    const isActive = computed(() => activeKey.value === key2);
    const needIcon = computed(() => props2.needIcon);
    registerMenuInfo(key2, {
      key: key2,
      parentKey: parentInfo == null ? void 0 : parentInfo.key
    });
    const handleClick = (e) => {
      handleActiveChange(key2);
      emit("click", e);
    };
    onBeforeUnmount(() => unregisterMenuInfo(key2));
    return () => {
      var _a2, _b2;
      return createVNode("li", {
        "class": {
          "lesscode-bk-menu-item": true,
          "is-active": isActive.value
        },
        "onClick": handleClick
      }, [needIcon.value && createVNode("span", {
        "class": "item-icon"
      }, [((_a2 = slots == null ? void 0 : slots.icon) == null ? void 0 : _a2.call(slots)) || createVNode("i", {
        "class": "default-icon"
      }, null)]), createVNode("span", {
        "class": "item-content"
      }, [(_b2 = slots.default) == null ? void 0 : _b2.call(slots)])]);
    };
  }
});
const subMenuProps = {
  title: {
    type: String,
    default: "title"
  }
};
var Submenu = defineComponent({
  name: "Submenu",
  props: subMenuProps,
  emits: ["collapse"],
  slots: ["icon"],
  setup(props2, {
    slots,
    emit
  }) {
    var _a, _b;
    const {
      registerMenuInfo,
      unregisterMenuInfo,
      openedKeys,
      handleOpenChange,
      collapse: collapse2,
      activeKey,
      menuStore
    } = useMenuInject();
    const {
      parentInfo
    } = useMenuPathInject();
    const instance = getCurrentInstance();
    const key2 = ((_b = (_a = instance.vnode.key) == null ? void 0 : _a.toString) == null ? void 0 : _b.call(_a)) || String(instance.uid);
    const transition = ref(collapseMotion());
    const isShow = computed(() => openedKeys.value.includes(key2));
    const specialCollapse = computed(() => {
      var _a2, _b2;
      const activeParentKey = (_b2 = (_a2 = menuStore.value) == null ? void 0 : _a2[activeKey.value]) == null ? void 0 : _b2.parentKey;
      return collapse2.value && activeParentKey === key2 && isShow;
    });
    useMenuPathProvider(key2);
    registerMenuInfo(key2, {
      key: key2,
      parentKey: parentInfo == null ? void 0 : parentInfo.key
    });
    onBeforeUnmount(() => unregisterMenuInfo(key2));
    const handleCollapse = () => {
      handleOpenChange(key2, !isShow.value);
      emit("collapse", !isShow.value, instance);
    };
    return () => {
      var _a2;
      return createVNode("li", {
        "class": {
          "lesscode-bk-menu-submenu": true,
          "is-opened": isShow.value
        }
      }, [createVNode("div", {
        "class": {
          "submenu-header": true,
          "is-collapse": specialCollapse.value
        },
        "onClick": handleCollapse
      }, [createVNode("span", {
        "class": "submenu-header-icon"
      }, [((_a2 = slots.icon) == null ? void 0 : _a2.call(slots)) || createVNode(treeApplicationShape, {
        "class": "menu-icon"
      }, null)]), createVNode("span", {
        "class": "submenu-header-content"
      }, [props2.title]), createVNode(angleDown, {
        "class": {
          "submenu-header-collapse": true,
          "is-collapse": openedKeys.value.includes(key2)
        }
      }, null)]), createVNode(Transition, transition.value, {
        default: () => {
          var _a3;
          return [withDirectives(createVNode("ul", {
            "class": "submenu-list"
          }, [(_a3 = slots.default) == null ? void 0 : _a3.call(slots)]), [[vShow, isShow.value]])];
        }
      })]);
    };
  }
});
const BkMenu = withInstallProps(Component$d, { Item, Submenu, Group });
const TitleProps = {
  sideTitle: {
    type: String,
    default: ""
  },
  navigationType: {
    type: String,
    default: "left-right"
  }
};
var NavigationTitle = defineComponent({
  props: TitleProps,
  slots: ["side-icon"],
  setup(props2, {
    slots
  }) {
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": "lesscode-bk-navigation-title",
        "style": {
          borderBottomWidth: props2.navigationType === "left-right" ? "0" : "1px"
        }
      }, [((_a = slots.default) == null ? void 0 : _a.call(slots)) || [createVNode("span", {
        "class": "title-icon"
      }, [((_b = slots["side-icon"]) == null ? void 0 : _b.call(slots)) || createVNode("i", {
        "class": "lesscode-bk-icon icon-rtx"
      }, null)]), createVNode("span", {
        "class": "title-desc"
      }, [props2.sideTitle])]]);
    };
  }
});
const NavigationProps = {
  navWidth: {
    type: [Number, String],
    default: 60
  },
  hoverWidth: {
    type: [Number, String],
    default: 260
  },
  showSideNavTitle: {
    type: Boolean,
    default: true
  },
  sideTitle: {
    type: String,
    default: ""
  },
  headerTitle: {
    type: String,
    default: ""
  },
  hoverLeaveDelay: {
    type: Number,
    default: 0
  },
  hoverEnterDelay: {
    type: Number,
    default: 100
  },
  defaultOpen: Boolean,
  headHeight: {
    type: [Number, String],
    default: 52
  },
  navigationType: {
    type: String,
    default: "left-right",
    validator(v2) {
      return ["top-bottom", "left-right"].includes(v2);
    }
  },
  needMenu: {
    type: Boolean,
    default: true
  }
};
var Component$c = defineComponent({
  name: "Navigation",
  props: NavigationProps,
  emits: ["leave", "toggle", "hover", "toggle-click"],
  slots: ["header", "menu", "footer", "side-icon", "side-header"],
  setup(props2, {
    emit
  }) {
    const defaultHeaderTitle = ref(props2.headerTitle);
    const nav = reactive({
      click: false,
      hover: false,
      delay: false,
      timer: null,
      enterTimer: null
    });
    if (props2.defaultOpen) {
      nav.click = !nav.click;
      nav.hover = nav.click;
      emit("toggle", nav.hover);
    }
    onBeforeUnmount(() => {
      nav.timer && window.clearTimeout(nav.timer);
    });
    const handleMouseOver = () => {
      if (!nav.click) {
        nav.enterTimer = setTimeout(() => {
          nav.hover = true;
          nav.enterTimer && window.clearTimeout(nav.enterTimer);
          nav.timer && window.clearTimeout(nav.timer);
          emit("hover", nav.hover);
          emit("toggle", nav.hover);
        }, props2.hoverEnterDelay);
      }
    };
    const handleMouseLeave = () => {
      if (!nav.click) {
        nav.enterTimer && window.clearTimeout(nav.enterTimer);
        nav.timer = setTimeout(() => {
          nav.hover = false;
          window.clearTimeout(nav.timer);
          emit("leave", nav.hover);
          emit("toggle", nav.hover);
        }, props2.hoverLeaveDelay);
      }
    };
    const handleClick = () => {
      nav.click = !nav.click;
      nav.hover = nav.click;
      emit("toggle", nav.hover);
      emit("toggle-click", nav.hover);
    };
    return {
      defaultHeaderTitle,
      nav,
      onBeforeUnmount,
      handleMouseOver,
      handleMouseLeave,
      handleClick
    };
  },
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    return createVNode("div", {
      "class": "lesscode-bk-navigation"
    }, [this.navigationType === "top-bottom" && createVNode("div", {
      "class": "lesscode-bk-navigation-header",
      "style": {
        flexBasis: `${this.headHeight}px`
      }
    }, [createVNode(NavigationTitle, {
      "sideTitle": this.sideTitle
    }, {
      default: this.$slots["side-header"],
      "side-icon": !this.$slots["side-header"] ? this.$slots["side-icon"] : void 0
    }), createVNode("div", {
      "class": "header-right"
    }, [(_b = (_a = this.$slots).header) == null ? void 0 : _b.call(_a)])]), createVNode("div", {
      "class": "lesscode-bk-navigation-wrapper"
    }, [this.needMenu && createVNode("div", {
      "class": "navigation-nav",
      "style": {
        width: !this.nav.click ? `${this.navWidth}px` : `${this.hoverWidth}px`
      }
    }, [createVNode("div", {
      "class": "nav-slider",
      "onMouseenter": this.handleMouseOver,
      "onMouseleave": this.handleMouseLeave,
      "style": {
        width: !this.nav.hover ? `${this.navWidth}px` : `${this.hoverWidth}px`,
        borderRight: this.navigationType !== "top-bottom" ? "none" : "1px solid #DCDEE5"
      }
    }, [this.navigationType !== "top-bottom" && this.showSideNavTitle && createVNode(NavigationTitle, {
      "style": {
        flexBasis: `${this.headHeight}px`
      },
      "sideTitle": this.sideTitle
    }, {
      default: this.$slots["side-header"],
      "side-icon": !this.$slots["side-header"] ? this.$slots["side-icon"] : void 0
    }), createVNode("div", {
      "class": "nav-slider-list",
      "style": {
        height: `calc(100vh - ${+this.headHeight + 56}px)`
      }
    }, [(_d = (_c = this.$slots).menu) == null ? void 0 : _d.call(_c)]), createVNode("div", {
      "class": "nav-slider-footer"
    }, [createVNode("div", {
      "class": {
        "is-left": this.navigationType !== "top-bottom",
        "footer-icon": true
      },
      "onClick": this.handleClick
    }, [createVNode(collapseLeft, {
      "class": "footer-icon-svg",
      "style": {
        transform: this.nav.click ? "rotate(180deg)" : "rotate(0deg)"
      }
    }, null)])])])]), createVNode("div", {
      "class": "navigation-container",
      "style": {
        maxWidth: this.needMenu ? "calc(100vw - 60px)" : "100vw"
      }
    }, [this.navigationType !== "top-bottom" && createVNode("div", {
      "class": "container-header",
      "style": {
        flexBasis: `${this.headHeight}px`
      }
    }, [((_f = (_e = this.$slots).header) == null ? void 0 : _f.call(_e)) || [createVNode("div", {
      "class": "container-header-title"
    }, [this.headerTitle]), createVNode("div", {
      "class": "container-header-sets"
    }, [(_h = (_g = this.$slots)["header-set"]) == null ? void 0 : _h.call(_g)])]]), createVNode("div", {
      "class": "container-content",
      "style": {
        maxHeight: `calc(100vh - ${this.headHeight}px)`
      }
    }, [(_j = (_i = this.$slots).default) == null ? void 0 : _j.call(_i), createVNode("div", {
      "class": "container-footer"
    }, [(_l = (_k = this.$slots).footer) == null ? void 0 : _l.call(_k)])])])])]);
  }
});
const Navigation = withInstall(Component$c);
const pickerDropdownProps = {
  placement: {
    type: String,
    default: "bottom-start",
    validator: (value) => {
      const validList = ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"];
      if (validList.indexOf(value) < 0) {
        console.error(`placement property is not valid: '${value}'`);
        return false;
      }
      return true;
    }
  },
  className: {
    type: String
  },
  extPopoverCls: {
    type: String
  },
  appendToBody: {
    type: Boolean
  },
  triggerRef: {
    type: Object
  },
  onClick: Function
};
var PickerDropdown = defineComponent({
  props: pickerDropdownProps,
  emits: ["changeVisible"],
  setup(props2, {
    emit
  }) {
    let popoverInstance = /* @__PURE__ */ Object.create(null);
    const refContentRef = ref(null);
    onMounted(() => {
      updateDropdown();
    });
    onBeforeUnmount(() => {
      destoryDropdown();
    });
    const forceUpdate = () => {
      var _a;
      if (popoverInstance) {
        (_a = popoverInstance == null ? void 0 : popoverInstance.forceUpdate) == null ? void 0 : _a.call(popoverInstance);
      }
    };
    const destoryDropdown = () => {
      if (popoverInstance && Object.keys(popoverInstance).length !== 0) {
        const instance = popoverInstance;
        instance.isShow && instance.hide();
        instance.destroy();
        popoverInstance = null;
        emit("changeVisible", false);
      }
    };
    const updateDropdown = () => {
      if (popoverInstance && Object.keys(popoverInstance).length !== 0) {
        nextTick(() => {
          popoverInstance.update();
        });
      } else {
        nextTick(() => {
          popoverInstance = new BKPopover(props2.triggerRef, refContentRef.value, {
            placement: props2.placement,
            trigger: "manual",
            modifiers: [
              {
                name: "computeStyles",
                options: {
                  adaptive: false,
                  gpuAcceleration: false
                }
              },
              {
                name: "offset",
                options: {
                  offset: [0, 4]
                }
              }
            ]
          });
        });
      }
    };
    const styles = computed(() => {
      const style2 = {};
      if (props2.appendToBody) {
        style2["z-index"] = 1060 + bkZIndexManager.getModalNextIndex();
      }
      return style2;
    });
    const state = reactive({
      styles
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      refContentRef,
      forceUpdate,
      updateDropdown,
      destoryDropdown
    });
  },
  render() {
    var _a, _b, _c;
    return createVNode("div", {
      "ref": "refContentRef",
      "class": [resolveClassName("date-picker-dropdown"), this.className, this.extPopoverCls],
      "style": this.styles,
      "onClick": this.onClick
    }, [(_c = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)) != null ? _c : ""]);
  }
});
const confirmProps = {
  showTime: {
    type: Boolean,
    required: true
  },
  isTime: {
    type: Boolean,
    default: false
  },
  timeDisabled: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: true
  }
};
var Confirm = defineComponent({
  props: confirmProps,
  emits: ["pick-clear", "pick-success", "pick-toggle-time"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("datePicker");
    const labels2 = computed(() => ({
      time: props2.isTime ? t2.value.selectDate : t2.value.selectTime,
      clear: t2.value.clear,
      ok: t2.value.ok
    }));
    const handleClear = () => {
      emit("pick-clear");
    };
    const handleSuccess = () => {
      emit("pick-success");
    };
    const handleToggleTime = () => {
      if (props2.timeDisabled) {
        return;
      }
      emit("pick-toggle-time");
    };
    const elRef = ref(null);
    const handleTab = (e) => {
      const tabbables = [...elRef.value.children];
      const expectedFocus = tabbables[e.shiftKey ? "shift" : "pop"]();
      if (document.activeElement === expectedFocus) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    return {
      labels: labels2,
      handleClear,
      handleSuccess,
      handleToggleTime,
      handleTab
    };
  },
  render() {
    var _a, _b, _c;
    return createVNode("div", {
      "class": resolveClassName("picker-confirm"),
      "ref": "elRef",
      "onKeydown": this.handleTab
    }, [this.showTime ? createVNode(BkButton, {
      "text": true,
      "class": resolveClassName("picker-confirm-time"),
      "disabled": this.timeDisabled,
      "onClick": this.handleToggleTime
    }, {
      default: () => [this.labels.time]
    }) : "", (_c = (_b = (_a = this.$slots).confirm) == null ? void 0 : _b.call(_a)) != null ? _c : createVNode("div", {
      "class": resolveClassName("picker-confirm-action")
    }, [this.clearable ? createVNode("a", {
      "href": "javascript: void(0);",
      "onClick": this.handleClear,
      "onKeydown": this.handleClear
    }, [this.labels.clear]) : "", createVNode("a", {
      "href": "javascript: void(0);",
      "class": "confirm",
      "onClick": this.handleSuccess,
      "onKeydown_enter": this.handleSuccess
    }, [this.labels.ok])])]);
  }
});
var oneDay = 1e3 * 60 * 60 * 24;
function daysInMonth(year, month) {
  return new Date(year, month + 1, 0).getDate();
}
function getYear(year, month, weekNr) {
  if (month === 0 && weekNr > 50)
    return year - 1;
  else if (month === 11 && weekNr < 10)
    return year + 1;
  else
    return year;
}
function getDateInfo(y2, m2, d2, iso) {
  if (m2 > 11) {
    m2 = 0;
    y2++;
  }
  var currentDay = new Date(y2, m2, d2);
  if (iso)
    currentDay.setDate(currentDay.getDate() + 4 - (currentDay.getDay() || 7));
  var year = iso ? currentDay.getFullYear() : y2;
  var firstOfJanuary = new Date(year, 0, 1);
  var numberOfDays = 1 + Math.round((currentDay - firstOfJanuary) / oneDay);
  if (!iso)
    numberOfDays += firstOfJanuary.getDay();
  var w2 = Math.ceil(numberOfDays / 7);
  if (!iso) {
    var initialDay = new Date(y2, m2, d2);
    var beginOfNextYear = new Date(y2 + 1, 0, 1);
    var startDayOfNextYear = beginOfNextYear.getDay();
    if (initialDay.getTime() >= beginOfNextYear.getTime() - oneDay * startDayOfNextYear)
      w2 = 1;
  }
  return w2;
}
function getMonthCalender(year, month, iteratorFns) {
  var lang = this.lang || "en";
  var onlyDays = this.onlyDays;
  var weekStart = typeof this.weekStart === "undefined" ? 1 : this.weekStart;
  var iso = weekStart === 1;
  var cells = [];
  var monthStartDate = new Date(year, month, 1);
  var dayOfWeek = monthStartDate.getDay() || (iso ? 7 : 0);
  var currentDay = weekStart - dayOfWeek;
  var weekNr = getDateInfo(year, month, 1, iso);
  var maxDays = daysInMonth(year, month);
  var lastMonthMaxDays = daysInMonth(year, month - 1);
  var currentMonth, day, dayBefore;
  var currentYear = getYear(year, month, weekNr);
  var returnObject = {
    month,
    year,
    daysInMonth: maxDays
  };
  for (var i2 = 0; i2 < 7; i2++) {
    dayBefore = currentDay;
    for (var j2 = 0; j2 < 8; j2++) {
      if (i2 > 0 && j2 > 0)
        currentDay++;
      if (currentDay > maxDays || currentDay < 1) {
        day = currentDay > maxDays ? currentDay - maxDays : lastMonthMaxDays + currentDay;
        currentMonth = currentDay > maxDays ? month + 1 : month - 1;
      } else {
        day = currentDay;
        currentMonth = month;
      }
      var type = function() {
        if (j2 === 0)
          return "weekLabel";
        else if (i2 === 0)
          return "dayLabel";
        else if (currentDay < 1)
          return "prevMonth";
        else if (currentDay > maxDays)
          return "nextMonth";
        else
          return "monthDay";
      }();
      var isDay = dayBefore !== currentDay && i2 > 0;
      var dayData = {
        desc: isDay ? day : weekNr,
        week: weekNr,
        type,
        format: iso ? "ISO 8601" : "US",
        date: isDay ? new Date(Date.UTC(year, currentMonth, day)) : false,
        year: currentYear,
        index: cells.length
      };
      if (iteratorFns) {
        if (typeof iteratorFns === "function")
          dayData = iteratorFns.call(returnObject, dayData, lang);
        else
          iteratorFns.forEach(function(fn2) {
            dayData = fn2.call(returnObject, dayData, lang);
          });
      }
      if (onlyDays && isDay)
        cells.push(dayData);
      else if (!onlyDays)
        cells.push(dayData);
    }
    if (i2 > 0)
      weekNr = getDateInfo(year, currentMonth, day + 1, iso);
    currentYear = getYear(year, month, weekNr);
  }
  returnObject.cells = cells;
  return returnObject;
}
var jsCalendar$1 = function(config) {
  return getMonthCalender.bind(config);
};
var labels$1 = {
  weekPlaceholder: "",
  columnNames: {
    en: {
      0: "w",
      1: "monday",
      2: "tuesday",
      3: "wednesday",
      4: "thursday",
      5: "friday",
      6: "saturday",
      7: "sunday"
    },
    sv: {
      0: "v",
      1: "m\xE5ndag",
      2: "tisdag",
      3: "onsdag",
      4: "torsdag",
      5: "fredag",
      6: "l\xF6rdag",
      7: "s\xF6ndag"
    },
    pt: {
      0: "s",
      1: "segunda",
      2: "ter\xE7a",
      3: "quarta",
      4: "quinta",
      5: "sexta",
      6: "s\xE1bado",
      7: "domingo"
    }
  },
  monthNames: {
    en: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    sv: [
      "januari",
      "februari",
      "mars",
      "april",
      "maj",
      "juni",
      "juli",
      "augusti",
      "september",
      "oktober",
      "november",
      "december"
    ],
    pt: [
      "Janeiro",
      "Fevereiro",
      "Mar\xE7o",
      "Abril",
      "Maio",
      "Junho",
      "Julho",
      "Agosto",
      "Setembro",
      "Outubro",
      "Novembro",
      "Dezembro"
    ]
  },
  classes: {
    dayLabel: "day-of-week",
    weekLabel: "week-number",
    prevMonth: "inactive",
    nextMonth: "inactive",
    monthDay: "day-in-month"
  }
};
var labels = labels$1;
function isIterable(variable) {
  if (variable == null)
    return false;
  if (variable.constructor === Array)
    return true;
  if (variable.constructor === Object)
    return true;
  return false;
}
function merge(_new, _old) {
  for (var prop in _new) {
    if (!_old[prop])
      _old[prop] = _new[prop];
    else if (isIterable(_new[prop]))
      merge(_new[prop], _old[prop]);
  }
}
function addLabels(dayObject, lang) {
  var cssClass = [labels.classes[dayObject.type]];
  if (dayObject.class)
    dayObject.class = (typeof dayObject.class == "string" ? [dayObject.class] : dayObject.class).concat(cssClass);
  else
    dayObject.class = cssClass;
  if (dayObject.type.indexOf("Label") > 0) {
    if (dayObject.index == 0 && labels.weekPlaceholder)
      dayObject.desc = labels.weekPlaceholder;
    else if (dayObject.index < 8)
      dayObject.desc = labels.columnNames[lang][dayObject.index];
    else if (dayObject.index % 8 == 0)
      dayObject.desc = dayObject.week;
  }
  if (dayObject.date)
    dayObject.monthName = labels.monthNames[lang][dayObject.date.getMonth()];
  if (!this.monthName)
    this.monthName = labels.monthNames[lang][this.month];
  if (!this.labels)
    this.labels = {
      monthNames: labels.monthNames[lang],
      columnNames: labels.columnNames[lang],
      classes: labels.classes
    };
  return dayObject;
}
addLabels.setLabels = function(newOptions) {
  merge(newOptions, labels);
};
var addLabels_1 = addLabels;
var jsCalendar = {
  Generator: jsCalendar$1,
  addLabels: addLabels_1
};
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid$1(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function(token2, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance$1 = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function(token2, _date, _baseDate, _options) {
  return formatRelativeLocale[token2];
};
var formatRelative$1 = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize$1 = localize;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key2 = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key2) : key2;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key2 in object) {
    if (object.hasOwnProperty(key2) && predicate(object[key2])) {
      return key2;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key2 = 0; key2 < array.length; key2++) {
    if (predicate(array[key2])) {
      return key2;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match$1 = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff3 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff3);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff3 = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff3 / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff3 = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff3);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff3 = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff3 / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$2 = {
  y: function(date, token2) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  M: function(date, token2) {
    var month = date.getUTCMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function(date, token2) {
    return addLeadingZeros(date.getUTCDate(), token2.length);
  },
  a: function(date, token2) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date, token2) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token2.length);
  },
  H: function(date, token2) {
    return addLeadingZeros(date.getUTCHours(), token2.length);
  },
  m: function(date, token2) {
    return addLeadingZeros(date.getUTCMinutes(), token2.length);
  },
  s: function(date, token2) {
    return addLeadingZeros(date.getUTCSeconds(), token2.length);
  },
  S: function(date, token2) {
    var numberOfDigits = token2.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};
var formatters$3 = formatters$2;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  G: function(date, token2, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token2) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date, token2, localize2) {
    if (token2 === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$3.y(date, token2);
  },
  Y: function(date, token2, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  R: function(date, token2) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  u: function(date, token2) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token2.length);
  },
  Q: function(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "M":
      case "MM":
        return formatters$3.M(date, token2);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date, token2, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token2.length);
  },
  I: function(date, token2, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  d: function(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$3.d(date, token2);
  },
  D: function(date, token2, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  E: function(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token2) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date, token2, localize2) {
    if (token2 === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$3.h(date, token2);
  },
  H: function(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$3.H(date, token2);
  },
  K: function(date, token2, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  k: function(date, token2, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  m: function(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$3.m(date, token2);
  },
  s: function(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$3.s(date, token2);
  },
  S: function(date, token2) {
    return formatters$3.S(date, token2);
  },
  X: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  T: function(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token2.length);
  }
};
function formatTimezoneShort(offset2, dirtyDelimiter) {
  var sign = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
  if (offset2 % 60 === 0) {
    var sign = offset2 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, dirtyDelimiter);
}
function formatTimezone(offset2, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var formatters$1 = formatters;
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return protectedDayOfYearTokens.indexOf(token2) !== -1;
}
function isProtectedWeekYearToken(token2) {
  return protectedWeekYearTokens.indexOf(token2) !== -1;
}
function throwProtectedError(token2, format2, input2) {
  if (token2 === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input2, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input2, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input2, "`; see: https://git.io/fxCyr"));
  } else if (token2 === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input2, "`; see: https://git.io/fxCyr"));
  }
}
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale2 = options.locale || defaultLocale;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid$1(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input2) {
  return input2.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
const fecha = {};
const token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
const twoDigits = /\d\d?/;
const threeDigits = /\d{3}/;
const fourDigits = /\d{4}/;
const word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
const noop = function() {
};
function shorten(arr, sLen) {
  const newArr = [];
  for (let i2 = 0, len = arr.length; i2 < len; i2++) {
    newArr.push(arr[i2].substr(0, sLen));
  }
  return newArr;
}
function monthUpdate(arrName) {
  return (d2, v2, i18n) => {
    const index2 = i18n[arrName].indexOf(v2.charAt(0).toUpperCase() + v2.substr(1).toLowerCase());
    if (~index2) {
      d2.month = index2;
    }
  };
}
function pad(_val, len = 2) {
  let val = String(_val);
  while (val.length < len) {
    val = `0${val}`;
  }
  return val;
}
const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
const monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const monthNamesShort = shorten(monthNames, 3);
const dayNamesShort = shorten(dayNames, 3);
fecha.i18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn(D2) {
    return D2 + ["th", "st", "nd", "rd"][D2 % 10 > 3 ? 0 : (D2 - D2 % 10 !== 10) * D2 % 10];
  }
};
const formatFlags = {
  D(dateObj) {
    return dateObj.getDay();
  },
  DD(dateObj) {
    return pad(dateObj.getDay());
  },
  Do(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d(dateObj) {
    return dateObj.getDate();
  },
  dd(dateObj) {
    return pad(dateObj.getDate());
  },
  ddd(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M(dateObj) {
    return dateObj.getMonth() + 1;
  },
  MM(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  yy(dateObj) {
    return String(dateObj.getFullYear()).substr(2);
  },
  yyyy(dateObj) {
    return dateObj.getFullYear();
  },
  h(dateObj) {
    return dateObj.getHours() % 12 || 12;
  },
  hh(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H(dateObj) {
    return dateObj.getHours();
  },
  HH(dateObj) {
    return pad(dateObj.getHours());
  },
  m(dateObj) {
    return dateObj.getMinutes();
  },
  mm(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s(dateObj) {
    return dateObj.getSeconds();
  },
  ss(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S(dateObj) {
    return Math.round(dateObj.getMilliseconds() / 100);
  },
  SS(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ(dateObj) {
    const o2 = dateObj.getTimezoneOffset();
    return (o2 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o2) / 60) * 100 + Math.abs(o2) % 60, 4);
  }
};
const parseFlags = {
  d: [twoDigits, (d2, v2) => {
    d2.day = v2;
  }],
  M: [twoDigits, (d2, v2) => {
    d2.month = v2 - 1;
  }],
  yy: [twoDigits, (d2, v2) => {
    const da = new Date();
    const cent = +`${da.getFullYear()}`.substr(0, 2);
    d2.year = `${v2 > 68 ? cent - 1 : cent}${v2}`;
  }],
  h: [twoDigits, (d2, v2) => {
    d2.hour = v2;
  }],
  m: [twoDigits, (d2, v2) => {
    d2.minute = v2;
  }],
  s: [twoDigits, (d2, v2) => {
    d2.second = v2;
  }],
  yyyy: [fourDigits, (d2, v2) => {
    d2.year = v2;
  }],
  S: [/\d/, (d2, v2) => {
    d2.millisecond = v2 * 100;
  }],
  SS: [/\d{2}/, (d2, v2) => {
    d2.millisecond = v2 * 10;
  }],
  SSS: [threeDigits, (d2, v2) => {
    d2.millisecond = v2;
  }],
  D: [twoDigits, noop],
  ddd: [word, noop],
  MMM: [word, monthUpdate("monthNamesShort")],
  MMMM: [word, monthUpdate("monthNames")],
  a: [word, (d2, v2, i18n) => {
    const val = v2.toLowerCase();
    if (val === i18n.amPm[0]) {
      d2.isPm = false;
    } else if (val === i18n.amPm[1]) {
      d2.isPm = true;
    }
  }],
  ZZ: [/[\\+\\-]\d\d:?\d\d/, (d2, v2) => {
    const parts = `${v2}`.match(/([\\+\\-]|\d\d)/gi);
    let minutes;
    if (parts) {
      minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
      d2.timezoneOffset = parts[0] === "+" ? minutes : -minutes;
    }
  }]
};
parseFlags.DD = parseFlags.D;
parseFlags.dddd = parseFlags.ddd;
parseFlags.Do = parseFlags.dd = parseFlags.d;
parseFlags.mm = parseFlags.m;
parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
parseFlags.MM = parseFlags.M;
parseFlags.ss = parseFlags.s;
parseFlags.A = parseFlags.a;
fecha.masks = {
  default: "ddd MMM dd yyyy HH:mm:ss",
  shortDate: "M/D/yy",
  mediumDate: "MMM d, yyyy",
  longDate: "MMMM d, yyyy",
  fullDate: "dddd, MMMM d, yyyy",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
fecha.format = (dateObj, mask, i18nSettings) => {
  const i18n = i18nSettings || fecha.i18n;
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date in fecha.format");
  }
  mask = fecha.masks[mask] || mask || fecha.masks.default;
  return mask.replace(token, ($0) => $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1));
};
fecha.parse = (dateStr, format2, i18nSettings) => {
  const i18n = i18nSettings || fecha.i18n;
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha.parse");
  }
  format2 = fecha.masks[format2] || format2;
  if (dateStr.length > 1e3) {
    return false;
  }
  let isValid2 = true;
  const dateInfo = {};
  format2.replace(token, ($0) => {
    if (parseFlags[$0]) {
      const info2 = parseFlags[$0];
      const index2 = dateStr.search(info2[0]);
      if (!~index2) {
        isValid2 = false;
      } else {
        dateStr.replace(info2[0], (result) => {
          info2[1](dateInfo, result, i18n);
          dateStr = dateStr.substr(index2 + result.length);
          return result;
        });
      }
    }
    return parseFlags[$0] ? "" : $0.slice(1, $0.length - 1);
  });
  if (!isValid2) {
    return false;
  }
  const today = new Date();
  if (dateInfo.isPm === true && dateInfo.hour !== null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  let date;
  if (dateInfo.timezoneOffset !== null && dateInfo.timezoneOffset !== void 0) {
    dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
    date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
  } else {
    date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
  }
  return date;
};
const RANGE_SEPARATOR = " - ";
const dateFormat = (_date, format$1) => {
  const date = toDate(new Date(_date));
  if (!date || isNaN(date.getTime())) {
    return "";
  }
  return format(date, format$1 || "yyyy-MM-dd");
};
const rangeFormatter = (value, format2) => {
  if (Array.isArray(value) && value.length === 2) {
    const start2 = value[0];
    const end2 = value[1];
    if (start2 && end2) {
      return dateFormat(start2, format2) + RANGE_SEPARATOR + dateFormat(end2, format2);
    }
  } else if (!Array.isArray(value) && value instanceof Date) {
    return dateFormat(value, format2);
  }
  return "";
};
const rangeParser = (text, format2) => {
  const array = Array.isArray(text) ? text : text.split(RANGE_SEPARATOR);
  if (array.length === 2) {
    const range1 = array[0];
    const range2 = array[1];
    return [
      range1 instanceof Date ? range1 : fecha.parse(range1, format2 || "yyyy-MM-dd"),
      range2 instanceof Date ? range2 : fecha.parse(range2, format2 || "yyyy-MM-dd")
    ];
  }
  return [];
};
const typeValueResolver = {
  default: {
    formatter(value) {
      if (!value) {
        return "";
      }
      return `${value}`;
    },
    parser(text) {
      if (text === void 0 || text === "") {
        return null;
      }
      return text;
    }
  },
  date: {
    formatter: (value, format2) => dateFormat(value, format2),
    parser: (text, format2) => fecha.parse(text, format2 || "yyyy-MM-dd")
  },
  datetime: {
    formatter: (value, format2) => dateFormat(value, format2),
    parser: (text, format2) => fecha.parse(text, format2 || "yyyy-MM-dd")
  },
  daterange: {
    formatter: rangeFormatter,
    parser: rangeParser
  },
  datetimerange: {
    formatter: rangeFormatter,
    parser: rangeParser
  },
  timerange: {
    formatter: rangeFormatter,
    parser: rangeParser
  },
  time: {
    formatter: (value, format2) => dateFormat(value, format2),
    parser: (text, format2) => fecha.parse(text, format2 || "yyyy-MM-dd")
  },
  month: {
    formatter: (value, format2) => dateFormat(value, format2),
    parser: (text, format2) => fecha.parse(text, format2 || "yyyy-MM-dd")
  },
  year: {
    formatter: (value, format2) => dateFormat(value, format2),
    parser: (text, format2) => fecha.parse(text, format2 || "yyyy-MM-dd")
  },
  multiple: {
    formatter(value, format2) {
      return value.filter(Boolean).map((date) => dateFormat(date, format2)).join(",");
    },
    parser(v2, format2) {
      const values = typeof v2 === "string" ? v2.split(",") : v2;
      return values.map((value) => {
        if (value instanceof Date) {
          return value;
        }
        let val = value;
        if (typeof value === "string") {
          val = value.trim();
        } else if (typeof value !== "number" && !value) {
          val = "";
        }
        return fecha.parse(val, format2 || "yyyy-MM-dd");
      });
    }
  },
  number: {
    formatter(value) {
      if (!value) {
        return "";
      }
      return `${value}`;
    },
    parser(text) {
      const result = Number(text);
      if (!isNaN(text)) {
        return result;
      }
      return null;
    }
  }
};
const initTime = () => {
  const date = new Date();
  date.setHours(0);
  date.setMinutes(0);
  date.setSeconds(0);
  return date;
};
const isAllEmptyArr = (arr) => arr.every((item) => !item || typeof item === "string" && item.trim() === "");
const extractTime = (date) => {
  if (!date) {
    return [0, 0, 0];
  }
  return [
    date.getHours(),
    date.getMinutes(),
    date.getSeconds()
  ];
};
const DEFAULT_FORMATS = {
  date: "yyyy-MM-dd",
  month: "yyyy-MM",
  year: "yyyy",
  datetime: "yyyy-MM-dd HH:mm:ss",
  time: "HH:mm:ss",
  timerange: "HH:mm:ss",
  daterange: "yyyy-MM-dd",
  datetimerange: "yyyy-MM-dd HH:mm:ss"
};
const parseDate = (val, type, multiple, format2) => {
  const isRange = type.includes("range");
  const { parser } = typeValueResolver[type] || typeValueResolver.default;
  const f2 = format2 || DEFAULT_FORMATS[type];
  const multipleParser = typeValueResolver.multiple.parser;
  let value = val;
  if (val && type === "time" && !(val instanceof Date)) {
    value = parser(val, f2);
  } else if (multiple && val) {
    value = multipleParser(val, f2);
  } else if (isRange) {
    if (!val) {
      value = [null, null];
    } else {
      if (typeof val === "string") {
        value = parser(val, f2);
      } else if (type === "timerange") {
        value = parser(val, f2).map((v2) => v2 || "");
      } else {
        const [start2, end2] = val;
        if (start2 instanceof Date && end2 instanceof Date) {
          value = val.map((date) => new Date(date));
        } else if (typeof start2 === "string" && typeof end2 === "string") {
          value = parser(val.join(RANGE_SEPARATOR), f2);
        } else if (!start2 || !end2) {
          value = [null, null];
        }
      }
    }
  } else if (typeof val === "string" && type.indexOf("time") !== 0) {
    value = parser(val, f2) || null;
  }
  return isRange || multiple ? value || [] : [value];
};
const formatDate = (val, type, multiple, format2) => {
  const f2 = DEFAULT_FORMATS[type];
  if (multiple) {
    const { formatter: formatter2 } = typeValueResolver.multiple;
    return formatter2(val, format2 || f2);
  }
  const { formatter } = typeValueResolver[type] || typeValueResolver.default;
  return formatter(val, format2 || f2);
};
const datePickerKey = Symbol("date-picker");
const timePickerKey = Symbol("time-picker");
function iconBtnCls(direction, type = "") {
  return [
    resolveClassName("picker-panel-icon-btn"),
    resolveClassName(`date-picker-${direction}-btn`),
    resolveClassName(`date-picker-${direction}-btn-arrow${type}`)
  ];
}
const getDayCountOfMonth = (year, month) => new Date(year, month + 1, 0).getDate();
const siblingMonth = (src, diff3) => {
  const temp = new Date(src);
  const newMonth = temp.getMonth() + diff3;
  const newMonthDayCount = getDayCountOfMonth(temp.getFullYear(), newMonth);
  if (newMonthDayCount < temp.getDate()) {
    temp.setDate(newMonthDayCount);
  }
  temp.setMonth(newMonth);
  return temp;
};
const formatDateLabels = (() => {
  const formats = {
    yyyy: (date) => date.getFullYear(),
    m: (date) => date.getMonth() + 1,
    mm: (date) => `0${date.getMonth() + 1}`.slice(-2),
    mmm: (date, locale2) => {
      const monthName = date.toLocaleDateString(locale2, {
        month: "long"
      });
      return monthName.slice(0, 3);
    },
    Mmm: (date, locale2) => {
      const monthName = date.toLocaleDateString(locale2, {
        month: "long"
      });
      return (monthName[0].toUpperCase() + monthName.slice(1).toLowerCase()).slice(0, 3);
    },
    mmmm: (date, locale2) => date.toLocaleDateString(locale2, {
      month: "long"
    }),
    Mmmm: (date, locale2) => {
      const monthName = date.toLocaleDateString(locale2, {
        month: "long"
      });
      return monthName[0].toUpperCase() + monthName.slice(1).toLowerCase();
    }
  };
  const formatRegex = new RegExp(["yyyy", "Mmmm", "mmmm", "Mmm", "mmm", "mm", "m"].join("|"), "g");
  return (locale2, format2, date) => {
    const componetsRegex = /(\[[^\]]+\])([^\\[\]]+)(\[[^\]]+\])/;
    const components2 = format2.match(componetsRegex).slice(1);
    const separator2 = components2[1];
    const labels2 = [components2[0], components2[2]].map((component) => {
      const label = component.replace(/\[[^\]]+\]/, (str) => str.slice(1, -1).replace(formatRegex, (match2) => formats[match2](date, locale2)));
      return {
        label,
        type: component.indexOf("yy") !== -1 ? "year" : "month"
      };
    });
    return {
      separator: separator2,
      labels: labels2
    };
  };
})();
const clearHours = (time) => {
  const cloneDate = new Date(time);
  cloneDate.setHours(0, 0, 0, 0);
  return cloneDate.getTime();
};
const isInRange = (time, a2, b2) => {
  if (!a2 || !b2) {
    return false;
  }
  const [start2, end2] = [a2, b2].sort();
  return time >= start2 && time <= end2;
};
function firstUpperCase(str) {
  return str.toString()[0].toUpperCase() + str.toString().slice(1);
}
const mergeDateHMS = (date, ...hms) => {
  const newDate = new Date(date.getTime());
  newDate.setHours(hms[0]);
  newDate.setMinutes(hms[1]);
  newDate.setSeconds(hms[2]);
  return newDate;
};
const dateTableProps = {
  tableDate: {
    type: Date,
    required: true
  },
  disabledDate: Function,
  selectionMode: {
    type: String,
    required: true
  },
  modelValue: {
    type: [Date, String, Number, Array]
  },
  rangeState: {
    type: Object,
    default: () => ({
      from: null,
      to: null,
      selecting: false
    })
  },
  focusedDate: {
    type: Date,
    required: true
  }
};
var DateTable = defineComponent({
  name: "DateTable",
  props: dateTableProps,
  emits: ["pick", "pick-click", "changeRange"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("datePicker");
    const calendar = computed(() => new jsCalendar.Generator({
      onlyDays: true,
      weekStart: 0
    }));
    const headerDays = computed(() => {
      const translatedDays = [t2.value.weekdays.sun, t2.value.weekdays.mon, t2.value.weekdays.tue, t2.value.weekdays.wed, t2.value.weekdays.thu, t2.value.weekdays.fri, t2.value.weekdays.sat];
      return translatedDays.splice(0, 7 - 0).concat(translatedDays.splice(0, 0));
    });
    const dates = computed(() => {
      const rangeSelecting = props2.selectionMode === "range" && props2.rangeState.selecting;
      return rangeSelecting ? [props2.rangeState.from] : props2.modelValue;
    });
    const cells = computed(() => {
      const tableYear = props2.tableDate.getFullYear();
      const tableMonth = props2.tableDate.getMonth();
      const today = clearHours(new Date());
      const selectedDays = dates.value.filter(Boolean).map(clearHours);
      const [minDay, maxDay] = dates.value.map(clearHours);
      const rangeStart = props2.rangeState.from && clearHours(props2.rangeState.from);
      const rangeEnd = props2.rangeState.to && clearHours(props2.rangeState.to);
      const isRange = props2.selectionMode === "range";
      const disableTestFn = typeof props2.disabledDate === "function" && props2.disabledDate;
      return calendar.value(tableYear, tableMonth, (cell) => {
        if (cell.date instanceof Date) {
          cell.date.setTime(cell.date.getTime() + cell.date.getTimezoneOffset() * 6e4);
        }
        const time = cell.date && clearHours(cell.date);
        const dateIsInCurrentMonth = cell.date && tableMonth === cell.date.getMonth();
        return __spreadProps(__spreadValues({}, cell), {
          type: time === today ? "today" : cell.type,
          selected: dateIsInCurrentMonth && selectedDays.includes(time),
          disabled: cell.date && disableTestFn && disableTestFn(new Date(time)),
          range: dateIsInCurrentMonth && isRange && isInRange(time, rangeStart, rangeEnd),
          start: dateIsInCurrentMonth && isRange && time === minDay,
          end: dateIsInCurrentMonth && isRange && time === maxDay
        });
      }).cells.slice(0);
    });
    const handleClick = (cell) => {
      if (cell.disabled || cell.type === "weekLabel") {
        return;
      }
      const newDate = new Date(clearHours(cell.date));
      emit("pick", newDate);
      emit("pick-click");
    };
    const handleMouseMove = (cell) => {
      if (!props2.rangeState.selecting) {
        return;
      }
      if (cell.disabled) {
        return;
      }
      const newDate = cell.date;
      emit("changeRange", newDate);
    };
    const getCellCls = (cell) => [resolveClassName("date-picker-cells-cell"), {
      [resolveClassName("date-picker-cells-cell-selected")]: cell.selected || cell.start || cell.end,
      [resolveClassName("date-picker-cells-cell-disabled")]: cell.disabled,
      [resolveClassName("date-picker-cells-cell-today")]: cell.type === "today",
      [resolveClassName("date-picker-cells-cell-prev-month")]: cell.type === "prevMonth",
      [resolveClassName("date-picker-cells-cell-next-month")]: cell.type === "nextMonth",
      [resolveClassName("date-picker-cells-cell-week-label")]: cell.type === "weekLabel",
      [resolveClassName("date-picker-cells-cell-range")]: cell.range && !cell.start && !cell.end
    }];
    return {
      headerDays,
      cells,
      getCellCls,
      handleClick,
      handleMouseMove
    };
  },
  render() {
    return createVNode("div", {
      "class": resolveClassName("date-picker-cells")
    }, [createVNode("div", {
      "class": resolveClassName("date-picker-cells-header")
    }, [this.headerDays.map((day) => createVNode("span", null, [day]))]), this.cells.map((cell) => createVNode("span", {
      "class": this.getCellCls(cell),
      "onClick": () => this.handleClick(cell),
      "onMouseenter": () => this.handleMouseMove(cell)
    }, [createVNode("em", null, [cell.desc])]))]);
  }
});
const monthTableProps = {
  tableDate: {
    type: Date,
    required: true
  },
  disabledDate: {
    type: Function
  },
  selectionMode: {
    type: String,
    required: true
  },
  modelValue: {
    type: [Date, String, Number, Array],
    required: true
  },
  rangeState: {
    type: Object,
    default: () => ({
      from: null,
      to: null,
      selecting: false
    })
  },
  focusedDate: {
    type: Date,
    required: true
  },
  cellClass: {
    type: Function,
    default: () => ""
  }
};
var MonthTable = defineComponent({
  name: "MonthTable",
  props: monthTableProps,
  emits: ["pick", "pick-click", "change-range"],
  setup(props2, {
    emit
  }) {
    const dates = computed(() => {
      const {
        selectionMode,
        modelValue,
        rangeState
      } = props2;
      const rangeSelecting = selectionMode === "range" && rangeState.selecting;
      return rangeSelecting ? [rangeState.from] : modelValue;
    });
    const cells = computed(() => {
      const cells2 = [];
      const cellTmpl = {
        text: "",
        selected: false,
        disabled: false
      };
      const tableYear = props2.tableDate.getFullYear();
      const selectedDays = dates.value.filter(Boolean).map((date) => clearHours(new Date(date.getFullYear(), date.getMonth(), 1)));
      const focusedDate = clearHours(new Date(props2.focusedDate.getFullYear(), props2.focusedDate.getMonth(), 1));
      for (let i2 = 0; i2 < 12; i2++) {
        const cell = JSON.parse(JSON.stringify(cellTmpl));
        cell.date = new Date(tableYear, i2, 1);
        cell.text = tCell(i2 + 1);
        const day = clearHours(cell.date);
        cell.disabled = typeof props2.disabledDate === "function" && props2.disabledDate(cell.date) && props2.selectionMode === "month";
        cell.selected = selectedDays.includes(day);
        cell.focused = day === focusedDate;
        cells2.push(cell);
      }
      return cells2;
    });
    const tCell = (nr) => String(nr).length > 1 ? nr : `0${nr}`;
    const getCellCls = (cell) => [resolveClassName("date-picker-cells-cell"), {
      [resolveClassName("date-picker-cells-cell-selected")]: cell.selected,
      [resolveClassName("date-picker-cells-cell-disabled")]: cell.disabled,
      [resolveClassName("date-picker-cells-cell-range")]: cell.range && !cell.start && !cell.end
    }];
    const handleClick = (cell) => {
      if (cell.disabled || cell.type === "weekLabel") {
        return;
      }
      const newDate = new Date(clearHours(cell.date));
      emit("pick", newDate);
      emit("pick-click");
    };
    const handleMouseMove = (cell) => {
      if (!props2.rangeState.selecting) {
        return;
      }
      if (cell.disabled) {
        return;
      }
      const newDate = cell.date;
      emit("change-range", newDate);
    };
    return {
      cells,
      getCellCls,
      handleClick,
      handleMouseMove
    };
  },
  render() {
    return createVNode("div", {
      "class": [resolveClassName("date-picker-cells"), resolveClassName("date-picker-cells-month")]
    }, [this.cells.map((cell) => createVNode("span", {
      "class": this.getCellCls(cell),
      "onClick": () => this.handleClick(cell),
      "onMouseenter": () => this.handleMouseMove(cell)
    }, [createVNode("em", null, [cell.text])]))]);
  }
});
const yearTableProps = {
  tableDate: {
    type: Date,
    required: true
  },
  disabledDate: {
    type: Function
  },
  selectionMode: {
    type: String,
    required: true
  },
  modelValue: {
    type: [Date, String, Number, Array],
    required: true
  },
  rangeState: {
    type: Object,
    default: () => ({
      from: null,
      to: null,
      selecting: false
    })
  },
  focusedDate: {
    type: Date,
    required: true
  },
  cellClass: {
    type: Function,
    default: () => ""
  }
};
var YearTable = defineComponent({
  name: "YearTable",
  props: yearTableProps,
  emits: ["pick", "pick-click", "change-range"],
  setup(props2, {
    emit
  }) {
    const dates = computed(() => {
      const {
        selectionMode,
        modelValue,
        rangeState
      } = props2;
      const rangeSelecting = selectionMode === "range" && rangeState.selecting;
      return rangeSelecting ? [rangeState.from] : modelValue;
    });
    const startYear = computed(() => Math.floor(props2.tableDate.getFullYear() / 10) * 10);
    const cells = computed(() => {
      const cells2 = [];
      const cellTmpl = {
        text: "",
        selected: false,
        disabled: false
      };
      const selectedDays = dates.value.filter(Boolean).map((date) => clearHours(new Date(date.getFullYear(), 0, 1)));
      const focusedDate = clearHours(new Date(props2.focusedDate.getFullYear(), 0, 1));
      for (let i2 = 0; i2 < 10; i2++) {
        const cell = JSON.parse(JSON.stringify(cellTmpl));
        cell.date = new Date(startYear.value + i2, 0, 1);
        cell.disabled = typeof props2.disabledDate === "function" && props2.disabledDate(cell.date) && props2.selectionMode === "year";
        const day = clearHours(cell.date);
        cell.selected = selectedDays.includes(day);
        cell.focused = day === focusedDate;
        cells2.push(cell);
      }
      return cells2;
    });
    const getCellCls = (cell) => [resolveClassName("date-picker-cells-cell"), {
      [resolveClassName("date-picker-cells-cell-selected")]: cell.selected,
      [resolveClassName("date-picker-cells-cell-disabled")]: cell.disabled,
      [resolveClassName("date-picker-cells-cell-range")]: cell.range && !cell.start && !cell.end
    }];
    const handleClick = (cell) => {
      if (cell.disabled || cell.type === "weekLabel") {
        return;
      }
      const newDate = new Date(clearHours(cell.date));
      emit("pick", newDate);
      emit("pick-click");
    };
    const handleMouseMove = (cell) => {
      if (!props2.rangeState.selecting) {
        return;
      }
      if (cell.disabled) {
        return;
      }
      const newDate = cell.date;
      emit("change-range", newDate);
    };
    return {
      cells,
      getCellCls,
      handleClick,
      handleMouseMove
    };
  },
  render() {
    return createVNode("div", {
      "class": [resolveClassName("date-picker-cells"), resolveClassName("date-picker-cells-year")]
    }, [this.cells.map((cell) => createVNode("span", {
      "class": this.getCellCls(cell),
      "onClick": () => this.handleClick(cell),
      "onMouseenter": () => this.handleMouseMove(cell)
    }, [createVNode("em", null, [cell.date.getFullYear()])]))]);
  }
});
const datePickerProps = {
  type: {
    type: String,
    default: "date",
    validator(value) {
      const validList = ["year", "month", "date", "daterange", "datetime", "datetimerange", "time", "timerange"];
      if (validList.indexOf(value) < 0) {
        console.error(`type property is not valid: '${value}'`);
        return false;
      }
      return true;
    }
  },
  extPopoverCls: {
    type: String,
    default: ""
  },
  format: String,
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  editable: {
    type: Boolean,
    default: true
  },
  clearable: {
    type: Boolean,
    default: true
  },
  open: {
    type: Boolean,
    default: null
  },
  multiple: {
    type: Boolean,
    default: false
  },
  timePickerOptions: {
    type: Object,
    default: () => ({})
  },
  splitPanels: {
    type: Boolean,
    default: true
  },
  startDate: Date,
  placeholder: {
    type: String,
    default: ""
  },
  placement: {
    type: String,
    default: "bottom-start",
    validator: (value) => {
      const validList = [
        "top",
        "top-start",
        "top-end",
        "bottom",
        "bottom-start",
        "bottom-end",
        "left",
        "left-start",
        "left-end",
        "right",
        "right-start",
        "right-end"
      ];
      if (validList.indexOf(value) < 0) {
        console.error(`placement property is not valid: '${value}'`);
        return false;
      }
      return true;
    }
  },
  transfer: {
    type: Boolean,
    default: false
  },
  appendToBody: {
    type: Boolean,
    default: false
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  shortcutClose: {
    type: Boolean,
    default: false
  },
  modelValue: {
    type: [Date, String, Number, Array]
  },
  value: {
    type: [Date, String, Number, Array]
  },
  options: {
    type: Object,
    default: () => ({})
  },
  fontSize: {
    type: String,
    default: "normal"
  },
  upToNow: {
    type: Boolean,
    default: false
  },
  useShortcutText: {
    type: Boolean,
    default: false
  },
  shortcutSelectedIndex: {
    type: Number,
    default: -1
  },
  headerSlotCls: {
    type: String,
    default: ""
  },
  footerSlotCls: {
    type: String,
    default: ""
  },
  allowCrossDay: {
    type: Boolean,
    default: false
  },
  behavior: {
    type: String,
    default: "normal",
    validator(v2) {
      return ["simplicity", "normal"].indexOf(v2) > -1;
    }
  },
  disabledDate: Function,
  withValidate: {
    type: Boolean,
    default: true
  }
};
const timePanelProps = {
  disabledHours: {
    type: Array,
    default: () => []
  },
  disabledMinutes: {
    type: Array,
    default: () => []
  },
  disabledSeconds: {
    type: Array,
    default: () => []
  },
  hideDisabledOptions: {
    type: Boolean,
    default: false
  },
  width: {
    type: Number,
    default: 261
  },
  enterMode: {
    type: Boolean,
    default: true
  }
};
const timePickerProps = {
  type: {
    type: String,
    default: "time",
    validator(value) {
      const validList = ["time", "timerange"];
      if (validList.indexOf(value) < 0) {
        console.error(`type property is not valid: '${value}'`);
        return false;
      }
      return true;
    }
  },
  allowCrossDay: {
    type: Boolean,
    default: false
  }
};
const timeSpinnerProps = {
  hours: {
    type: [Number, String],
    default: NaN
  },
  minutes: {
    type: [Number, String],
    default: NaN
  },
  seconds: {
    type: [Number, String],
    default: NaN
  },
  showSeconds: {
    type: Boolean,
    default: true
  },
  steps: {
    type: Array,
    default: () => []
  }
};
const timeParts = ["hours", "minutes", "seconds"];
var TimeSpinner = defineComponent({
  name: "TimeSpinner",
  props: __spreadValues(__spreadValues({}, timeSpinnerProps), timePanelProps),
  emits: ["change", "pick-click"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("datePicker");
    const state = reactive({
      spinerSteps: [1, 1, 1].map((one, i2) => Math.abs(props2.steps[i2]) || one),
      compiled: false,
      focusedColumn: -1,
      focusedTime: [0, 0, 0]
    });
    const hoursList = computed(() => {
      const hours = [];
      const step = state.spinerSteps[0];
      const focusedHour = state.focusedColumn === 0 && state.focusedTime[0];
      const hourTmpl = {
        text: 0,
        selected: false,
        disabled: false,
        hide: false
      };
      for (let i2 = 0; i2 < 24; i2 += step) {
        const hour = JSON.parse(JSON.stringify(hourTmpl));
        hour.text = i2;
        hour.focused = i2 === focusedHour;
        if (props2.disabledHours.length && props2.disabledHours.indexOf(i2) > -1) {
          hour.disabled = true;
          if (props2.hideDisabledOptions) {
            hour.hide = true;
          }
        }
        if (props2.hours === i2) {
          hour.selected = true;
        }
        hours.push(hour);
      }
      return hours;
    });
    const minutesList = computed(() => {
      const minutes = [];
      const step = state.spinerSteps[1];
      const focusedMinute = state.focusedColumn === 1 && state.focusedTime[1];
      const minuteTmpl = {
        text: 0,
        selected: false,
        disabled: false,
        hide: false
      };
      for (let i2 = 0; i2 < 60; i2 += step) {
        const minute = JSON.parse(JSON.stringify(minuteTmpl));
        minute.text = i2;
        minute.focused = i2 === focusedMinute;
        if (props2.disabledMinutes.length && props2.disabledMinutes.indexOf(i2) > -1) {
          minute.disabled = true;
          if (props2.hideDisabledOptions) {
            minute.hide = true;
          }
        }
        if (props2.minutes === i2) {
          minute.selected = true;
        }
        minutes.push(minute);
      }
      return minutes;
    });
    const secondsList = computed(() => {
      const seconds = [];
      const step = state.spinerSteps[2];
      const focusedMinute = state.focusedColumn === 2 && state.focusedTime[2];
      const secondTmpl = {
        text: 0,
        selected: false,
        disabled: false,
        hide: false
      };
      for (let i2 = 0; i2 < 60; i2 += step) {
        const second = JSON.parse(JSON.stringify(secondTmpl));
        second.text = i2;
        second.focused = i2 === focusedMinute;
        if (props2.disabledSeconds.length && props2.disabledSeconds.indexOf(i2) > -1) {
          second.disabled = true;
          if (props2.hideDisabledOptions) {
            second.hide = true;
          }
        }
        if (props2.seconds === i2) {
          second.selected = true;
        }
        seconds.push(second);
      }
      return seconds;
    });
    const styles = computed(() => ({
      width: props2.showSeconds ? "33.33%" : "50%"
    }));
    watch(() => props2.hours, (val) => {
      if (!state.compiled) {
        return;
      }
      scroll("hours", hoursList.value.findIndex((obj) => obj.text === val));
    });
    watch(() => props2.minutes, (val) => {
      if (!state.compiled) {
        return;
      }
      scroll("minutes", minutesList.value.findIndex((obj) => obj.text === val));
    });
    watch(() => props2.seconds, (val) => {
      if (!state.compiled) {
        return;
      }
      scroll("seconds", minutesList.value.findIndex((obj) => obj.text === val));
    });
    watch(() => state.focusedTime, (updated, old) => {
      timeParts.forEach((part, i2) => {
        if (updated[i2] === old[i2] || typeof updated[i2] === "undefined") {
          return;
        }
        const valueIndex = this[`${part}List`].findIndex((obj) => obj.text === updated[i2]);
        scroll(part, valueIndex);
      });
    });
    onMounted(() => {
      nextTick(() => {
        state.compiled = true;
        bindWheelEvent();
      });
    });
    function getDomRef(type) {
      let domRef;
      if (type === "hours") {
        domRef = hoursRef;
      } else if (type === "minutes") {
        domRef = minutesRef;
      } else {
        domRef = secondsRef;
      }
      return domRef.value;
    }
    function getCellCls(cell) {
      return [resolveClassName("time-picker-cells-cell"), {
        [resolveClassName("time-picker-cells-cell-selected")]: cell.selected,
        [resolveClassName("time-picker-cells-cell-focused")]: cell.focused,
        [resolveClassName("time-picker-cells-cell-disabled")]: cell.disabled
      }];
    }
    function bindWheelEvent() {
      const bindFunction = (type) => {
        const domRef = getDomRef(type);
        domRef.addEventListener("wheel", lodash.exports.debounce(() => {
          handleWheel(type);
        }, 32), {
          passive: true
        });
      };
      bindFunction("hours");
      bindFunction("minutes");
      bindFunction("seconds");
    }
    function typeItemHeight(type) {
      const domRef = getDomRef(type);
      return domRef.querySelector("li").offsetHeight;
    }
    function scrollBarHeight(type) {
      const domRef = getDomRef(type);
      return domRef.offsetHeight;
    }
    function handleWheel(type) {
      const domRef = getDomRef(type);
      const value = Math.min(Math.round((domRef.scrollTop - (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) + 3) / typeItemHeight(type)), type === "hours" ? 23 : 59);
      let list;
      if (type === "hours") {
        list = hoursList;
      } else if (type === "minutes") {
        list = minutesList;
      } else {
        list = secondsList;
      }
      const item = list.value.find((data2) => data2.text === value);
      if (item.disabled) {
        return false;
      }
      nextTick(() => {
        emitChange({
          [type]: value
        });
      });
    }
    function handleClick(type, cell) {
      if (cell.disabled) {
        return;
      }
      const data2 = {
        [type]: cell.text
      };
      emitChange(data2);
    }
    function emitChange(changes) {
      emit("change", changes);
      emit("pick-click");
    }
    function scroll(type, index2) {
      const domRef = getDomRef(type);
      const from = domRef.scrollTop;
      const to = 32 * getScrollIndex(type, index2);
      scrollTop(domRef, from, to, 500);
    }
    function getScrollIndex(type, index2) {
      const t3 = firstUpperCase(type);
      const disabled = props2[`disabled${t3}`];
      let ret = index2;
      if (disabled.length && props2.hideDisabledOptions) {
        let count = 0;
        disabled.forEach((item) => item <= index2 ? count += 1 : "");
        ret -= count;
      }
      return ret;
    }
    function updateScroll() {
      nextTick(() => {
        timeParts.forEach((type) => {
          const domRef = getDomRef(type);
          let list;
          if (type === "hours") {
            list = hoursList;
          } else if (type === "minutes") {
            list = minutesList;
          } else {
            list = secondsList;
          }
          domRef.scrollTop = 32 * list.value.findIndex((obj) => obj.text === props2[type]);
        });
      });
    }
    function padTime(text) {
      return text < 10 ? `0${text}` : text;
    }
    const hoursRef = ref(null);
    const minutesRef = ref(null);
    const secondsRef = ref(null);
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      hoursList,
      minutesList,
      secondsList,
      styles,
      hoursRef,
      minutesRef,
      secondsRef,
      getCellCls,
      handleClick,
      updateScroll,
      padTime,
      t: t2
    });
  },
  render() {
    return createVNode("div", {
      "class": [resolveClassName("time-picker-cells"), this.showSeconds ? resolveClassName("time-picker-cells-with-seconds") : ""]
    }, [createVNode("div", {
      "class": resolveClassName("time-picker-cells-title-wrapper")
    }, [createVNode("div", {
      "class": [resolveClassName("time-picker-cells-title"), this.focusedColumn === 0 ? "active" : ""],
      "style": this.styles
    }, [this.t.hour]), createVNode("div", {
      "class": [resolveClassName("time-picker-cells-title"), this.focusedColumn === 1 ? "active" : ""],
      "style": this.styles
    }, [this.t.min]), withDirectives(createVNode("div", {
      "class": [resolveClassName("time-picker-cells-title"), this.focusedColumn === 2 ? "active" : ""],
      "style": this.styles
    }, [this.t.sec]), [[vShow, this.showSeconds]])]), createVNode("div", {
      "class": resolveClassName("time-picker-cells-list"),
      "ref": "hoursRef",
      "style": this.styles
    }, [createVNode("ul", {
      "class": resolveClassName("time-picker-cells-ul")
    }, [this.hoursList.map((item) => withDirectives(createVNode("li", {
      "class": this.getCellCls(item),
      "onClick": () => this.handleClick("hours", item)
    }, [this.padTime(item.text)]), [[vShow, !item.hide]]))])]), createVNode("div", {
      "class": resolveClassName("time-picker-cells-list"),
      "ref": "minutesRef",
      "style": this.styles
    }, [createVNode("ul", {
      "class": resolveClassName("time-picker-cells-ul")
    }, [this.minutesList.map((item) => withDirectives(createVNode("li", {
      "class": this.getCellCls(item),
      "onClick": () => this.handleClick("minutes", item)
    }, [this.padTime(item.text)]), [[vShow, !item.hide]]))])]), withDirectives(createVNode("div", {
      "class": resolveClassName("time-picker-cells-list"),
      "ref": "secondsRef",
      "style": this.styles
    }, [createVNode("ul", {
      "class": resolveClassName("time-picker-cells-ul")
    }, [this.secondsList.map((item) => withDirectives(createVNode("li", {
      "class": this.getCellCls(item),
      "onClick": () => this.handleClick("seconds", item)
    }, [this.padTime(item.text)]), [[vShow, !item.hide]]))])]), [[vShow, this.showSeconds]])]);
  }
});
const timeProps = {
  disabledDate: {
    type: Function,
    default: () => false
  },
  steps: {
    type: Array,
    default: () => []
  },
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  value: {
    type: Array,
    required: true
  },
  confirm: {
    type: Boolean,
    default: false
  }
};
var TimePanel = defineComponent({
  name: "TimePanel",
  props: __spreadValues(__spreadValues(__spreadValues({}, datePickerProps), timePanelProps), timeProps),
  emits: ["pick", "pick-click"],
  setup(props2, {
    emit
  }) {
    const state = reactive({
      date: props2.value[0] || initTime(),
      showDate: false
    });
    const parentProvide = inject(timePickerKey);
    const timeSpinnerRef = ref(null);
    const showSeconds = computed(() => !(props2.format || "").match(/mm$/));
    const visibleDate = computed(() => fecha.format(parentProvide.panelDate, props2.format));
    const timeSlots = computed(() => {
      if (!props2.value[0]) {
        return [];
      }
      return ["getHours", "getMinutes", "getSeconds"].map((slot) => state.date[slot]());
    });
    const disabledHMS = computed(() => {
      const disabledTypes = ["disabledHours", "disabledMinutes", "disabledSeconds"];
      if (props2.disabledDate === (() => !props2.value[0])) {
        const disabled2 = disabledTypes.reduce((obj, type) => {
          obj[type] = this[type];
          return obj;
        }, {});
        return disabled2;
      }
      const slots = [24, 60, 60];
      const disabled = ["Hours", "Minutes", "Seconds"].map((type) => props2[`disabled${type}`]);
      const disabledHMS2 = disabled.map((preDisabled, j2) => {
        const slot = slots[j2];
        const toDisable = preDisabled;
        for (let i2 = 0; i2 < slot; i2 += props2.steps[j2] || 1) {
          const hms = timeSlots.value.map((slot2, x2) => x2 === j2 ? i2 : slot2);
          const testDateTime = mergeDateHMS(state.date, ...hms);
          if (props2.disabledDate(testDateTime, true)) {
            toDisable.push(i2);
          }
        }
        return toDisable.filter((el, i2, arr) => arr.indexOf(el) === i2);
      });
      return disabledTypes.reduce((obj, type, i2) => {
        obj[type] = disabledHMS2[i2];
        return obj;
      }, {});
    });
    watch(() => props2.value, (dates) => {
      let newVal = dates[0] || initTime();
      newVal = new Date(newVal);
      state.date = newVal;
    });
    onMounted(() => {
      if (parentProvide && parentProvide.parentName === "DatePanel") {
        state.showDate = true;
      }
    });
    function handleChange(date, isEmit = true) {
      const newDate = new Date(state.date);
      Object.keys(date).forEach((type) => newDate[`set${capitalize(type)}`](date[type]));
      if (isEmit) {
        emit("pick", newDate, true, "time");
      }
    }
    function handlePickClick() {
      emit("pick-click");
    }
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      visibleDate,
      showSeconds,
      timeSlots,
      disabledHMS,
      timeSpinnerRef,
      handlePickClick,
      handleChange
    });
  },
  render() {
    return createVNode("div", {
      "class": resolveClassName("picker-panel-body-wrapper"),
      "onMousedown": (e) => {
        e.preventDefault();
      }
    }, [createVNode("div", {
      "class": resolveClassName("picker-panel-body"),
      "style": {
        width: `${this.width}px`
      }
    }, [this.showDate ? createVNode("div", {
      "class": resolveClassName("time-picker-header")
    }, [this.visibleDate]) : "", createVNode("div", {
      "class": resolveClassName("picker-panel-content")
    }, [createVNode(TimeSpinner, {
      "ref": "timeSpinnerRef",
      "showSeconds": this.showSeconds,
      "steps": this.steps,
      "hours": this.timeSlots[0],
      "minutes": this.timeSlots[1],
      "seconds": this.timeSlots[2],
      "disabledHours": this.disabledHMS.disabledHours,
      "disabledMinutes": this.disabledHMS.disabledMinutes,
      "disabledSeconds": this.disabledHMS.disabledSeconds,
      "hideDisabledOptions": this.hideDisabledOptions,
      "onPick-click": this.handlePickClick,
      "onChange": this.handleChange
    }, null)])])]);
  }
});
const datePanelProps = {
  modelValue: {
    type: [Date, String, Number, Array]
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  multiple: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: true
  },
  shortcutClose: {
    type: Boolean,
    default: false
  },
  selectionMode: {
    type: String,
    default: "date",
    validator(v2) {
      if (["year", "month", "date", "time"].indexOf(v2) < 0) {
        console.error(`selectionMode property is not valid: '${v2}'`);
        return false;
      }
      return true;
    }
  },
  startDate: {
    type: Date
  },
  focusedDate: {
    type: Date,
    required: true
  },
  confirm: {
    type: Boolean,
    default: false
  },
  showTime: {
    type: Boolean,
    default: false
  },
  format: {
    type: String,
    default: "yyyy-MM-dd"
  },
  disabledDate: {
    type: Function,
    default: () => false
  },
  timePickerOptions: {
    type: Object,
    default: () => ({})
  }
};
var DatePanel = defineComponent({
  name: "DatePanel",
  props: datePanelProps,
  emits: ["pick", "pick-success", "pick-clear", "pick-click", "selection-mode-change"],
  setup(props2, {
    slots,
    emit
  }) {
    const getTableType = (currentView) => currentView.match(/^time/) ? "time-picker" : `${currentView}-table`;
    const dates = props2.modelValue.slice().sort();
    const state = reactive({
      currentView: props2.selectionMode || "date",
      pickerTable: getTableType(props2.selectionMode),
      dates,
      panelDate: props2.startDate || dates[0] || new Date()
    });
    const {
      proxy
    } = getCurrentInstance();
    provide(timePickerKey, {
      panelDate: state.panelDate,
      parentName: proxy.$options.name
    });
    const timePickerRef = ref(null);
    const timeSpinnerRef = ref(null);
    const timeSpinnerEndRef = ref(null);
    watch(() => state.currentView, (val) => {
      emit("selection-mode-change", val);
      if (state.currentView === "time") {
        nextTick(() => {
          const spinner2 = timePickerRef.value.timeSpinnerRef;
          spinner2.updateScroll();
        });
      }
    });
    watch(() => props2.selectionMode, (type) => {
      state.currentView = type;
      state.pickerTable = getTableType(type);
    });
    watch(() => props2.modelValue, (newVal) => {
      state.dates = newVal;
      const panelDate = props2.multiple ? state.dates[state.dates.length - 1] : props2.startDate || state.dates[0];
      state.panelDate = panelDate || new Date();
    });
    const resetView = () => {
      setTimeout(() => {
        state.currentView = props2.selectionMode;
      }, 500);
    };
    const handlePreSelection = (value) => {
      state.panelDate = value;
      if (state.pickerTable === "year-table") {
        state.pickerTable = "month-table";
      } else {
        state.pickerTable = getTableType(state.currentView);
      }
    };
    const handlePick = (value, type) => {
      let val = value;
      if (props2.selectionMode === "year") {
        val = new Date(value.getFullYear(), 0, 1);
      } else if (props2.selectionMode === "month") {
        val = new Date(state.panelDate.getFullYear(), value.getMonth(), 1);
      } else {
        val = new Date(value);
      }
      state.dates = [val];
      emit("pick", val, false, type || props2.selectionMode);
    };
    const handlePickSuccess = () => {
      resetView();
      emit("pick-success");
    };
    const handlePickClear = () => {
      resetView();
      emit("pick-clear");
    };
    const handleShortcutClick = (shortcut) => {
      if (shortcut.value) {
        emit("pick", shortcut.value(), false, void 0, shortcut);
      }
      if (shortcut.onClick) {
        shortcut.onClick(this);
      }
      if (props2.shortcutClose) {
        handlePickSuccess();
      }
    };
    const reset2 = () => {
      state.currentView = props2.selectionMode;
      state.pickerTable = getTableType(state.currentView);
    };
    const changeYear = (dir) => {
      if (props2.selectionMode === "year" || state.pickerTable === "year-table") {
        state.panelDate = new Date(state.panelDate.getFullYear() + dir * 10, 0, 1);
      } else {
        state.panelDate = siblingMonth(state.panelDate, dir * 12);
      }
    };
    const changeMonth = (dir) => {
      state.panelDate = siblingMonth(state.panelDate, dir);
    };
    const onToggleVisibility = (open) => {
      var _a, _b;
      if (open) {
        (_a = timeSpinnerRef == null ? void 0 : timeSpinnerRef.value) == null ? void 0 : _a.updateScroll();
        (_b = timeSpinnerEndRef == null ? void 0 : timeSpinnerEndRef.value) == null ? void 0 : _b.updateScroll();
      }
    };
    const panelPickerHandlers = computed(() => state.pickerTable === `${state.currentView}-table` ? handlePick : handlePreSelection);
    const datePanelLabel = computed(() => {
      const locale2 = "zh-CN";
      const datePanelLabelStr = "[yyyy]-[mm]";
      const date = state.panelDate;
      const {
        labels: labels2,
        separator: separator2
      } = formatDateLabels(locale2, datePanelLabelStr, date);
      const handler = (type) => () => {
        state.pickerTable = getTableType(type);
      };
      return {
        separator: separator2,
        labels: labels2.map((obj) => {
          const ret = obj;
          ret.handler = handler(obj.type);
          return ret;
        })
      };
    });
    const showLabelFirst = computed(() => datePanelLabel.value.labels[0].type === "year" || state.currentView === "date");
    const showLabelSecond = computed(() => datePanelLabel.value.labels[1].type === "year" || state.currentView === "date");
    const isTime = computed(() => state.currentView === "time");
    const handleToggleTime = () => {
      state.currentView = state.currentView === "time" ? "date" : "time";
    };
    const hasShortcuts = computed(() => !!slots.shortcuts);
    const timeDisabled = computed(() => !state.dates[0]);
    function handlePickClick() {
      emit("pick-click");
    }
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      panelPickerHandlers,
      datePanelLabel,
      showLabelFirst,
      showLabelSecond,
      handleShortcutClick,
      changeYear,
      changeMonth,
      reset: reset2,
      isTime,
      hasShortcuts,
      timeDisabled,
      onToggleVisibility,
      handleToggleTime,
      handlePickSuccess,
      handlePickClear,
      handlePick,
      handlePickClick,
      timePickerRef
    });
  },
  render() {
    var _a, _b, _c;
    return createVNode("div", {
      "class": [resolveClassName("picker-panel-body-wrapper"), this.shortcuts.length || this.hasShortcuts ? resolveClassName("picker-panel-with-sidebar") : ""],
      "onMousedown": (e) => {
        e.preventDefault();
      }
    }, [this.shortcuts.length ? createVNode("div", {
      "class": "lesscode-bk-picker-panel-sidebar"
    }, [this.shortcuts.map((shortcut) => createVNode("div", {
      "class": resolveClassName("picker-panel-shortcut"),
      "onClick": () => this.handleShortcutClick(shortcut)
    }, [shortcut.text]))]) : "", createVNode("div", {
      "class": resolveClassName("picker-panel-body"),
      "style": "width: 261px;"
    }, [withDirectives(createVNode("div", {
      "class": resolveClassName("date-picker-header")
    }, [createVNode("span", {
      "class": iconBtnCls("prev", "-double"),
      "onClick": () => this.changeYear(-1)
    }, [createVNode(angleDoubleLeft, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), this.pickerTable === "date-table" ? withDirectives(createVNode("span", {
      "class": iconBtnCls("prev"),
      "onClick": () => this.changeMonth(-1)
    }, [createVNode(angleLeft, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), [[vShow, this.currentView === "date"]]) : "", this.datePanelLabel && Object.keys(this.datePanelLabel).length > 0 ? createVNode("span", null, [withDirectives(createVNode("span", {
      "class": resolveClassName("date-picker-header-label"),
      "onClick": () => this.datePanelLabel.labels[0].handler
    }, [this.datePanelLabel.labels[0].label]), [[vShow, this.showLabelFirst]]), this.currentView === "date" ? ` ${this.datePanelLabel.separator} ` : " ", withDirectives(createVNode("span", {
      "class": resolveClassName("date-picker-header-label"),
      "onClick": () => this.datePanelLabel.labels[1].handler
    }, [this.datePanelLabel.labels[1].label]), [[vShow, this.showLabelSecond]])]) : "", createVNode("span", {
      "class": iconBtnCls("next", "-double"),
      "onClick": () => this.changeYear(1)
    }, [createVNode(angleDoubleRight, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), this.pickerTable === "date-table" ? withDirectives(createVNode("span", {
      "class": iconBtnCls("next"),
      "onClick": () => this.changeMonth(1)
    }, [createVNode(angleRight, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), [[vShow, this.currentView === "date"]]) : ""]), [[vShow, this.currentView !== "time"]]), createVNode("div", {
      "class": resolveClassName("picker-panel-content")
    }, [this.currentView !== "time" ? (() => {
      switch (this.pickerTable) {
        case "date-table":
          return createVNode(DateTable, {
            "tableDate": this.panelDate,
            "disabledDate": this.disabledDate,
            "selectionMode": this.selectionMode,
            "modelValue": this.dates,
            "focusedDate": this.focusedDate,
            "onPick": this.panelPickerHandlers
          }, null);
        case "year-table":
          return createVNode(YearTable, {
            "tableDate": this.panelDate,
            "disabledDate": this.disabledDate,
            "selectionMode": this.selectionMode,
            "modelValue": this.dates,
            "focusedDate": this.focusedDate,
            "onPick": this.panelPickerHandlers
          }, null);
        case "month-table":
          return createVNode(MonthTable, {
            "tableDate": this.panelDate,
            "disabledDate": this.disabledDate,
            "selectionMode": this.selectionMode,
            "modelValue": this.dates,
            "focusedDate": this.focusedDate,
            "onPick": this.panelPickerHandlers
          }, null);
        default:
          return null;
      }
    })() : createVNode(TimePanel, {
      "ref": "timePickerRef",
      "value": this.dates,
      "format": this.format,
      "disabledDate": this.disabledDate,
      "onPick": this.handlePick,
      "onPick-click": this.handlePickClick,
      "onPick-clear": this.handlePickClear,
      "onPick-success": this.handlePickSuccess,
      "onPick-toggle-time": this.handleToggleTime
    }, null)]), this.confirm ? createVNode(Confirm, {
      "clearable": this.clearable,
      "showTime": this.showTime,
      "timeDisabled": this.timeDisabled,
      "isTime": this.isTime,
      "onPick-toggle-time": this.handleToggleTime,
      "onPick-clear": this.handlePickClear,
      "onPick-success": this.handlePickSuccess
    }, this.$slots) : ""]), this.hasShortcuts ? createVNode("div", {
      "class": resolveClassName("picker-panel-sidebar")
    }, [(_c = (_b = (_a = this.$slots).shortcuts) == null ? void 0 : _b.call(_a)) != null ? _c : null]) : null]);
  }
});
const timeRangeProps = {
  steps: {
    type: Array,
    default: () => []
  },
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  value: {
    type: Array,
    required: true
  },
  allowCrossDay: {
    type: Boolean,
    default: false
  }
};
var TimeRangePanel = defineComponent({
  name: "TimeRangePanel",
  props: __spreadValues(__spreadValues(__spreadValues({}, datePickerProps), timePanelProps), timeRangeProps),
  emits: ["pick", "pick-click"],
  setup(props2, {
    emit
  }) {
    const [dateStart, dateEnd] = props2.value.slice();
    const state = reactive({
      showDate: false,
      dateStart: dateStart || initTime(),
      dateEnd: dateEnd || initTime()
    });
    const parentProvide = inject(timePickerKey);
    const showSeconds = computed(() => !(props2.format || "").match(/mm$/));
    const leftDatePanelLabel = computed(() => fecha.format(parentProvide.dates[0], props2.format));
    const rightDatePanelLabel = computed(() => fecha.format(parentProvide.dates[1], props2.format));
    watch(() => props2.value, (dates) => {
      const [dateStart2, dateEnd2] = dates.slice();
      state.dateStart = dateStart2 || initTime();
      state.dateEnd = dateEnd2 || initTime();
    });
    onMounted(() => {
      if (parentProvide && parentProvide.parentName === "DatePanel") {
        state.showDate = true;
      }
    });
    function handlePickClick() {
      emit("pick-click");
    }
    function handleChange(idx, start2, end2, isEmit = true) {
      let dateStart2 = new Date(state.dateStart);
      let dateEnd2 = new Date(state.dateEnd);
      Object.keys(start2).forEach((type) => {
        dateStart2[`set${capitalize(type)}`](start2[type]);
      });
      Object.keys(end2).forEach((type) => {
        dateEnd2[`set${capitalize(type)}`](end2[type]);
      });
      if (!props2.allowCrossDay && dateEnd2 < dateStart2) {
        if (idx === "start") {
          dateEnd2 = dateStart2;
        }
        if (idx === "end") {
          dateStart2 = dateEnd2;
        }
      }
      if (isEmit) {
        emit("pick", [dateStart2, dateEnd2], true, "time");
      }
    }
    function handleStartChange(date) {
      handleChange("start", date, {});
    }
    function handleEndChange(date) {
      handleChange("end", {}, date);
    }
    const timeSpinnerRef = ref(null);
    const timeSpinnerEndRef = ref(null);
    function updateScroll() {
      var _a, _b;
      (_a = timeSpinnerRef == null ? void 0 : timeSpinnerRef.value) == null ? void 0 : _a.updateScroll();
      (_b = timeSpinnerEndRef == null ? void 0 : timeSpinnerEndRef.value) == null ? void 0 : _b.updateScroll();
    }
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      showSeconds,
      leftDatePanelLabel,
      rightDatePanelLabel,
      handleStartChange,
      handleEndChange,
      handlePickClick,
      updateScroll,
      timeSpinnerRef,
      timeSpinnerEndRef
    });
  },
  render() {
    return createVNode("div", {
      "class": [resolveClassName("picker-panel-body-wrapper"), resolveClassName("time-picker-with-range"), this.showSeconds ? resolveClassName("time-picker-with-seconds") : ""],
      "onMousedown": (e) => {
        e.preventDefault();
      }
    }, [createVNode("div", {
      "class": resolveClassName("picker-panel-body"),
      "style": {
        width: `${this.width * 2}px`
      }
    }, [createVNode("div", {
      "class": [resolveClassName("picker-panel-content"), resolveClassName("picker-panel-content-left")],
      "style": {
        width: `${this.width}px`
      }
    }, [this.showDate ? createVNode("div", {
      "class": "lesscode-bk-time-picker-header"
    }, [this.leftDatePanelLabel]) : "", createVNode(TimeSpinner, {
      "ref": "timeSpinnerRef",
      "steps": this.steps,
      "showSeconds": this.showSeconds,
      "hours": this.value[0] && this.dateStart.getHours(),
      "minutes": this.value[0] && this.dateStart.getMinutes(),
      "seconds": this.value[0] && this.dateStart.getSeconds(),
      "disabledHours": this.disabledHours,
      "disabledMinutes": this.disabledMinutes,
      "disabledSeconds": this.disabledSeconds,
      "hideDisabledOptions": this.hideDisabledOptions,
      "onChange": this.handleStartChange,
      "onPick-click": this.handlePickClick
    }, null)]), createVNode("div", {
      "class": [resolveClassName("picker-panel-content"), resolveClassName("picker-panel-content-right")],
      "style": {
        width: `${this.width}px`
      }
    }, [this.showDate ? createVNode("div", {
      "class": resolveClassName("time-picker-header")
    }, [this.rightDatePanelLabel]) : "", createVNode(TimeSpinner, {
      "ref": "timeSpinnerEndRef",
      "steps": this.steps,
      "showSeconds": this.showSeconds,
      "hours": this.value[1] && this.dateEnd.getHours(),
      "minutes": this.value[1] && this.dateEnd.getMinutes(),
      "seconds": this.value[1] && this.dateEnd.getSeconds(),
      "disabledHours": this.disabledHours,
      "disabledMinutes": this.disabledMinutes,
      "disabledSeconds": this.disabledSeconds,
      "hideDisabledOptions": this.hideDisabledOptions,
      "onChange": this.handleEndChange,
      "onPick-click": this.handlePickClick
    }, null)])])]);
  }
});
const dateRangePanelProps = {
  modelValue: {
    type: [Date, String, Number, Array]
  },
  type: {
    type: String,
    default: "date",
    validator(value) {
      const validList = ["year", "month", "date", "daterange", "datetime", "datetimerange", "time", "timerange"];
      if (validList.indexOf(value) < 0) {
        console.error(`type property is not valid: '${value}'`);
        return false;
      }
      return true;
    }
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  shortcutClose: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: true
  },
  splitPanels: {
    type: Boolean,
    default: true
  },
  showTime: {
    type: Boolean,
    default: false
  },
  selectionMode: {
    type: String,
    default: "date",
    validator(v2) {
      if (["year", "month", "date", "time"].indexOf(v2) < 0) {
        console.error(`selectionMode property is not valid: '${v2}'`);
        return false;
      }
      return true;
    }
  },
  startDate: {
    type: Date
  },
  upToNow: {
    type: Boolean,
    default: false
  },
  disabledDate: Function,
  focusedDate: {
    type: Date,
    required: true
  },
  confirm: {
    type: Boolean,
    default: false
  },
  format: {
    type: String,
    default: "yyyy-MM-dd"
  },
  timePickerOptions: {
    type: Object,
    default: () => ({})
  }
};
var DateRangePanel = defineComponent({
  name: "DateRangePanel",
  props: dateRangePanelProps,
  emits: ["pick", "pick-success", "pick-clear", "pick-click"],
  setup(props2, {
    slots,
    emit
  }) {
    const t2 = useLocale("datePicker");
    const [minDate, maxDate] = props2.modelValue.map((date) => date || initTime());
    const leftPanelDate = props2.startDate ? props2.startDate : minDate;
    const state = reactive({
      currentView: props2.selectionMode || "date",
      leftPickerTable: `${props2.selectionMode}-table`,
      rightPickerTable: `${props2.selectionMode}-table`,
      leftPanelDate,
      rightPanelDate: new Date(leftPanelDate.getFullYear(), leftPanelDate.getMonth() + 1, 1),
      rangeState: {
        from: props2.modelValue[0],
        to: props2.modelValue[1],
        selecting: minDate && !maxDate
      },
      upToNowEnable: false,
      dates: props2.modelValue
    });
    const {
      proxy
    } = getCurrentInstance();
    provide(timePickerKey, {
      dates: state.dates,
      parentName: proxy.$options.name
    });
    const dateSorter = (a2, b2) => {
      if (!a2 || !b2) {
        return 0;
      }
      return a2.getTime() - b2.getTime();
    };
    const reset2 = () => {
      state.currentView = props2.selectionMode;
      state.leftPickerTable = `${state.currentView}-table`;
      state.rightPickerTable = `${state.currentView}-table`;
    };
    const timeSpinner = ref(null);
    const timeSpinnerEnd = ref(null);
    const onToggleVisibility = (open) => {
      var _a, _b;
      if (open) {
        (_a = timeSpinner == null ? void 0 : timeSpinner.value) == null ? void 0 : _a.updateScroll();
        (_b = timeSpinnerEnd == null ? void 0 : timeSpinnerEnd.value) == null ? void 0 : _b.updateScroll();
      }
    };
    const changePanelDate = (panel, type, increment, updateOtherPanel = true) => {
      const current = new Date(state[`${panel}PanelDate`]);
      current[`set${type}`](current[`get${type}`]() + increment);
      state[`${panel}PanelDate`] = current;
      if (!updateOtherPanel) {
        return;
      }
      if (props2.splitPanels) {
        const otherPanel = panel === "left" ? "right" : "left";
        if (panel === "left" && state.leftPanelDate >= state.rightPanelDate) {
          changePanelDate(otherPanel, type, 1);
        }
        if (panel === "right" && state.rightPanelDate <= state.leftPanelDate) {
          changePanelDate(otherPanel, type, -1);
        }
      } else {
        const otherPanel = panel === "left" ? "right" : "left";
        const currentDate = state[`${otherPanel}PanelDate`];
        const temp = new Date(currentDate);
        if (type === "Month") {
          const nextMonthLastDate = new Date(temp.getFullYear(), temp.getMonth() + increment + 1, 0).getDate();
          temp.setDate(Math.min(nextMonthLastDate, temp.getDate()));
        }
        temp[`set${type}`](temp[`get${type}`]() + increment);
        state[`${otherPanel}PanelDate`] = temp;
      }
    };
    const prevYear = (panel) => {
      const increment = state.currentView === "year" ? -10 : -1;
      changePanelDate(panel, "FullYear", increment);
    };
    const nextYear = (panel) => {
      const increment = state.currentView === "year" ? 10 : 1;
      changePanelDate(panel, "FullYear", increment);
    };
    const prevMonth = (panel) => {
      changePanelDate(panel, "Month", -1);
    };
    const nextMonth = (panel) => {
      changePanelDate(panel, "Month", 1);
    };
    const showYearPicker = (panel) => {
      state[`${panel}PickerTable`] = "year-table";
    };
    const showMonthPicker = (panel) => {
      state[`${panel}PickerTable`] = "month-table";
    };
    const panelLabelConfig = (direction) => {
      const locale2 = "zh-CN";
      const datePanelLabel = "[yyyy]-[mm]";
      const date = state[`${direction}PanelDate`];
      const {
        labels: labels2,
        separator: separator2
      } = formatDateLabels(locale2, datePanelLabel, date);
      const handler = (type) => {
        const fn2 = type === "month" ? showMonthPicker : showYearPicker;
        return () => fn2(direction);
      };
      return {
        separator: separator2,
        labels: labels2.map((obj) => {
          const ret = obj;
          ret.handler = handler(obj.type);
          return ret;
        })
      };
    };
    const handleConfirm = (visible, type) => {
      emit("pick", state.dates, visible, type || props2.type);
    };
    const handleRangePick = (val, type) => {
      if (state.rangeState.selecting || state.currentView === "time") {
        if (state.currentView === "time") {
          state.dates = val;
        } else {
          const [minDate2, maxDate2] = [state.rangeState.from, val].sort(dateSorter);
          const maxDateLastMoment = type === "upToNow" ? new Date() : new Date(new Date(new Date(maxDate2.setHours(23)).setMinutes(59)).setSeconds(59));
          state.dates = [minDate2, maxDateLastMoment];
          state.rangeState = {
            from: minDate2,
            to: maxDateLastMoment,
            selecting: false
          };
        }
        handleConfirm(false, type || "date");
      } else {
        state.upToNowEnable = new Date(val).getTime() < new Date().getTime();
        state.rangeState = {
          from: val,
          to: null,
          selecting: true
        };
      }
    };
    const handlePreSelection = (panelPosition, value) => {
      state[`${panelPosition}PanelDate`] = value;
      const currentViewType = state[`${panelPosition}PickerTable`];
      if (currentViewType === "year-table") {
        state[`${panelPosition}PickerTable`] = "month-table";
      } else {
        state[`${panelPosition}PickerTable`] = `${state.currentView}-table`;
      }
      if (!props2.splitPanels) {
        const otherPanel = panelPosition === "left" ? "right" : "left";
        state[`${otherPanel}PanelDate`] = value;
        const increment = otherPanel === "left" ? -1 : 1;
        changePanelDate(otherPanel, "Month", increment, false);
      }
    };
    const handleShortcutClick = (shortcut, index2) => {
      if (!(shortcut == null ? void 0 : shortcut.value)) {
        return false;
      }
      if (shortcut.onClick) {
        shortcut.onClick(shortcut, index2);
      }
      const value = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      const [form2, to] = value;
      state.rangeState.from = form2;
      state.rangeState.to = to;
      state.dates = [form2, to];
      emit("pick", value, false, "shortcut", shortcut);
      if (props2.shortcutClose) {
        emit("pick-success");
      }
    };
    const handleChangeRange = (val) => {
      state.rangeState.to = val;
    };
    function setPanelDates(leftPanelDate2) {
      state.leftPanelDate = leftPanelDate2;
      const rightPanelDate = new Date(leftPanelDate2.getFullYear(), leftPanelDate2.getMonth() + 1, 1);
      const splitRightPanelDate = state.dates[1] ? state.dates[1].getTime() : state.dates[1];
      state.rightPanelDate = props2.splitPanels ? new Date(Math.max(splitRightPanelDate, rightPanelDate.getTime())) : rightPanelDate;
    }
    watch(() => props2.selectionMode, (v2) => {
      state.currentView = v2 || "range";
    });
    watch(() => props2.modelValue, (newVal) => {
      const minDate2 = newVal[0] ? toDate(newVal[0]) : null;
      const maxDate2 = newVal[1] ? toDate(newVal[1]) : null;
      state.dates = [minDate2, maxDate2].sort(dateSorter);
      state.rangeState = {
        from: state.dates[0],
        to: state.dates[1],
        selecting: false
      };
      setPanelDates(props2.startDate || state.dates[0] || new Date());
    });
    watch(() => state.currentView, (v2) => {
      const leftMonth = state.leftPanelDate.getMonth();
      const rightMonth = state.rightPanelDate.getMonth();
      const isSameYear = state.leftPanelDate.getFullYear() === state.rightPanelDate.getFullYear();
      if (v2 === "date" && isSameYear && leftMonth === rightMonth) {
        changePanelDate("right", "Month", 1);
      }
      if (v2 === "month" && isSameYear) {
        changePanelDate("right", "FullYear", 1);
      }
      if (v2 === "year" && isSameYear) {
        changePanelDate("right", "FullYear", 10);
      }
      if (state.currentView === "time") {
        nextTick(() => {
          timePickerRef.value.updateScroll();
        });
      }
    });
    const isTime = computed(() => state.currentView === "time");
    const leftDatePanelLabel = computed(() => panelLabelConfig("left"));
    const rightDatePanelLabel = computed(() => panelLabelConfig("right"));
    const leftDatePanelView = computed(() => state.leftPickerTable.split("-").shift());
    const rightDatePanelView = computed(() => state.rightPickerTable.split("-").shift());
    const leftShowLabelFirst = computed(() => leftDatePanelLabel.value.labels[0].type === "year" || state.currentView === "date");
    const leftShowLabelSecond = computed(() => leftDatePanelLabel.value.labels[1].type === "year" || state.currentView === "date");
    const rightShowLabelFirst = computed(() => rightDatePanelLabel.value.labels[0].type === "year" || state.currentView === "date");
    const rightShowLabelSecond = computed(() => rightDatePanelLabel.value.labels[1].type === "year" || state.currentView === "date");
    const preSelecting = computed(() => {
      const tableType = `${state.currentView}-table`;
      return {
        left: state.leftPickerTable !== tableType,
        right: state.rightPickerTable !== tableType
      };
    });
    const panelPickerHandlers = computed(() => ({
      left: preSelecting.value.left ? handlePreSelection.bind("left") : handleRangePick,
      right: preSelecting.value.right ? handlePreSelection.bind("right") : handleRangePick
    }));
    const hasShortcuts = computed(() => {
      var _a;
      return slots.shortcuts || ((_a = props2.shortcuts) == null ? void 0 : _a.length);
    });
    const handleToggleTime = () => {
      state.currentView = state.currentView === "time" ? "date" : "time";
    };
    const resetView = () => {
      setTimeout(() => {
        state.currentView = props2.selectionMode;
      }, 500);
    };
    const handlePickSuccess = () => {
      resetView();
      emit("pick-success");
    };
    const handlePickClear = () => {
      resetView();
      emit("pick-clear");
    };
    function handlePickClick() {
      emit("pick-click");
    }
    const timeDisabled = computed(() => !(state.dates[0] && state.dates[1]));
    const timePickerRef = ref(null);
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      isTime,
      hasShortcuts,
      prevYear,
      nextYear,
      prevMonth,
      nextMonth,
      leftDatePanelLabel,
      rightDatePanelLabel,
      leftDatePanelView,
      rightDatePanelView,
      leftShowLabelFirst,
      leftShowLabelSecond,
      rightShowLabelFirst,
      rightShowLabelSecond,
      preSelecting,
      panelPickerHandlers,
      timeDisabled,
      handleShortcutClick,
      reset: reset2,
      onToggleVisibility,
      handleRangePick,
      handleChangeRange,
      handleToggleTime,
      handlePickSuccess,
      handlePickClear,
      handlePickClick,
      timePickerRef,
      t: t2
    });
  },
  render() {
    let shortcuts = null;
    if (this.hasShortcuts) {
      let inner = "";
      if (this.$slots.shortcuts) {
        inner = typeof this.$slots.shortcuts === "function" ? this.$slots.shortcuts() : this.$slots.shortcuts;
      } else {
        if (this.shortcuts.length) {
          inner = createVNode("div", {
            "class": resolveClassName("picker-panel-shortcuts")
          }, [this.shortcuts.map((item, index2) => createVNode("div", {
            "key": index2,
            "class": "shortcuts-item",
            "onClick": () => this.handleShortcutClick(item, index2)
          }, [item.text]))]);
        }
      }
      shortcuts = createVNode("div", {
        "class": resolveClassName("picker-panel-sidebar")
      }, [inner]);
    }
    return createVNode("div", {
      "class": [resolveClassName("picker-panel-body-wrapper"), resolveClassName("date-picker-with-range"), this.shortcuts.length || this.$slots.shortcuts ? resolveClassName("picker-panel-with-sidebar") : ""],
      "onMousedown": (e) => {
        e.preventDefault();
      }
    }, [createVNode("div", {
      "class": [resolveClassName("picker-panel-body"), this.showTime ? resolveClassName("picker-panel-body-time") : resolveClassName("picker-panel-body-date")]
    }, [withDirectives(createVNode("div", {
      "class": [resolveClassName("picker-panel-content"), resolveClassName("picker-panel-content-left")],
      "style": "width: 261px;"
    }, [withDirectives(createVNode("div", {
      "class": resolveClassName("date-picker-header")
    }, [createVNode("span", {
      "class": iconBtnCls("prev", "-double"),
      "onClick": () => this.prevYear("left")
    }, [createVNode(angleDoubleLeft, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), this.leftPickerTable === "date-table" ? withDirectives(createVNode("span", {
      "class": iconBtnCls("prev"),
      "onClick": () => this.prevMonth("left")
    }, [createVNode(angleLeft, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), [[vShow, this.currentView === "date"]]) : "", this.leftDatePanelLabel && Object.keys(this.leftDatePanelLabel).length > 0 ? createVNode("span", null, [withDirectives(createVNode("span", {
      "class": resolveClassName("date-picker-header-label"),
      "onClick": () => this.leftDatePanelLabel.labels[0].handler
    }, [this.leftDatePanelLabel.labels[0].label]), [[vShow, this.leftShowLabelFirst]]), this.leftDatePanelView === "date" ? ` ${this.leftDatePanelLabel.separator} ` : " ", withDirectives(createVNode("span", {
      "class": resolveClassName("date-picker-header-label"),
      "onClick": () => this.leftDatePanelLabel.labels[1].handler
    }, [this.leftDatePanelLabel.labels[1].label]), [[vShow, this.leftShowLabelSecond]])]) : "", this.splitPanels || this.leftPickerTable !== "date-table" ? createVNode("span", {
      "class": iconBtnCls("next", "-double"),
      "onClick": () => this.nextYear("left")
    }, [createVNode(angleDoubleRight, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]) : "", this.splitPanels || this.leftPickerTable === "date-table" ? withDirectives(createVNode("span", {
      "class": iconBtnCls("next"),
      "onClick": () => this.nextMonth("left")
    }, [createVNode(angleRight, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), [[vShow, this.currentView === "date"]]) : ""]), [[vShow, this.currentView !== "time"]]), this.currentView !== "time" ? (() => {
      switch (this.leftPickerTable) {
        case "date-table":
          return createVNode(DateTable, {
            "selectionMode": "range",
            "tableDate": this.leftPanelDate,
            "disabledDate": this.disabledDate,
            "rangeState": this.rangeState,
            "modelValue": this.preSelecting.left ? [this.dates[0]] : this.dates,
            "focusedDate": this.focusedDate,
            "onChangeRange": this.handleChangeRange,
            "onPick": this.panelPickerHandlers.left
          }, null);
        default:
          return null;
      }
    })() : ""]), [[vShow, !this.isTime]]), withDirectives(createVNode("div", {
      "class": [resolveClassName("picker-panel-content"), resolveClassName("picker-panel-content-right")],
      "style": "width: 261px;"
    }, [withDirectives(createVNode("div", {
      "class": resolveClassName("date-picker-header")
    }, [this.splitPanels || this.rightPickerTable !== "date-table" ? createVNode("span", {
      "class": iconBtnCls("prev", "-double"),
      "onClick": () => this.prevYear("right")
    }, [createVNode(angleDoubleLeft, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]) : "", this.splitPanels && this.rightPickerTable === "date-table" ? withDirectives(createVNode("span", {
      "class": iconBtnCls("prev", "-double"),
      "onClick": () => this.prevMonth("right")
    }, [createVNode(angleLeft, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), [[vShow, this.currentView === "date"]]) : "", this.rightDatePanelLabel && Object.keys(this.rightDatePanelLabel).length > 0 ? createVNode("span", null, [withDirectives(createVNode("span", {
      "class": resolveClassName("date-picker-header-label"),
      "onClick": () => this.rightDatePanelLabel.labels[0].handler
    }, [this.rightDatePanelLabel.labels[0].label]), [[vShow, this.rightShowLabelFirst]]), this.rightDatePanelView === "date" ? ` ${this.rightDatePanelLabel.separator} ` : " ", withDirectives(createVNode("span", {
      "class": resolveClassName("date-picker-header-label"),
      "onClick": () => this.rightDatePanelLabel.labels[1].handler
    }, [this.rightDatePanelLabel.labels[1].label]), [[vShow, this.rightShowLabelSecond]])]) : "", this.upToNow ? (() => {
      if ((this.rangeState.selecting || this.currentView === "time") && this.upToNowEnable) {
        return createVNode("span", {
          "class": "up-to-now",
          "onClick": () => this.handleRangePick(new Date(), "upToNow")
        }, [this.t.toNow]);
      }
      return createVNode("span", {
        "class": "up-to-now disabled"
      }, [this.t.toNow]);
    })() : "", createVNode("span", {
      "class": iconBtnCls("next", "-double"),
      "onClick": () => this.nextYear("right")
    }, [createVNode(angleDoubleRight, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), this.rightPickerTable === "date-table" ? withDirectives(createVNode("span", {
      "class": iconBtnCls("next"),
      "onClick": () => this.nextMonth("right")
    }, [createVNode(angleRight, {
      "style": {
        fontSize: "20px",
        lineHeight: 1,
        verticalAlign: "text-bottom"
      }
    }, null)]), [[vShow, this.currentView === "date"]]) : ""]), [[vShow, this.currentView !== "time"]]), this.currentView !== "time" ? (() => {
      switch (this.rightPickerTable) {
        case "date-table":
          return createVNode(DateTable, {
            "selectionMode": "range",
            "tableDate": this.rightPanelDate,
            "disabledDate": this.disabledDate,
            "rangeState": this.rangeState,
            "modelValue": this.preSelecting.right ? [this.dates[this.dates.length - 1]] : this.dates,
            "focusedDate": this.focusedDate,
            "onChangeRange": this.handleChangeRange,
            "onPick": this.panelPickerHandlers.right
          }, null);
        default:
          return null;
      }
    })() : ""]), [[vShow, !this.isTime]]), this.isTime ? createVNode(TimeRangePanel, {
      "ref": "timePickerRef",
      "value": this.dates,
      "format": this.format,
      "disabledDate": this.disabledDate,
      "onPick": this.handleRangePick,
      "onPick-click": this.handlePickClick,
      "onPick-clear": this.handlePickClear,
      "onPick-success": this.handlePickSuccess,
      "onPick-toggle-time": this.handleToggleTime
    }, null) : "", this.confirm ? createVNode(Confirm, {
      "clearable": this.clearable,
      "showTime": this.showTime,
      "timeDisabled": this.timeDisabled,
      "isTime": this.isTime,
      "onPick-toggle-time": this.handleToggleTime,
      "onPick-clear": this.handlePickClear,
      "onPick-success": this.handlePickSuccess
    }, this.$slots) : ""]), shortcuts]);
  }
});
var Component$b = defineComponent({
  name: "DatePicker",
  directives: {
    clickoutside: ClickOutside
  },
  props: datePickerProps,
  emits: ["open-change", "input", "change", "update:modelValue", "clear", "shortcut-change", "pick-success"],
  slots: ["header"],
  setup(props2, {
    slots,
    emit
  }) {
    const formItem = useFormItem();
    const isRange = props2.type.includes("range");
    const emptyArray = isRange ? [null, null] : [null];
    const initialArr = isRange ? props2.value || props2.modelValue : [props2.value || props2.modelValue];
    let initialValue = isAllEmptyArr(initialArr) ? emptyArray : parseDate(props2.value || props2.modelValue, props2.type, props2.multiple, props2.format);
    let shortcut = null;
    if (props2.shortcutSelectedIndex !== -1) {
      shortcut = props2.shortcuts[props2.shortcutSelectedIndex] || null;
      if (shortcut) {
        initialValue = shortcut.value();
      }
    }
    const state = reactive({
      showClose: false,
      visible: false,
      internalValue: initialValue,
      disableClickOutSide: false,
      disableCloseUnderTransfer: false,
      selectionMode: "date",
      forceInputRerender: 1,
      isFocused: false,
      focusedDate: initialValue[0] || props2.startDate || new Date(),
      focusedTime: {
        column: 0,
        picker: 0,
        time: initialValue.map(extractTime),
        active: false
      },
      internalFocus: false,
      timeEnterMode: true,
      shortcut,
      onSelectionModeChange
    });
    onSelectionModeChange(props2.type);
    function onSelectionModeChange(_type) {
      let type = _type;
      if (_type.match(/^date/)) {
        type = "date";
      }
      state.selectionMode = ["year", "month", "date", "time"].indexOf(type) > -1 && type;
      return state.selectionMode;
    }
    const publicVModelValue = computed(() => {
      if (props2.multiple) {
        return state.internalValue.slice();
      }
      const isRange2 = props2.type.includes("range");
      let val = state.internalValue.map((date) => date instanceof Date ? new Date(date) : date || "");
      if (props2.type.match(/^time/)) {
        val = val.map((v2) => formatDate(v2, props2.type, props2.multiple, props2.format));
      }
      return isRange2 || props2.multiple ? val : val[0];
    });
    const publicStringValue = computed(() => {
      if (props2.type.match(/^time/)) {
        return publicVModelValue.value;
      }
      if (props2.multiple) {
        return formatDate(publicVModelValue.value, props2.type, props2.multiple, props2.format);
      }
      return Array.isArray(publicVModelValue.value) ? publicVModelValue.value.map((v2) => formatDate(v2, props2.type, props2.multiple, props2.format)) : formatDate(publicVModelValue.value, props2.type, props2.multiple, props2.format);
    });
    const panel = computed(() => {
      const isRange2 = props2.type === "daterange" || props2.type === "datetimerange";
      return isRange2 ? "DateRangePanel" : "DatePanel";
    });
    const opened = computed(() => props2.open === null ? state.visible : props2.open);
    const visualValue = computed(() => formatDate(state.internalValue, props2.type, props2.multiple, props2.format));
    const displayValue = computed(() => {
      var _a;
      if (((_a = state.shortcut) == null ? void 0 : _a.text) && props2.useShortcutText) {
        return state.shortcut.text;
      }
      return visualValue.value;
    });
    const isConfirm = computed(() => !!slots.trigger || props2.type === "datetime" || props2.type === "datetimerange" || props2.multiple);
    const hasHeader = computed(() => !!slots.header);
    const hasFooter = computed(() => !!slots.footer);
    const hasShortcuts = computed(() => !!slots.shortcuts);
    const hasConfirm = computed(() => !!slots.confirm);
    const fontSizeCls = computed(() => {
      let cls = "";
      if (props2.fontSize === "medium") {
        cls = "medium-font";
      } else if (props2.fontSize === "large") {
        cls = "large-font";
      }
      return cls;
    });
    const longWidthCls = computed(() => {
      let cls = "";
      if (props2.fontSize === "medium") {
        cls = "medium-width";
      } else if (props2.fontSize === "large") {
        cls = "large-width";
      }
      return cls;
    });
    const localReadonly = computed(() => {
      var _a;
      if (((_a = state.shortcut) == null ? void 0 : _a.text) && props2.useShortcutText) {
        return true;
      }
      return !props2.editable || props2.readonly;
    });
    const ownPickerProps = computed(() => props2.options);
    const allowCrossDayProp = computed(() => panel.value === "RangeTimePickerPanel" ? props2.allowCrossDay : false);
    const inputRef = ref(null);
    const inputFocus = () => {
      var _a;
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.focus();
    };
    watch(() => state.visible, (visible) => {
      var _a, _b;
      if (visible === false) {
        (_a = pickerDropdownRef.value) == null ? void 0 : _a.destoryDropdown();
      }
      (_b = pickerDropdownRef.value) == null ? void 0 : _b.updateDropdown();
      emit("open-change", visible);
    });
    const pickerDropdownRef = ref(null);
    watch(() => props2.modelValue, (modelValue) => {
      var _a;
      state.internalValue = parseDate(modelValue, props2.type, props2.multiple, props2.format);
      if (props2.withValidate) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
      }
    });
    watch(() => props2.open, (open) => {
      state.visible = open === true;
    });
    watch(() => props2.type, (type) => {
      onSelectionModeChange(type);
    });
    watch(() => publicVModelValue, (now, before) => {
      const newValue = JSON.stringify(now);
      const oldValue = JSON.stringify(before);
      const shouldEmitInput = newValue !== oldValue || typeof now !== typeof before;
      if (shouldEmitInput) {
        emit("input", now);
      }
    });
    onMounted(() => {
      if (props2.type.indexOf("date") > -1) {
        state.timeEnterMode = true;
      } else {
        state.timeEnterMode = true;
      }
      const initialValue2 = props2.modelValue;
      const parsedValue = publicVModelValue.value;
      if (typeof initialValue2 !== typeof parsedValue || JSON.stringify(initialValue2) !== JSON.stringify(parsedValue)) {
        emit("input", publicVModelValue.value);
      }
      if (props2.open !== null) {
        state.visible = props2.open;
      }
      provide(datePickerKey, {
        props: props2,
        focus: () => inputFocus()
      });
    });
    const pickerPanelRef = ref(null);
    const handleClose = (e) => {
      var _a;
      if (state.disableCloseUnderTransfer) {
        state.disableCloseUnderTransfer = false;
        return false;
      }
      if (e && e.type === "mousedown" && state.visible) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      if (state.visible) {
        const pickerPanel = (_a = pickerPanelRef == null ? void 0 : pickerPanelRef.value) == null ? void 0 : _a.$el;
        if (e && pickerPanel && pickerPanel.contains(e.target)) {
          return;
        }
        state.visible = false;
        e == null ? void 0 : e.preventDefault();
        e == null ? void 0 : e.stopPropagation();
        return;
      }
      state.isFocused = false;
      state.disableClickOutSide = false;
    };
    const handleIconClick = () => {
      var _a, _b;
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.focus();
      (_b = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _b.click();
    };
    const handleInputMouseenter = () => {
      if (props2.readonly || props2.disabled) {
        return;
      }
      if (visualValue == null ? void 0 : visualValue.value) {
        state.showClose = true;
      }
    };
    const handleInputMouseleave = (_e) => {
      state.showClose = false;
    };
    const emitChange = (type) => {
      nextTick(() => {
        var _a;
        emit("update:modelValue", publicVModelValue.value);
        emit("change", publicStringValue.value, type);
        if (props2.type.indexOf("time") < 0) {
          (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.blur();
        }
      });
    };
    const handleInputChange = (e) => {
      var _a;
      const isArrayValue = props2.type.includes("range") || props2.multiple;
      const oldValue = visualValue.value;
      const newValue = e.target.value;
      const newDate = parseDate(newValue, props2.type, props2.multiple, props2.format);
      const valueToTest = isArrayValue ? newDate : newDate[0];
      const isDisabled = (_a = props2.disabledDate) == null ? void 0 : _a.call(props2, valueToTest);
      const isValidDate = newDate.reduce((valid, date) => valid && date instanceof Date, true);
      if (newValue !== oldValue && !isDisabled && isValidDate) {
        emitChange(props2.type);
        state.internalValue = newDate;
      } else {
        state.forceInputRerender = state.forceInputRerender + 1;
      }
    };
    const handleFocus = (e) => {
      if (props2.readonly) {
        return;
      }
      state.isFocused = true;
      if (e && e.type === "focus") {
        return;
      }
      if (!props2.disabled) {
        state.visible = true;
      }
    };
    const reset2 = () => {
      var _a;
      (_a = pickerPanelRef == null ? void 0 : pickerPanelRef.value) == null ? void 0 : _a.reset();
    };
    const handleBlur = (e) => {
      var _a, _b;
      if (state.internalFocus) {
        state.internalFocus = false;
        return;
      }
      if (state.visible) {
        e.preventDefault();
        return;
      }
      state.isFocused = false;
      onSelectionModeChange(props2.type);
      state.internalValue = state.internalValue.slice();
      reset2();
      (_a = pickerPanelRef == null ? void 0 : pickerPanelRef.value) == null ? void 0 : _a.onToggleVisibility(false);
      (_b = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _b.call(formItem, "blur");
    };
    const handleKeydown = (e) => {
      const {
        keyCode
      } = e;
      if (keyCode === 9) {
        if (state.visible) {
          e.stopPropagation();
          e.preventDefault();
          if (isConfirm.value) {
            const selector = `.${resolveClassName("picker-confirm")} > *`;
            const tabbable = pickerDropdownRef.value.$el.querySelectorAll(selector);
            state.internalFocus = true;
            const element = [...tabbable][e.shiftKey ? "pop" : "shift"]();
            element.focus();
          } else {
            handleClose();
          }
        }
      }
      const arrows = [37, 38, 39, 40];
      if (!state.visible && arrows.includes(keyCode)) {
        state.visible = true;
        return;
      }
      if (keyCode === 27) {
        if (state.visible) {
          e.stopPropagation();
          handleClose();
        }
      }
      if (!arrows.includes(keyCode)) {
        return;
      }
      if (state.focusedTime.active) {
        e.preventDefault();
      }
    };
    const handleClear = () => {
      state.visible = false;
      state.internalValue = state.internalValue.map(() => null);
      emit("clear");
      emitChange(props2.type);
      reset2();
      state.showClose = false;
      state.shortcut = null;
      setTimeout(() => onSelectionModeChange(props2.type), 500);
    };
    const onPickSuccess = () => {
      var _a;
      state.visible = false;
      nextTick(() => {
        emit("pick-success");
      });
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.blur();
      reset2();
    };
    const onPick = (_dates, visible = false, type, shortcut2) => {
      let dates = _dates;
      if (props2.multiple) {
        const pickedTimeStamp = dates.getTime();
        const indexOfPickedDate = state.internalValue.findIndex((date) => date && date.getTime() === pickedTimeStamp);
        const allDates = [...state.internalValue, dates].filter(Boolean);
        const timeStamps = allDates.map((date) => date.getTime()).filter((ts, i2, arr) => arr.indexOf(ts) === i2 && i2 !== indexOfPickedDate);
        state.internalValue = timeStamps.map((ts) => new Date(ts));
      } else {
        dates = parseDate(_dates, props2.type, props2.multiple, props2.format);
        state.internalValue = Array.isArray(dates) ? dates : [dates];
      }
      if (state.internalValue[0]) {
        const [v2] = state.internalValue;
        state.focusedDate = v2;
      }
      state.focusedTime = __spreadProps(__spreadValues({}, state.focusedTime), {
        time: state.internalValue.map(extractTime)
      });
      if (!isConfirm.value) {
        onSelectionModeChange(props2.type);
        state.visible = visible;
      }
      if (type === "upToNow" && props2.type === "daterange") {
        onPickSuccess();
      }
      state.shortcut = shortcut2;
      emitChange(type);
      const shortcutIndex = props2.shortcuts.findIndex((item) => item === state.shortcut);
      emit("shortcut-change", state.shortcut, shortcutIndex);
    };
    const triggerRef = ref(null);
    const handleToggleTime = () => {
      var _a, _b;
      (_b = (_a = pickerPanelRef.value).handleToggleTime) == null ? void 0 : _b.call(_a);
    };
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      panel,
      publicStringValue,
      opened,
      visualValue,
      displayValue,
      isConfirm,
      hasHeader,
      hasFooter,
      hasShortcuts,
      hasConfirm,
      fontSizeCls,
      longWidthCls,
      localReadonly,
      allowCrossDayProp,
      ownPickerProps,
      pickerDropdownRef,
      inputRef,
      triggerRef,
      pickerPanelRef,
      handleClose,
      handleIconClick,
      handleInputMouseenter,
      handleInputMouseleave,
      handleFocus,
      handleBlur,
      handleKeydown,
      handleInputChange,
      handleClear,
      onPick,
      onPickSuccess,
      handleToggleTime
    });
  },
  render() {
    var _a, _b, _c;
    const defaultTrigger = createVNode("div", null, [createVNode("span", {
      "class": ["icon-wrapper", this.disabled ? "disabled" : ""],
      "onClick": this.handleIconClick
    }, [this.type === "time" || this.type === "timerange" ? createVNode("svg", {
      "class": "picker-icon",
      "x": "0px",
      "y": "0px",
      "viewBox": "0 0 1024 1024"
    }, [createVNode("g", {
      "id": "time"
    }, [createVNode("path", {
      "fill": "#c4c6cc",
      "d": "M512,128c51.9,0,102.2,10.1,149.5,30.2c45.7,19.3,86.8,47,122.1,82.3s63,76.4,82.3,122.1c20,47.3,30.2,97.6,30.2,149.5S886,614.3,865.9,661.6c-19.3,45.7-47,86.8-82.3,122.1s-76.4,63-122.1,82.3c-47.3,20-97.6,30.2-149.5,30.2S409.8,886.1,362.5,866c-45.7-19.3-86.8-47-122.1-82.3s-63-76.4-82.3-122.1c-20-47.3-30.2-97.6-30.2-149.5s10.1-102.2,30.2-149.5c19.3-45.7,47-86.8,82.3-122.1s76.4-63,122.1-82.3C409.8,138.1,460.1,128,512,128 M512,64C264.6,64,64,264.6,64,512s200.6,448,448,448s448-200.6,448-448S759.4,64,512,64L512,64z"
    }, null), createVNode("polygon", {
      "fill": "#c4c6cc",
      "points": "512,512 512,256 448,256 448,512 448,576 512,576 768,576 768,512"
    }, null)])]) : createVNode("svg", {
      "class": "picker-icon",
      "x": "0px",
      "y": "0px",
      "viewBox": "0 0 1024 1024"
    }, [createVNode("g", {
      "id": "date"
    }, [createVNode("path", {
      "fill": "#c4c6cc",
      "d": "M896,128h-96v64h64v112H160V192h64v-64h-96c-17.7,0-32,14.3-32,32v736c0,17.7,14.3,32,32,32h768c17.7,0,32-14.3,32-32V160C928,142.3,913.7,128,896,128z M160,864V368h704v496H160z"
    }, null), createVNode("rect", {
      "x": "416",
      "y": "128",
      "fill": "#c4c6cc",
      "width": "192",
      "height": "64"
    }, null), createVNode("rect", {
      "x": "288",
      "y": "96",
      "fill": "#c4c6cc",
      "width": "64",
      "height": "128"
    }, null), createVNode("rect", {
      "x": "672",
      "y": "96",
      "fill": "#c4c6cc",
      "width": "64",
      "height": "128"
    }, null), createVNode("polygon", {
      "fill": "#c4c6cc",
      "points": "403.7,514.4 557.1,514.4 557.1,515.3 420.1,765.5 483.5,765.5 620.3,504.3 620.3,466.5 403.7,466.5"
    }, null)])])]), createVNode("input", {
      "type": "text",
      "class": [resolveClassName("date-picker-editor"), this.readonly ? "readonly" : "", this.fontSizeCls, this.behavior === "simplicity" ? "only-bottom-border" : ""],
      "ref": "inputRef",
      "key": this.forceInputRerender,
      "readonly": this.localReadonly,
      "disabled": this.disabled,
      "placeholder": this.placeholder,
      "value": this.displayValue,
      "onFocus": this.handleFocus,
      "onClick": this.handleFocus,
      "onBlur": this.handleBlur,
      "onKeydown": this.handleKeydown,
      "onChange": this.handleInputChange
    }, null), this.clearable && this.showClose ? createVNode(close$1, {
      "onClick": this.handleClear,
      "class": "clear-action"
    }, null) : ""]);
    const shortcutsSlot = this.hasShortcuts ? {
      shortcuts: () => {
        var _a2, _b2;
        return ((_b2 = (_a2 = this.$slots).shortcuts) == null ? void 0 : _b2.call(_a2, {
          change: this.onPick
        })) || null;
      }
    } : {};
    const confirmSlot = this.hasConfirm ? {
      confirm: this.$slots.confirm
    } : {};
    const slots = __spreadValues(__spreadValues({}, shortcutsSlot), confirmSlot);
    return withDirectives(createVNode("div", {
      "class": [resolveClassName("date-picker"), this.type === "datetimerange" ? "long" : "", this.longWidthCls]
    }, [createVNode("div", {
      "ref": "triggerRef",
      "class": resolveClassName("date-picker-rel"),
      "onMouseenter": this.handleInputMouseenter,
      "onMouseleave": this.handleInputMouseleave
    }, [(_c = (_b = (_a = this.$slots).trigger) == null ? void 0 : _b.call(_a)) != null ? _c : defaultTrigger]), createVNode(Teleport, {
      "to": "body",
      "disabled": !this.appendToBody
    }, {
      default: () => [createVNode(Transition, {
        "name": resolveClassName("fade-down-transition")
      }, {
        default: () => [withDirectives(createVNode(PickerDropdown, {
          "class": [this.appendToBody ? resolveClassName("date-picker-transfer") : ""],
          "ref": "pickerDropdownRef",
          "triggerRef": this.triggerRef,
          "placement": this.placement,
          "extPopoverCls": this.extPopoverCls,
          "appendToBody": this.appendToBody
        }, {
          default: () => {
            var _a2, _b2, _c2, _d, _e, _f;
            return [this.hasHeader ? createVNode("div", {
              "class": [resolveClassName("date-picker-top-wrapper"), this.headerSlotCls]
            }, [(_c2 = (_b2 = (_a2 = this.$slots).header) == null ? void 0 : _b2.call(_a2)) != null ? _c2 : null]) : null, this.panel === "DateRangePanel" ? createVNode(DateRangePanel, {
              "ref": "pickerPanelRef",
              "type": this.type,
              "showTime": this.type === "datetime" || this.type === "datetimerange",
              "confirm": this.isConfirm,
              "shortcuts": this.shortcuts,
              "shortcutClose": this.shortcutClose,
              "modelValue": this.internalValue,
              "selectionMode": this.selectionMode,
              "startDate": this.startDate,
              "disabledDate": this.disabledDate,
              "focusedDate": this.focusedDate,
              "timePickerOptions": this.timePickerOptions,
              "onPick": this.onPick,
              "onPick-clear": this.handleClear,
              "onPick-success": this.onPickSuccess,
              "onSelection-mode-change": this.onSelectionModeChange
            }, slots) : createVNode(DatePanel, {
              "ref": "pickerPanelRef",
              "clearable": this.clearable,
              "showTime": this.type === "datetime" || this.type === "datetimerange",
              "confirm": this.isConfirm,
              "shortcuts": this.shortcuts,
              "multiple": this.multiple,
              "shortcutClose": this.shortcutClose,
              "selectionMode": this.selectionMode,
              "modelValue": this.internalValue,
              "startDate": this.startDate,
              "disabledDate": this.disabledDate,
              "focusedDate": this.focusedDate,
              "timePickerOptions": this.timePickerOptions,
              "onPick": this.onPick,
              "onPick-clear": this.handleClear,
              "onPick-success": this.onPickSuccess,
              "onSelection-mode-change": this.onSelectionModeChange
            }, slots), this.hasFooter ? createVNode("div", {
              "class": [resolveClassName("date-picker-footer-wrapper"), this.footerSlotCls]
            }, [(_f = (_e = (_d = this.$slots).footer) == null ? void 0 : _e.call(_d)) != null ? _f : null]) : null];
          }
        }), [[vShow, this.opened]])]
      })]
    })]), [[resolveDirective("clickoutside"), this.handleClose]]);
  }
});
var TimePicker = defineComponent({
  name: "TimePicker",
  directives: {
    clickoutside: ClickOutside
  },
  props: __spreadValues(__spreadValues(__spreadValues({}, datePickerProps), timePickerProps), timePanelProps),
  emits: ["open-change", "input", "change", "update:modelValue", "clear", "shortcut-change", "pick-success"],
  slots: ["header"],
  setup(props2, {
    slots,
    emit
  }) {
    const formItem = useFormItem();
    const isRange = props2.type.includes("range");
    const emptyArray = isRange ? [null, null] : [null];
    let initialValue = isAllEmptyArr((isRange ? props2.modelValue : [props2.modelValue]) || []) ? emptyArray : parseDate(props2.modelValue, props2.type, props2.multiple, props2.format);
    let shortcut = null;
    if (props2.shortcutSelectedIndex !== -1) {
      shortcut = props2.shortcuts[props2.shortcutSelectedIndex] || null;
      if (shortcut) {
        initialValue = shortcut.value();
      }
    }
    const state = reactive({
      showClose: false,
      visible: false,
      internalValue: initialValue,
      disableClickOutSide: false,
      disableCloseUnderTransfer: false,
      selectionMode: "date",
      forceInputRerender: 1,
      isFocused: false,
      focusedDate: initialValue[0] || props2.startDate || new Date(),
      focusedTime: {
        column: 0,
        picker: 0,
        time: initialValue.map(extractTime),
        active: false
      },
      internalFocus: false,
      timeEnterMode: true,
      shortcut,
      onSelectionModeChange
    });
    function onSelectionModeChange(_type) {
      let type = _type;
      if (_type.match(/^date/)) {
        type = "date";
      }
      state.selectionMode = ["year", "month", "date", "time"].indexOf(type) > -1 && type;
      return state.selectionMode;
    }
    const publicVModelValue = computed(() => {
      if (props2.multiple) {
        return state.internalValue.slice();
      }
      const isRange2 = props2.type.includes("range");
      let val = state.internalValue.map((date) => date instanceof Date ? new Date(date) : date || "");
      if (props2.type.match(/^time/)) {
        val = val.map((v2) => formatDate(v2, props2.type, props2.multiple, props2.format));
      }
      return isRange2 || props2.multiple ? val : val[0];
    });
    const publicStringValue = computed(() => {
      if (props2.type.match(/^time/)) {
        return publicVModelValue.value;
      }
      if (props2.multiple) {
        return formatDate(publicVModelValue.value, props2.type, props2.multiple, props2.format);
      }
      return Array.isArray(publicVModelValue.value) ? publicVModelValue.value.map((v2) => formatDate(v2, props2.type, props2.multiple, props2.format)) : formatDate(publicVModelValue.value, props2.type, props2.multiple, props2.format);
    });
    const panel = computed(() => {
      const isRange2 = props2.type === "timerange";
      return isRange2 ? "RangeTimePickerPanel" : "TimePickerPanel";
    });
    const opened = computed(() => props2.open === null ? state.visible : props2.open);
    const visualValue = computed(() => formatDate(state.internalValue, props2.type, props2.multiple, props2.format));
    const displayValue = computed(() => {
      var _a;
      if (((_a = state.shortcut) == null ? void 0 : _a.text) && props2.useShortcutText) {
        return state.shortcut.text;
      }
      return visualValue.value;
    });
    const isConfirm = computed(() => !!slots.trigger || props2.type === "datetime" || props2.type === "datetimerange" || props2.multiple);
    const hasHeader = computed(() => !!slots.header);
    const hasFooter = computed(() => !!slots.footer);
    const hasShortcuts = computed(() => !!slots.shortcuts);
    const fontSizeCls = computed(() => {
      let cls = "";
      if (props2.fontSize === "medium") {
        cls = "medium-font";
      } else if (props2.fontSize === "large") {
        cls = "large-font";
      }
      return cls;
    });
    const longWidthCls = computed(() => {
      let cls = "";
      if (props2.fontSize === "medium") {
        cls = "medium-width";
      } else if (props2.fontSize === "large") {
        cls = "large-width";
      }
      return cls;
    });
    const localReadonly = computed(() => {
      var _a;
      if (((_a = state.shortcut) == null ? void 0 : _a.text) && props2.useShortcutText) {
        return true;
      }
      return !props2.editable || props2.readonly;
    });
    const ownPickerProps = computed(() => ({
      disabledHours: props2.disabledHours,
      disabledMinutes: props2.disabledMinutes,
      disabledSeconds: props2.disabledSeconds,
      hideDisabledOptions: props2.hideDisabledOptions
    }));
    const allowCrossDayProp = computed(() => panel.value === "RangeTimePickerPanel" ? props2.allowCrossDay : false);
    const inputRef = ref(null);
    const inputFocus = () => {
      var _a;
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.focus();
    };
    const {
      proxy
    } = getCurrentInstance();
    const pickerDropdownRef = ref(null);
    watch(() => state.visible, (visible) => {
      var _a, _b;
      if (visible) {
        (_b = (_a = pickerDropdownRef.value) == null ? void 0 : _a.forceUpdate) == null ? void 0 : _b.call(_a);
        nextTick(() => {
          var _a2, _b2;
          (_b2 = (_a2 = proxy.pickerPanelRef) == null ? void 0 : _a2.timeSpinnerRef) == null ? void 0 : _b2.updateScroll();
        });
      }
    });
    watch(() => props2.modelValue, (modelValue) => {
      var _a;
      state.internalValue = parseDate(modelValue, props2.type, props2.multiple, props2.format);
      if (props2.withValidate) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
      }
    });
    watch(() => props2.open, (open) => {
      state.visible = open === true;
    });
    watch(() => props2.type, (type) => {
      onSelectionModeChange(type);
    });
    watch(() => publicVModelValue, (now, before) => {
      const newValue = JSON.stringify(now);
      const oldValue = JSON.stringify(before);
      const shouldEmitInput = newValue !== oldValue || typeof now !== typeof before;
      if (shouldEmitInput) {
        emit("input", now);
      }
    });
    onMounted(() => {
      if (props2.type.indexOf("date") > -1) {
        state.timeEnterMode = true;
      } else {
        state.timeEnterMode = true;
      }
      const initialValue2 = props2.modelValue;
      const parsedValue = publicVModelValue.value;
      if (typeof initialValue2 !== typeof parsedValue || JSON.stringify(initialValue2) !== JSON.stringify(parsedValue)) {
        emit("input", publicVModelValue.value);
      }
      if (props2.open !== null) {
        state.visible = props2.open;
      }
      provide(datePickerKey, {
        props: props2,
        focus: () => inputFocus()
      });
    });
    const pickerPanelRef = ref(null);
    const handleClose = (e) => {
      var _a;
      if (state.disableCloseUnderTransfer) {
        state.disableCloseUnderTransfer = false;
        return false;
      }
      if (e && e.type === "mousedown" && state.visible) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }
      if (state.visible) {
        const pickerPanel = (_a = pickerPanelRef == null ? void 0 : pickerPanelRef.value) == null ? void 0 : _a.$el;
        if (e && pickerPanel && pickerPanel.contains(e.target)) {
          return;
        }
        state.visible = false;
        e == null ? void 0 : e.preventDefault();
        e == null ? void 0 : e.stopPropagation();
        return;
      }
      state.isFocused = false;
      state.disableClickOutSide = false;
    };
    const handleIconClick = () => {
      var _a, _b;
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.focus();
      (_b = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _b.click();
    };
    const handleInputMouseenter = () => {
      if (props2.readonly || props2.disabled) {
        return;
      }
      if (visualValue == null ? void 0 : visualValue.value) {
        state.showClose = true;
      }
    };
    const handleInputMouseleave = (_e) => {
      state.showClose = false;
    };
    const emitChange = (type) => {
      nextTick(() => {
        var _a;
        emit("update:modelValue", publicVModelValue.value);
        emit("change", publicStringValue.value, type);
        if (props2.type.indexOf("time") < 0) {
          (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.blur();
        }
      });
    };
    const handleInputChange = (e) => {
      var _a;
      const isArrayValue = props2.type.includes("range") || props2.multiple;
      const oldValue = visualValue.value;
      const newValue = e.target.value;
      const newDate = parseDate(newValue, props2.type, props2.multiple, props2.format);
      const valueToTest = isArrayValue ? newDate : newDate[0];
      const isDisabled = (_a = props2.disabledDate) == null ? void 0 : _a.call(props2, valueToTest);
      const isValidDate = newDate.reduce((valid, date) => valid && date instanceof Date, true);
      if (newValue !== oldValue && !isDisabled && isValidDate) {
        emitChange(props2.type);
        state.internalValue = newDate;
      } else {
        state.forceInputRerender = state.forceInputRerender + 1;
      }
    };
    const handleFocus = (e) => {
      if (props2.readonly) {
        return;
      }
      state.isFocused = true;
      if (e && e.type === "focus") {
        return;
      }
      if (!props2.disabled) {
        state.visible = true;
      }
    };
    const reset2 = () => {
      var _a, _b;
      (_b = (_a = pickerPanelRef == null ? void 0 : pickerPanelRef.value) == null ? void 0 : _a.reset) == null ? void 0 : _b.call(_a);
    };
    const handleBlur = (e) => {
      var _a, _b;
      if (state.internalFocus) {
        state.internalFocus = false;
        return;
      }
      if (state.visible) {
        e.preventDefault();
        return;
      }
      state.isFocused = false;
      onSelectionModeChange(props2.type);
      state.internalValue = state.internalValue.slice();
      reset2();
      (_a = pickerPanelRef == null ? void 0 : pickerPanelRef.value) == null ? void 0 : _a.onToggleVisibility(false);
      (_b = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _b.call(formItem, "blur");
    };
    const handleKeydown = (e) => {
      const {
        keyCode
      } = e;
      if (keyCode === 9) {
        if (state.visible) {
          e.stopPropagation();
          e.preventDefault();
          if (isConfirm.value) {
            const selector = ".lesscode-bk-picker-confirm > *";
            const tabbable = pickerDropdownRef.value.$el.querySelectorAll(selector);
            state.internalFocus = true;
            const element = [...tabbable][e.shiftKey ? "pop" : "shift"]();
            element.focus();
          } else {
            handleClose();
          }
        }
      }
      const arrows = [37, 38, 39, 40];
      if (!state.visible && arrows.includes(keyCode)) {
        state.visible = true;
        return;
      }
      if (keyCode === 27) {
        if (state.visible) {
          e.stopPropagation();
          handleClose();
        }
      }
      if (!arrows.includes(keyCode)) {
        return;
      }
      if (state.focusedTime.active) {
        e.preventDefault();
      }
    };
    const handleClear = () => {
      state.visible = false;
      state.internalValue = state.internalValue.map(() => null);
      emit("clear");
      emitChange(props2.type);
      reset2();
      state.showClose = false;
      state.shortcut = null;
      setTimeout(() => onSelectionModeChange(props2.type), 500);
    };
    const handleTransferClick = () => {
      if (props2.appendToBody) {
        state.disableCloseUnderTransfer = true;
      }
    };
    const onPickSuccess = () => {
      var _a;
      state.visible = false;
      nextTick(() => {
        emit("pick-success");
      });
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.blur();
      reset2();
    };
    const onPick = (_dates, visible = false, type, shortcut2) => {
      let dates = _dates;
      if (props2.multiple) {
        const pickedTimeStamp = dates.getTime();
        const indexOfPickedDate = state.internalValue.findIndex((date) => date && date.getTime() === pickedTimeStamp);
        const allDates = [...state.internalValue, dates].filter(Boolean);
        const timeStamps = allDates.map((date) => date.getTime()).filter((ts, i2, arr) => arr.indexOf(ts) === i2 && i2 !== indexOfPickedDate);
        state.internalValue = timeStamps.map((ts) => new Date(ts));
      } else {
        dates = parseDate(_dates, props2.type, props2.multiple, props2.format);
        state.internalValue = Array.isArray(dates) ? dates : [dates];
      }
      if (state.internalValue[0]) {
        const [v2] = state.internalValue;
        state.focusedDate = v2;
      }
      state.focusedTime = __spreadProps(__spreadValues({}, state.focusedTime), {
        time: state.internalValue.map(extractTime)
      });
      if (!isConfirm.value) {
        onSelectionModeChange(props2.type);
        state.visible = visible;
      }
      if (type === "upToNow" && props2.type === "daterange") {
        onPickSuccess();
      }
      state.shortcut = shortcut2;
      emitChange(type);
      const shortcutIndex = props2.shortcuts.findIndex((item) => item === state.shortcut);
      emit("shortcut-change", state.shortcut, shortcutIndex);
    };
    const triggerRef = ref(null);
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      panel,
      publicStringValue,
      opened,
      visualValue,
      displayValue,
      isConfirm,
      hasHeader,
      hasFooter,
      hasShortcuts,
      fontSizeCls,
      longWidthCls,
      localReadonly,
      allowCrossDayProp,
      ownPickerProps,
      pickerDropdownRef,
      inputRef,
      triggerRef,
      pickerPanelRef,
      handleClose,
      handleIconClick,
      handleInputMouseenter,
      handleInputMouseleave,
      handleFocus,
      handleBlur,
      handleKeydown,
      handleInputChange,
      handleClear,
      handleTransferClick,
      onPick,
      onPickSuccess
    });
  },
  render() {
    var _a, _b, _c;
    const defaultTrigger = createVNode("div", null, [createVNode("span", {
      "class": ["icon-wrapper", this.disabled ? "disabled" : ""],
      "onClick": this.handleIconClick
    }, [this.type === "time" || this.type === "timerange" ? createVNode("svg", {
      "class": "picker-icon",
      "x": "0px",
      "y": "0px",
      "viewBox": "0 0 1024 1024"
    }, [createVNode("g", {
      "id": "time"
    }, [createVNode("path", {
      "fill": "#c4c6cc",
      "d": "M512,128c51.9,0,102.2,10.1,149.5,30.2c45.7,19.3,86.8,47,122.1,82.3s63,76.4,82.3,122.1c20,47.3,30.2,97.6,30.2,149.5S886,614.3,865.9,661.6c-19.3,45.7-47,86.8-82.3,122.1s-76.4,63-122.1,82.3c-47.3,20-97.6,30.2-149.5,30.2S409.8,886.1,362.5,866c-45.7-19.3-86.8-47-122.1-82.3s-63-76.4-82.3-122.1c-20-47.3-30.2-97.6-30.2-149.5s10.1-102.2,30.2-149.5c19.3-45.7,47-86.8,82.3-122.1s76.4-63,122.1-82.3C409.8,138.1,460.1,128,512,128 M512,64C264.6,64,64,264.6,64,512s200.6,448,448,448s448-200.6,448-448S759.4,64,512,64L512,64z"
    }, null), createVNode("polygon", {
      "fill": "#c4c6cc",
      "points": "512,512 512,256 448,256 448,512 448,576 512,576 768,576 768,512"
    }, null)])]) : createVNode("svg", {
      "class": "picker-icon",
      "x": "0px",
      "y": "0px",
      "viewBox": "0 0 1024 1024"
    }, [createVNode("g", {
      "id": "date"
    }, [createVNode("path", {
      "fill": "#c4c6cc",
      "d": "M896,128h-96v64h64v112H160V192h64v-64h-96c-17.7,0-32,14.3-32,32v736c0,17.7,14.3,32,32,32h768c17.7,0,32-14.3,32-32V160C928,142.3,913.7,128,896,128z M160,864V368h704v496H160z"
    }, null), createVNode("rect", {
      "x": "416",
      "y": "128",
      "fill": "#c4c6cc",
      "width": "192",
      "height": "64"
    }, null), createVNode("rect", {
      "x": "288",
      "y": "96",
      "fill": "#c4c6cc",
      "width": "64",
      "height": "128"
    }, null), createVNode("rect", {
      "x": "672",
      "y": "96",
      "fill": "#c4c6cc",
      "width": "64",
      "height": "128"
    }, null), createVNode("polygon", {
      "fill": "#c4c6cc",
      "points": "403.7,514.4 557.1,514.4 557.1,515.3 420.1,765.5 483.5,765.5 620.3,504.3 620.3,466.5 403.7,466.5"
    }, null)])])]), createVNode("input", {
      "type": "text",
      "class": [resolveClassName("date-picker-editor"), this.readonly ? "readonly" : "", this.fontSizeCls, this.behavior === "simplicity" ? "only-bottom-border" : ""],
      "ref": "inputRef",
      "key": this.forceInputRerender,
      "readonly": this.localReadonly,
      "disabled": this.disabled,
      "placeholder": this.placeholder,
      "value": this.displayValue,
      "onFocus": this.handleFocus,
      "onClick": this.handleFocus,
      "onBlur": this.handleBlur,
      "onKeydown": this.handleKeydown,
      "onChange": this.handleInputChange
    }, null), this.clearable && this.showClose ? createVNode(close$1, {
      "onClick": this.handleClear,
      "class": "clear-action"
    }, null) : ""]);
    const shortcutsSlot = this.hasShortcuts ? {
      shortcuts: () => {
        var _a2, _b2;
        return ((_b2 = (_a2 = this.$slots).shortcuts) == null ? void 0 : _b2.call(_a2)) || null;
      }
    } : {};
    return withDirectives(createVNode("div", {
      "class": [resolveClassName("date-picker"), this.type === "datetimerange" ? "long" : "", this.longWidthCls]
    }, [createVNode("div", {
      "ref": "triggerRef",
      "class": resolveClassName("date-picker-rel"),
      "onMouseenter": this.handleInputMouseenter,
      "onMouseleave": this.handleInputMouseleave
    }, [(_c = (_b = (_a = this.$slots).trigger) == null ? void 0 : _b.call(_a)) != null ? _c : defaultTrigger]), createVNode(Teleport, {
      "to": "body",
      "disabled": !this.appendToBody
    }, {
      default: () => [createVNode(Transition, {
        "name": "lesscode-bk-fade-down-transition"
      }, {
        default: () => [withDirectives(createVNode(PickerDropdown, {
          "class": [this.appendToBody ? resolveClassName("date-picker-transfer") : ""],
          "ref": "pickerDropdownRef",
          "triggerRef": this.triggerRef,
          "placement": this.placement,
          "extPopoverCls": this.extPopoverCls,
          "appendToBody": this.appendToBody,
          "onClick": this.handleTransferClick
        }, {
          default: () => {
            var _a2, _b2, _c2, _d, _e, _f;
            return [this.hasHeader ? createVNode("div", {
              "class": [resolveClassName("date-picker-top-wrapper"), this.headerSlotCls]
            }, [(_c2 = (_b2 = (_a2 = this.$slots).header) == null ? void 0 : _b2.call(_a2)) != null ? _c2 : null]) : null, this.panel === "RangeTimePickerPanel" ? createVNode(TimeRangePanel, {
              "ref": "pickerPanelRef",
              "clearable": this.clearable,
              "shortcuts": this.shortcuts,
              "multiple": this.multiple,
              "shortcutClose": this.shortcutClose,
              "value": this.internalValue,
              "startDate": this.startDate,
              "disabledDate": this.disabledDate,
              "onPick": this.onPick,
              "onPick-clear": this.handleClear,
              "onPick-success": this.onPickSuccess,
              "disabledHours": this.ownPickerProps.disabledHours,
              "disabledMinutes": this.ownPickerProps.disabledMinutes,
              "disabledSeconds": this.ownPickerProps.disabledSeconds
            }, shortcutsSlot) : createVNode(TimePanel, {
              "ref": "pickerPanelRef",
              "clearable": this.clearable,
              "confirm": this.isConfirm,
              "shortcuts": this.shortcuts,
              "multiple": this.multiple,
              "shortcutClose": this.shortcutClose,
              "value": this.internalValue,
              "startDate": this.startDate,
              "disabledDate": this.disabledDate,
              "onPick": this.onPick,
              "onPick-clear": this.handleClear,
              "onPick-success": this.onPickSuccess,
              "disabledHours": this.ownPickerProps.disabledHours,
              "disabledMinutes": this.ownPickerProps.disabledMinutes,
              "disabledSeconds": this.ownPickerProps.disabledSeconds
            }, shortcutsSlot), this.hasFooter ? createVNode("div", {
              "class": [resolveClassName("date-picker-footer-wrapper"), this.footerSlotCls]
            }, [(_f = (_e = (_d = this.$slots).footer) == null ? void 0 : _e.call(_d)) != null ? _f : null]) : null];
          }
        }), [[vShow, this.opened]])]
      })]
    })]), [[resolveDirective("clickoutside"), this.handleClose]]);
  }
});
const BkDatePicker = withInstall(Component$b);
var ArrayType = /* @__PURE__ */ ((ArrayType2) => {
  ArrayType2["OBJECT_ARRAY"] = "objectArray";
  ArrayType2["BASE_ARRAY"] = "baseArray";
  ArrayType2["NOT_ARRAY"] = "notArray";
  return ArrayType2;
})(ArrayType || {});
const transferProps = {
  title: PropTypes.arrayOf(PropTypes.string).def([]),
  extCls: PropTypes.string.def(""),
  searchPlaceholder: PropTypes.string.def(""),
  settingKey: PropTypes.string.def("id"),
  displayKey: PropTypes.string.def("value"),
  sortKey: PropTypes.string.def("value"),
  showOverflowTips: PropTypes.bool.def(false),
  searchable: PropTypes.bool.def(false),
  sortable: PropTypes.bool.def(false),
  sourceList: PropTypes.arrayOf(PropTypes.any).def([]),
  targetList: PropTypes.arrayOf(PropTypes.any).def([]),
  emptyContent: PropTypes.arrayOf(PropTypes.string).def([]),
  multiple: PropTypes.bool.def(false)
};
function _isSlot$1(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
function useTransferData(sourceData, targetList, settingCode) {
  const selectList = ref([]);
  const selectedList = ref([]);
  const transformData = (isChange = false) => {
    if (isChange) {
      selectList.value = [];
      selectedList.value = [];
    }
    sourceData.value.forEach((s2) => {
      const keyId = s2[settingCode.value];
      if (targetList.value.includes(keyId)) {
        selectedList.value.push(s2);
      } else {
        selectList.value.push(s2);
      }
    });
  };
  transformData();
  watch(() => [sourceData, targetList, settingCode], () => {
    transformData(true);
  }, {
    deep: true
  });
  return {
    selectList,
    selectedList
  };
}
function useSelectListSearch(selectList, displayCode) {
  const selectSearchQuery = ref("");
  const selectListSearch = computed(() => {
    return selectList.value.filter((select2) => {
      const val = select2[displayCode.value];
      if (val instanceof Object)
        return false;
      return val.toString().includes(selectSearchQuery.value);
    });
  });
  return {
    selectSearchQuery,
    selectListSearch
  };
}
var Component$a = defineComponent({
  name: "Transfer",
  props: transferProps,
  emits: ["change", "update:targetList"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("transfer");
    const multipleSelectAllValue = ref({
      source: false,
      target: false
    });
    const multipleSelectList = ref({
      source: [],
      target: []
    });
    const sourceListType = computed(() => {
      if (Array.isArray(props2.sourceList)) {
        const isObjectArray = props2.sourceList.every((s2) => s2.toString().includes("[object Object]"));
        return isObjectArray ? ArrayType.OBJECT_ARRAY : ArrayType.BASE_ARRAY;
      }
      return ArrayType.NOT_ARRAY;
    });
    const settingCode = computed(() => sourceListType.value === ArrayType.BASE_ARRAY ? "value" : props2.settingKey);
    const displayCode = computed(() => sourceListType.value === ArrayType.BASE_ARRAY ? "value" : props2.displayKey);
    const sortCode = computed(() => props2.sortKey || displayCode.value);
    const sourceData = computed(() => {
      switch (sourceListType.value) {
        case ArrayType.BASE_ARRAY:
          return [...new Set(props2.sourceList)].map((s2) => ({
            value: s2
          }));
        case ArrayType.OBJECT_ARRAY:
          return [...props2.sourceList];
        default:
          return [];
      }
    });
    const {
      targetList
    } = toRefs(props2);
    const {
      selectList,
      selectedList
    } = useTransferData(sourceData, targetList, settingCode);
    const {
      selectSearchQuery,
      selectListSearch
    } = useSelectListSearch(selectList, displayCode);
    const selectListSort = computed(() => {
      return [...selectListSearch.value].sort((a2, b2) => {
        const va = a2[sortCode.value];
        const vb = b2[sortCode.value];
        return va > vb ? 1 : -1;
      });
    });
    const selectedListSort = computed(() => {
      return [...selectedList.value].sort((a2, b2) => {
        const va = a2[sortCode.value];
        const vb = b2[sortCode.value];
        return va > vb ? 1 : -1;
      });
    });
    watch(() => [selectList, selectedList], () => {
      if (!props2.multiple) {
        handleEmitUpdateTargetList();
      }
    }, {
      deep: true
    });
    const handleCheckAllItemSelect = (list, source) => {
      const itemKey = settingCode.value;
      return list.some((val) => val[itemKey] === source[itemKey]) && source.disabled;
    };
    const allToRight = () => {
      selectList.value = [...sourceData.value.filter((source) => {
        return handleCheckAllItemSelect(selectList.value, source);
      })];
      selectedList.value = [...sourceData.value.filter((source) => {
        return !handleCheckAllItemSelect(selectList.value, source);
      })];
      handleEmitUpdateTargetList();
    };
    const allToLeft = () => {
      selectList.value = [...sourceData.value.filter((source) => {
        return !handleCheckAllItemSelect(selectedList.value, source);
      })];
      selectedList.value = [...sourceData.value.filter((source) => {
        return handleCheckAllItemSelect(selectedList.value, source);
      })];
      handleEmitUpdateTargetList();
    };
    const handleItemClick = (item, isLeft) => {
      if (item.disabled)
        return;
      const itemKey = item[settingCode.value];
      const from = isLeft ? selectList : selectedList;
      const to = isLeft ? selectedList : selectList;
      const index2 = from.value.findIndex((item2) => item2[settingCode.value] === itemKey);
      to.value.push(...from.value.splice(index2, 1));
      handleEmitUpdateTargetList();
    };
    const handleEmitUpdateTargetList = () => {
      const restList = selectList.value.map((item) => item[settingCode.value]);
      const targetList2 = selectedList.value.map((item) => item[settingCode.value]);
      emit("update:targetList", targetList2);
      emit("change", sourceListType.value === ArrayType.BASE_ARRAY ? restList : selectList.value.map((v2) => toRaw(v2)), sourceListType.value === ArrayType.BASE_ARRAY ? targetList2 : selectedList.value.map((v2) => toRaw(v2)), targetList2);
    };
    const handleItemChecked = (dirct) => {
      const target = dirct === "source" ? selectList : selectedList;
      multipleSelectAllValue.value[dirct] = multipleSelectList.value[dirct].length === target.value.length;
    };
    const handleAllChecked = (value, dirct) => {
      const target = dirct === "source" ? selectList : selectedList;
      multipleSelectList.value[dirct] = value ? target.value.map((item) => item[settingCode.value]) : [];
    };
    const handleMultipleChange = (dirct) => {
      const isLeft = dirct === "left";
      const from = isLeft ? selectList : selectedList;
      const to = isLeft ? selectedList : selectList;
      const checkeds = multipleSelectList.value[isLeft ? "source" : "target"];
      const items = from.value.filter((val) => checkeds.includes(val[settingCode.value]));
      from.value = from.value.filter((val) => !checkeds.includes(val[settingCode.value]));
      to.value.push(...items);
      multipleSelectList.value[isLeft ? "source" : "target"] = [];
      handleEmitUpdateTargetList();
    };
    return {
      selectSearchQuery,
      selectListSearch,
      selectedList,
      selectListSort,
      selectedListSort,
      settingCode,
      displayCode,
      allToRight,
      allToLeft,
      handleItemClick,
      t: t2,
      handleAllChecked,
      multipleSelectAllValue,
      multipleSelectList,
      handleMultipleChange,
      handleItemChecked
    };
  },
  render() {
    const {
      multiple
    } = this.$props;
    const leftList = this.sortable ? this.selectListSort : this.selectListSearch;
    const rightList = this.sortable ? this.selectedListSort : this.selectedList;
    const getHeaderHtml = (dirct) => {
      var _a, _b;
      const isLeft = dirct === "left-header";
      const selectField = isLeft ? "source" : "target";
      const titleText = isLeft ? `${(_a = this.title[0]) != null ? _a : this.t.sourceList}` : `${(_b = this.title[1]) != null ? _b : this.t.targetList}`;
      const isDisabled = isLeft ? !leftList.length : !rightList.length;
      const isIndeterminate = !!this.multipleSelectList[selectField].length && !this.multipleSelectAllValue[selectField];
      const selectCount = this.multipleSelectList[selectField].length;
      const headerClick = () => {
        if (isDisabled)
          return;
        isLeft ? this.allToRight() : this.allToLeft();
      };
      return this.$slots[dirct] ? createVNode("div", {
        "class": "slot-header"
      }, [this.$slots[dirct]()]) : createVNode("div", {
        "class": "header"
      }, [this.multiple ? createVNode(BkCheckbox, {
        "class": "header-checkbox",
        "label": titleText,
        "modelValue": this.multipleSelectAllValue[selectField],
        "onUpdate:modelValue": ($event) => this.multipleSelectAllValue[selectField] = $event,
        "indeterminate": isIndeterminate,
        "onChange": (val) => this.handleAllChecked(val, selectField)
      }, null) : createVNode(Fragment, null, [`${titleText}\uFF08${isLeft ? leftList.length : rightList.length}\uFF09`]), this.multiple ? createVNode("div", {
        "class": "select-total-count"
      }, [createVNode("span", {
        "class": "select-count"
      }, [selectCount]), createVNode("span", {
        "class": "count-delimiter"
      }, [createTextVNode("/")]), createVNode("span", {
        "class": "total-count"
      }, [isLeft ? leftList.length : rightList.length])]) : createVNode("span", {
        "class": {
          "select-all": true,
          disabled: isDisabled
        },
        "onClick": () => headerClick()
      }, [isLeft ? this.t.selectAll : this.t.removeAll])]);
    };
    const getEmptyHtml = (dirct) => {
      var _a;
      const isLeft = dirct === "left-empty-content";
      const emptyText = (_a = isLeft ? this.emptyContent[0] : this.emptyContent[1]) != null ? _a : isLeft ? this.t.noData : this.t.noSelected;
      return this.$slots[dirct] ? createVNode("div", null, [this.$slots[dirct]()]) : createVNode("div", {
        "class": "empty"
      }, [emptyText]);
    };
    const getDefaultListHtml = (item, isLeft = true) => {
      return createVNode("div", {
        "class": ["item-content", {
          "is-disabled": item.disabled
        }]
      }, [createVNode("span", {
        "class": "content-text",
        "title": item[this.displayCode]
      }, [item[this.displayCode]]), !multiple && createVNode("span", {
        "class": "icon-wrapper"
      }, [isLeft ? createVNode(arrowsRight, {
        "class": "lesscode-bk-icon icon-move"
      }, null) : createVNode(error, {
        "class": "lesscode-bk-icon icon-delete"
      }, null)])]);
    };
    const getListContentHtml = (dirct) => {
      let _slot;
      const isLeft = dirct === "left";
      const selectField = dirct === "left" ? "source" : "target";
      const list = isLeft ? leftList : rightList;
      const slotName = isLeft ? "source-option" : "target-option";
      const emptySlotName = isLeft ? "left-empty-content" : "right-empty-content";
      const contentMode = multiple ? createVNode(BkCheckboxGroup, {
        "class": "content is-flex",
        "modelValue": this.multipleSelectList[selectField],
        "onUpdate:modelValue": ($event) => this.multipleSelectList[selectField] = $event,
        "onChange": () => this.handleItemChecked(selectField)
      }, _isSlot$1(_slot = list.map((item) => createVNode("div", null, [createVNode(BkCheckbox, {
        "class": "checkbox-item",
        "label": item[this.settingCode]
      }, {
        default: () => {
          var _a, _b, _c;
          return [(_c = (_b = (_a = this.$slots)[slotName]) == null ? void 0 : _b.call(_a, item)) != null ? _c : getDefaultListHtml(item, isLeft)];
        }
      })]))) ? _slot : {
        default: () => [_slot]
      }) : createVNode("ul", {
        "class": ["content", this.searchable && isLeft ? "is-search" : ""]
      }, [list.map((item) => {
        var _a, _b, _c;
        return createVNode("li", {
          "key": item[this.settingCode],
          "class": [this.$slots[slotName] ? "custom-item" : ""],
          "onClick": () => this.handleItemClick(item, isLeft)
        }, [(_c = (_b = (_a = this.$slots)[slotName]) == null ? void 0 : _b.call(_a, item)) != null ? _c : getDefaultListHtml(item, isLeft)]);
      })]);
      return list.length ? contentMode : getEmptyHtml(emptySlotName);
    };
    return createVNode("div", {
      "class": ["lesscode-bk-transfer", this.extCls]
    }, [createVNode("div", {
      "class": "source-list"
    }, [getHeaderHtml("left-header"), this.searchable && createVNode(BkInput, {
      "modelValue": this.selectSearchQuery,
      "onUpdate:modelValue": ($event) => this.selectSearchQuery = $event,
      "class": "transfer-search-input",
      "clearable": true,
      "placeholder": this.searchPlaceholder || this.t.search
    }, {
      prefix: () => createVNode(search, {
        "class": "icon-search"
      }, null)
    }), getListContentHtml("left")]), multiple ? createVNode("div", {
      "class": "transfer-button-group"
    }, [createVNode("div", {
      "class": ["transfer-button", {
        disabled: !this.multipleSelectList.source.length
      }],
      "onClick": () => this.handleMultipleChange("left")
    }, [createVNode(angleRight, null, null)]), createVNode("div", {
      "class": ["transfer-button", {
        disabled: !this.multipleSelectList.target.length
      }],
      "onClick": () => this.handleMultipleChange("right")
    }, [createVNode(angleLeft, null, null)])]) : createVNode(transfer, {
      "class": "transfer"
    }, null), createVNode("div", {
      "class": "target-list"
    }, [getHeaderHtml("right-header"), getListContentHtml("right")])]);
  }
});
const Transfer = withInstall(Component$a);
var EVENTS = /* @__PURE__ */ ((EVENTS2) => {
  EVENTS2["NODE_CLICK"] = "nodeClick";
  EVENTS2["NODE_COLLAPSE"] = "nodeCollapse";
  EVENTS2["NODE_EXPAND"] = "nodeExpand";
  EVENTS2["NODE_CHECKED"] = "nodeChecked";
  EVENTS2["NODE_DRAG_START"] = "nodeDragStart";
  EVENTS2["NODE_DRAG_OVER"] = "nodeDragOver";
  EVENTS2["NODE_DRAG_LEAVE"] = "nodeDragLeave";
  EVENTS2["NODE_DROP"] = "nodeDrop";
  return EVENTS2;
})(EVENTS || {});
const EMPTY = (..._args) => true;
const TreeEmitEventsType = {
  ["nodeClick"]: EMPTY,
  ["nodeCollapse"]: EMPTY,
  ["nodeExpand"]: EMPTY,
  ["nodeChecked"]: EMPTY,
  ["nodeDragStart"]: EMPTY,
  ["nodeDragOver"]: EMPTY,
  ["nodeDragLeave"]: EMPTY,
  ["nodeDrop"]: EMPTY
};
var NODE_ATTRIBUTES = /* @__PURE__ */ ((NODE_ATTRIBUTES2) => {
  NODE_ATTRIBUTES2["DEPTH"] = "__depth";
  NODE_ATTRIBUTES2["INDEX"] = "__index";
  NODE_ATTRIBUTES2["UUID"] = "__uuid";
  NODE_ATTRIBUTES2["PARENT_ID"] = "__parent_id";
  NODE_ATTRIBUTES2["HAS_CHILD"] = "__has_child";
  NODE_ATTRIBUTES2["PATH"] = "__path";
  NODE_ATTRIBUTES2["IS_ROOT"] = "__is_root";
  NODE_ATTRIBUTES2["ORDER"] = "__order";
  NODE_ATTRIBUTES2["IS_OPEN"] = "__is_open";
  NODE_ATTRIBUTES2["IS_CHECKED"] = "__is_checked";
  NODE_ATTRIBUTES2["IS_SELECTED"] = "__is_selected";
  NODE_ATTRIBUTES2["IS_ASYNC_INIT"] = "__is_async_init";
  NODE_ATTRIBUTES2["IS_MATCH"] = "__is_match";
  NODE_ATTRIBUTES2["IS_NULL"] = "__IS_NULL";
  NODE_ATTRIBUTES2["IS_CACHED"] = "__is_cached";
  NODE_ATTRIBUTES2["IS_ASYNC"] = "__is_async";
  NODE_ATTRIBUTES2["IS_LOADING"] = "__is_loading";
  NODE_ATTRIBUTES2["TREE_NODE_ATTR"] = "__attr__";
  return NODE_ATTRIBUTES2;
})(NODE_ATTRIBUTES || {});
const NODE_SOURCE_ATTRS = {
  ["__is_open"]: "isOpen",
  ["__is_selected"]: "selected",
  ["__is_match"]: "isMatch",
  ["__has_child"]: "hasChild",
  ["__is_checked"]: "checked",
  ["__is_async"]: "async",
  ["__is_loading"]: "loading",
  ["__is_root"]: "isRoot"
};
var NodeContentActionEnum = /* @__PURE__ */ ((NodeContentActionEnum2) => {
  NodeContentActionEnum2["CLICK"] = "click";
  NodeContentActionEnum2["SELECTED"] = "selected";
  NodeContentActionEnum2["EXPAND"] = "expand";
  NodeContentActionEnum2["COLLAPSE"] = "collapse";
  return NodeContentActionEnum2;
})(NodeContentActionEnum || {});
const treeProps = {
  data: PropTypes.arrayOf(PropTypes.any).def([]),
  label: PropTypes.oneOfType([PropTypes.func.def(void 0), PropTypes.string.def("label")]),
  nodeKey: PropTypes.string.def(void 0),
  children: PropTypes.string.def("children"),
  indent: PropTypes.number.def(18),
  lineHeight: PropTypes.number.def(32),
  levelLine: PropTypes.oneOfType([
    PropTypes.bool.def(false),
    PropTypes.func.def(void 0),
    PropTypes.string.def("1px dashed #c3cdd7")
  ]).def(false),
  virtualRender: PropTypes.bool.def(false),
  prefixIcon: PropTypes.oneOfType([
    PropTypes.func.def(() => {
    }),
    PropTypes.bool.def(false)
  ]).def(true),
  async: PropTypes.shape({
    callback: PropTypes.func.def(void 0),
    cache: PropTypes.bool.def(true),
    deepAutoOpen: j("columnType", {}).def("once")
  }),
  offsetLeft: PropTypes.number.def(5),
  search: PropTypes.oneOfType([
    PropTypes.shape({
      value: PropTypes.oneOfType([
        PropTypes.number,
        PropTypes.string,
        PropTypes.bool
      ]).def(""),
      match: PropTypes.oneOfType([
        E(),
        PropTypes.func
      ]).def("fuzzy"),
      resultType: E().def("tree"),
      openResultNode: PropTypes.bool
    }),
    PropTypes.string,
    PropTypes.number,
    PropTypes.bool
  ]).def(void 0),
  emptyText: PropTypes.string.def("\u6CA1\u6709\u6570\u636E"),
  draggable: PropTypes.bool.def(false),
  disableDrag: PropTypes.func,
  disableDrop: PropTypes.func,
  dragSort: PropTypes.bool.def(false),
  selectable: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]).def(true),
  disabledFolderSelectable: PropTypes.bool.def(false),
  showCheckbox: PropTypes.bool.def(false),
  showNodeTypeIcon: PropTypes.bool.def(true),
  selected: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.object]),
  autoCheckChildren: PropTypes.bool.def(true),
  autoOpenParentNode: PropTypes.bool.def(true),
  expandAll: PropTypes.bool.def(false),
  nodeContentAction: PropTypes.oneOfType([
    PropTypes.arrayOf(j("nodeContentActionType", {}).def(NodeContentActionEnum.CLICK)),
    PropTypes.func.def(() => ["selected"])
  ]).def(["selected", "expand", "click"])
};
var useEmpty = (props2, {
  slots
}) => ({
  renderEmpty: (type) => createVNode(BkException, {
    "scene": "part",
    "type": type
  }, {
    default: () => {
      var _a, _b;
      return [(_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : props2.emptyText];
    }
  })
});
var useNodeAttribute = (flatData, props2) => {
  const getSchemaVal2 = (key2) => flatData.schema.get(key2);
  const getNodeAttr2 = (node, attr) => {
    var _a;
    return (_a = getSchemaVal2(node[NODE_ATTRIBUTES.UUID])) == null ? void 0 : _a[attr];
  };
  const setNodeAttr = (node, attr, val) => {
    flatData.schema.set(node[NODE_ATTRIBUTES.UUID], __spreadProps(__spreadValues({}, getSchemaVal2(node[NODE_ATTRIBUTES.UUID])), {
      [attr]: val
    }));
  };
  const getNodePath = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.PATH);
  const getNodeId = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.UUID);
  const isRootNode = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.IS_ROOT);
  const isNodeOpened = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.IS_OPEN);
  const hasChildNode = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.HAS_CHILD);
  const isNodeMatched = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.IS_MATCH);
  const isNodeChecked = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.IS_CHECKED);
  const getNodeParentId = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.PARENT_ID);
  const getNodeParentIdById = (id) => getNodeAttr2({
    [NODE_ATTRIBUTES.UUID]: id
  }, NODE_ATTRIBUTES.PARENT_ID);
  const isNodeLoading = (node) => getNodeAttr2(node, NODE_ATTRIBUTES.IS_LOADING);
  const setTreeNodeLoading = (node, value) => {
    setNodeAttr(node, NODE_ATTRIBUTES.IS_LOADING, value);
  };
  const deleteNodeSchema = (id) => flatData.schema.delete(id);
  const getParentNode2 = (node) => getSchemaVal2(getNodeParentId(node));
  const isItemOpen = (item) => {
    var _a;
    if (typeof item === "object") {
      return isNodeOpened(item);
    }
    if (typeof item === "string") {
      return (_a = getSchemaVal2(item)) == null ? void 0 : _a[NODE_ATTRIBUTES.IS_OPEN];
    }
    return false;
  };
  const isParentNodeOpened = (node) => isItemOpen(getNodeAttr2(node, NODE_ATTRIBUTES.PARENT_ID));
  const checkNodeIsOpen = (node) => isRootNode(node) || isParentNodeOpened(node);
  const getSourceNodeByPath = (path) => {
    const paths = path.split("-");
    return paths.reduce((pre, nodeIndex) => {
      const index2 = Number(nodeIndex);
      return Array.isArray(pre) ? pre[index2] : pre[props2.children][index2];
    }, props2.data);
  };
  const getChildNodes = (node) => {
    const source = flatData.schema;
    return Array.prototype.filter.call(Array.from(source.keys()), (key2) => source.get(key2)[NODE_ATTRIBUTES.PARENT_ID] === node[NODE_ATTRIBUTES.UUID]);
  };
  const getSourceNodeByUID = (uid) => getSourceNodeByPath(getNodePath({
    [NODE_ATTRIBUTES.UUID]: uid
  }));
  const getParentNodeData = (uid) => {
    if (isRootNode({
      [NODE_ATTRIBUTES.UUID]: uid
    })) {
      return {
        [props2.children]: props2.data
      };
    }
    return getSourceNodeByUID(getNodeParentIdById(uid));
  };
  const resolveScopedSlotParam = (item) => ({
    [NODE_SOURCE_ATTRS[NODE_ATTRIBUTES.IS_LOADING]]: getNodeAttr2(item, NODE_ATTRIBUTES.IS_LOADING),
    [NODE_SOURCE_ATTRS[NODE_ATTRIBUTES.HAS_CHILD]]: hasChildNode(item),
    [NODE_SOURCE_ATTRS[NODE_ATTRIBUTES.IS_MATCH]]: isNodeMatched(item),
    [NODE_SOURCE_ATTRS[NODE_ATTRIBUTES.IS_CHECKED]]: isNodeChecked(item),
    [NODE_SOURCE_ATTRS[NODE_ATTRIBUTES.IS_OPEN]]: isNodeOpened(item),
    [NODE_SOURCE_ATTRS[NODE_ATTRIBUTES.IS_ROOT]]: isRootNode(item),
    fullPath: getNodeAttr2(item, NODE_ATTRIBUTES.PATH),
    uuid: getNodeId(item),
    parentId: getNodeAttr2(item, NODE_ATTRIBUTES.PARENT_ID)
  });
  const extendNodeAttr = (item) => __spreadProps(__spreadValues({}, item), {
    [NODE_ATTRIBUTES.TREE_NODE_ATTR]: resolveScopedSlotParam(item)
  });
  return {
    getSchemaVal: getSchemaVal2,
    getNodeAttr: getNodeAttr2,
    getNodeId,
    getNodeParentId,
    getNodeParentIdById,
    getParentNodeData,
    getParentNode: getParentNode2,
    setNodeAttr,
    getNodePath,
    isRootNode,
    isNodeOpened,
    hasChildNode,
    isItemOpen,
    isNodeChecked,
    isNodeMatched,
    isNodeLoading,
    checkNodeIsOpen,
    getSourceNodeByPath,
    getSourceNodeByUID,
    deleteNodeSchema,
    resolveScopedSlotParam,
    setTreeNodeLoading,
    extendNodeAttr,
    getChildNodes
  };
};
const DEFAULT_LEVLE_LINE = "1px dashed #c3cdd7";
const getPropsOneOfBoolValueWithDefault = (props2, key2, item = null, defaultTrueValue = null, defaultFalseValue = null, args = []) => {
  const prop = props2[key2];
  if (typeof prop === "boolean") {
    return prop ? defaultTrueValue : defaultFalseValue;
  }
  return getStringOrFuncStr(item, props2, key2, args);
};
const getStringOrFuncStr = (item, props2, key2, args = []) => {
  const value = props2[key2];
  if (typeof value === "string") {
    if (typeof item === "object" && item !== null) {
      if (!Object.prototype.hasOwnProperty.call(item, value)) {
        console.error(`cannot find node label with key ${value}`);
      }
      return item[value];
    }
    return value;
  }
  if (typeof value === "function") {
    const txt = value.apply(globalThis, [item, ...args]);
    if (typeof txt === "string") {
      return txt;
    }
    console.error("props label with function return value is not string, please check and return string");
    return void 0;
  }
  return void 0;
};
const getLabel = (item, props2) => getStringOrFuncStr(item, props2, "label");
const getSchemaVal = (schema, uuid2) => schema.get(uuid2) || {};
const getNodeAttr = (schema, uuid2, key2) => {
  var _a;
  return (_a = getSchemaVal(schema, uuid2)) == null ? void 0 : _a[key2];
};
const getTreeStyle = (item, props2) => {
  const levelLine = getPropsOneOfBoolValueWithDefault(props2, "levelLine", item, DEFAULT_LEVLE_LINE, null, ["tree"]);
  return {
    "--level-line": levelLine,
    "--lineHeight": `${props2.lineHeight}px`,
    "--indent": `${props2.indent}px`,
    "--offset-left": `${props2.offsetLeft}px`
  };
};
const getNodeItemStyle = (item, props2, flatData = {}) => {
  const { schema } = flatData;
  const depth = getNodeAttr(schema, item[NODE_ATTRIBUTES.UUID], NODE_ATTRIBUTES.DEPTH);
  return __spreadValues({
    "--depth": depth
  }, typeof props2.levelLine === "function" ? {
    "--level-line": getPropsOneOfBoolValueWithDefault(props2, "levelLine", item, DEFAULT_LEVLE_LINE, null, [
      "node"
    ])
  } : {});
};
const getNodeItemClass = (item, schema, props2) => {
  const { __is_root, __is_open } = getSchemaVal(schema, item[NODE_ATTRIBUTES.UUID]) || {};
  return {
    "is-root": __is_root,
    "lesscode-bk-tree-node": true,
    "is-open": __is_open,
    "is-virtual-render": props2.virtualRender,
    "level-line": props2.levelLine
  };
};
const getNodeRowClass = (item, schema) => {
  const { __is_checked, __is_selected } = getSchemaVal(schema, item[NODE_ATTRIBUTES.UUID]) || {};
  return {
    "is-checked": __is_checked,
    "is-selected": __is_selected,
    "node-folder": item.is_folder,
    "node-leaf": item.is_leaf,
    [resolveClassName("node-row")]: true
  };
};
const updateTreeNode = (path, treeData, childKey, nodekey, nodeValue) => {
  assignTreeNode(path, treeData, childKey, { [nodekey]: nodeValue });
};
const assignTreeNode = (path, treeData, childKey, assignVal) => {
  const paths = path.split("-");
  const targetNode = paths.reduce((pre, nodeIndex) => {
    const index2 = Number(nodeIndex);
    return Array.isArray(pre) ? pre[index2] : pre[childKey][index2];
  }, treeData);
  Object.assign(targetNode, assignVal || {});
};
const resolveNodeItem = (node) => {
  if (node === void 0 || node === null) {
    return { __IS_NULL: true };
  }
  if (typeof node === "string" || typeof node === "number" || typeof node === "symbol") {
    return { [NODE_ATTRIBUTES.UUID]: node };
  }
  if (Object.prototype.hasOwnProperty.call(node, NODE_ATTRIBUTES.UUID)) {
    return node;
  }
  console.error("setNodeAction Error: node id cannot found");
  return node;
};
var useNodeAsync = (props2, flatData) => {
  const {
    setNodeAttr,
    getNodePath,
    getNodeAttr: getNodeAttr2,
    resolveScopedSlotParam,
    setTreeNodeLoading
  } = useNodeAttribute(flatData, props2);
  const setNodeRemoteLoad = (resp, item) => {
    if (typeof resp === "object" && resp !== null) {
      setNodeAttr(item, NODE_ATTRIBUTES.IS_OPEN, true);
      const nodeValue = Array.isArray(resp) ? resp : [resp];
      updateTreeNode(getNodePath(item), props2.data, props2.children, props2.children, nodeValue);
      return Promise.resolve(resp);
    }
    return Promise.resolve(resp);
  };
  const asyncNodeClick = (item) => {
    const {
      callback = null,
      cache = true
    } = props2.async || {};
    if (typeof callback === "function" && getNodeAttr2(item, NODE_ATTRIBUTES.IS_ASYNC)) {
      setNodeAttr(item, NODE_ATTRIBUTES.IS_ASYNC_INIT, true);
      if (!getNodeAttr2(item, NODE_ATTRIBUTES.IS_CACHED)) {
        setNodeAttr(item, NODE_ATTRIBUTES.IS_CACHED, cache);
        const dataAttr = resolveScopedSlotParam(item);
        const callbackResult = callback(item, (resp) => setNodeRemoteLoad(resp, item), dataAttr);
        if (typeof callbackResult === "object" && callbackResult !== null) {
          setTreeNodeLoading(item, true);
          if (callbackResult instanceof Promise) {
            return Promise.resolve(callbackResult.then((resp) => setNodeRemoteLoad(resp, item)).catch((err) => console.error("load remote data error:", err)).finally(() => {
              setTreeNodeLoading(item, false);
              setNodeAttr(item, NODE_ATTRIBUTES.IS_CACHED, true);
            }));
          }
          setNodeRemoteLoad(callbackResult, item);
          setTreeNodeLoading(item, false);
          return Promise.resolve(true);
        }
      }
      return Promise.resolve(true);
    }
    return Promise.resolve(true);
  };
  const deepAutoOpen = () => {
    const autoOpenNodes = flatData.data.filter((item) => getNodeAttr2(item, NODE_ATTRIBUTES.IS_ASYNC) && item[NODE_SOURCE_ATTRS[NODE_ATTRIBUTES.IS_OPEN]] && !getNodeAttr2(item, NODE_ATTRIBUTES.IS_ASYNC_INIT));
    if (autoOpenNodes.length) {
      Promise.all(autoOpenNodes.map((item) => asyncNodeClick(item))).then(() => {
        deepAutoOpen();
      }).catch((err) => {
        console.warn(err);
      });
    }
  };
  return {
    asyncNodeClick,
    deepAutoOpen
  };
};
var useNodeAction = (props2, ctx, flatData, _renderData, schemaValues, initOption) => {
  let selectedNodeId = props2.selected;
  const {
    setNodeAttr,
    getNodePath,
    getSchemaVal: getSchemaVal2,
    getNodeAttr: getNodeAttr2,
    getNodeId,
    getChildNodes,
    isRootNode,
    hasChildNode,
    isItemOpen,
    isNodeOpened,
    isNodeLoading,
    isNodeChecked,
    getParentNode: getParentNode2,
    resolveScopedSlotParam,
    extendNodeAttr
  } = useNodeAttribute(flatData, props2);
  const {
    registerNextLoop
  } = initOption;
  const {
    asyncNodeClick,
    deepAutoOpen
  } = useNodeAsync(props2, flatData);
  const getRootIcon = (item) => isItemOpen(item) ? createVNode(folderShapeOpen, {
    "class": [resolveClassName("tree-icon"), resolveClassName("node-prefix")]
  }, null) : createVNode(folder, {
    "class": [resolveClassName("tree-icon"), resolveClassName("node-prefix")]
  }, null);
  const renderPrefixVal = (val) => {
    if (typeof val === "string") {
      return val;
    }
    if (typeof val === "object" && val !== null) {
      if (val.__v_isVNode) {
        return val;
      }
      const {
        node,
        className,
        text,
        style: style2
      } = val;
      return h$1(node, {
        class: className,
        style: style2
      }, text);
    }
    return null;
  };
  const getLoadingIcon = (item) => {
    var _a, _b, _c;
    return ((_c = (_b = (_a = ctx.slots).nodeLoading) == null ? void 0 : _b.call(_a, extendNodeAttr(item))) != null ? _c : isNodeLoading(item)) ? createVNode(spinner, null, null) : "";
  };
  const getActionIcon = (item) => {
    if (ctx.slots.nodeAction) {
      return ctx.slots.nodeAction(extendNodeAttr(item));
    }
    let prefixFnVal = null;
    if (isNodeLoading(item)) {
      return getLoadingIcon(item);
    }
    if (typeof props2.prefixIcon === "function") {
      prefixFnVal = props2.prefixIcon(extendNodeAttr(item), "node_action");
      if (prefixFnVal !== "default") {
        return renderPrefixVal(prefixFnVal);
      }
    }
    if (prefixFnVal === "default" || typeof props2.prefixIcon === "boolean" && props2.prefixIcon) {
      if (hasChildNode(item) || item.async || !props2.autoCheckChildren) {
        return isItemOpen(item) ? createVNode(downShape, {
          "class": resolveClassName("node-prefix")
        }, null) : createVNode(rightShape, {
          "class": resolveClassName("node-prefix")
        }, null);
      }
    }
    return null;
  };
  const getNodePrefixIcon = (item) => {
    if (!props2.showNodeTypeIcon) {
      return null;
    }
    if (ctx.slots.nodeType) {
      return ctx.slots.nodeType(extendNodeAttr(item));
    }
    let prefixFnVal = null;
    if (typeof props2.prefixIcon === "function") {
      prefixFnVal = props2.prefixIcon(extendNodeAttr(item), "node_type");
      if (prefixFnVal !== "default") {
        return renderPrefixVal(prefixFnVal);
      }
    }
    if (prefixFnVal === "default" || typeof props2.prefixIcon === "boolean" && props2.prefixIcon) {
      return isRootNode(item) || hasChildNode(item) ? getRootIcon(item) : createVNode(textFile, {
        "class": [resolveClassName("tree-icon"), resolveClassName("node-prefix")]
      }, null);
    }
    return null;
  };
  const updateParentChecked = (item, isChecked) => {
    const parent = getParentNode2(item);
    if (parent) {
      setNodeAttr(parent, NODE_ATTRIBUTES.IS_CHECKED, isChecked);
      if (!isRootNode(parent)) {
        updateParentChecked(parent, isChecked);
      }
    }
  };
  const deepUpdateChildNode = (node, attr, value) => {
    getChildNodes(node).forEach((id) => {
      setNodeAttr({
        [NODE_ATTRIBUTES.UUID]: id
      }, attr, value);
      deepUpdateChildNode({
        [NODE_ATTRIBUTES.UUID]: id
      }, attr, value);
    });
  };
  const handleNodeItemCheckboxChange = (item, value) => {
    setNodeAttr(item, NODE_ATTRIBUTES.IS_CHECKED, !!value);
    deepUpdateChildNode(item, NODE_ATTRIBUTES.IS_CHECKED, !!value);
    updateParentChecked(item, value);
    ctx.emit(EVENTS.NODE_CHECKED, schemaValues.value.filter((t2) => isNodeChecked(t2)).map((n2) => n2[NODE_ATTRIBUTES.UUID]));
  };
  const isIndeterminate = (item) => isNodeChecked(item) && !schemaValues.value.filter((node) => {
    var _a;
    return (_a = getNodePath(node)) == null ? void 0 : _a.startsWith(getNodePath(item));
  }).every((filterNode) => isNodeChecked(filterNode));
  const isNodeItemChecked = (item) => isNodeChecked(item) || schemaValues.value.filter((node) => {
    var _a;
    return (_a = getNodePath(node)) == null ? void 0 : _a.startsWith(getNodePath(item));
  }).some((filterNode) => isNodeChecked(filterNode));
  const getCheckboxRender = (item) => {
    if (!props2.showCheckbox) {
      return null;
    }
    return createVNode(BkCheckbox, {
      "size": "small",
      "modelValue": isNodeItemChecked(item),
      "indeterminate": isIndeterminate(item),
      "onChange": (val) => handleNodeItemCheckboxChange(item, val)
    }, null);
  };
  const setNodeOpened = (item, isOpen = null, e = null, fireEmit = true) => {
    const newVal = isOpen === null ? !isItemOpen(item) : !!isOpen;
    if (!newVal) {
      deepUpdateChildNode(item, NODE_ATTRIBUTES.IS_OPEN, newVal);
    }
    setNodeAttr(item, NODE_ATTRIBUTES.IS_OPEN, newVal);
    if (fireEmit) {
      const emitEvent = isItemOpen(item) ? EVENTS.NODE_EXPAND : EVENTS.NODE_COLLAPSE;
      ctx.emit(emitEvent, item, resolveScopedSlotParam(item), getSchemaVal2(item[NODE_ATTRIBUTES.UUID]), e);
    }
  };
  const setNodeAction = (args, action, value) => {
    if (Array.isArray(args)) {
      args.forEach((node) => setNodeAttr(resolveNodeItem(node), action, value));
      return;
    }
    setNodeAttr(resolveNodeItem(args), action, value);
  };
  const setOpen = (item, isOpen = true, autoOpenParents = false) => {
    const resolvedItem = resolveNodeItem(item);
    if (resolvedItem[NODE_ATTRIBUTES.IS_NULL]) {
      return;
    }
    if (autoOpenParents) {
      if (isOpen) {
        setNodeAction(resolvedItem, NODE_ATTRIBUTES.IS_OPEN, true);
        if (!isRootNode(resolvedItem)) {
          const parentId = getNodeAttr2(resolvedItem, NODE_ATTRIBUTES.PARENT_ID);
          setOpen(parentId, true, true);
        }
      } else {
        setNodeOpened(resolvedItem, false, null, false);
      }
    } else {
      setNodeAction(resolvedItem, NODE_ATTRIBUTES.IS_OPEN, isOpen);
    }
  };
  const handleTreeNodeClick = (item, e) => {
    const isOpen = isNodeOpened(item);
    if (isOpen) {
      setNodeOpened(item, false, e);
      return;
    }
    asyncNodeClick(item).finally(() => {
      if (getNodeAttr2(item, NODE_ATTRIBUTES.IS_LOADING)) {
        registerNextLoop("setNodeOpenedAfterLoading", {
          type: "once",
          fn: () => setNodeOpened(item, true, e)
        });
      } else {
        setNodeOpened(item, true, e);
      }
    });
  };
  const handleNodeActionClick = (e, node) => {
    e.stopImmediatePropagation();
    e.stopPropagation();
    e.preventDefault();
    handleTreeNodeClick(node, e);
  };
  const setSelect = (uuid2, selected = true, autoOpen = true) => {
    const nodeList2 = Array.isArray(uuid2) ? uuid2 : [uuid2];
    if (!nodeList2.length) {
      return;
    }
    const resolvedItem = resolveNodeItem(nodeList2[0]);
    if (resolvedItem[NODE_ATTRIBUTES.IS_NULL]) {
      return;
    }
    if (!props2.selectable || typeof props2.selectable === "function" && !props2.selectable(uuid2) || props2.disabledFolderSelectable && (uuid2 == null ? void 0 : uuid2.is_folder) === true) {
      console.warn("props.selectable is false or undefined, please set selectable with true");
      return;
    }
    if (selectedNodeId !== null && selectedNodeId !== void 0) {
      setNodeAttr({
        [NODE_ATTRIBUTES.UUID]: selectedNodeId
      }, NODE_ATTRIBUTES.IS_SELECTED, !selected);
    }
    if (props2.selected && props2.selected !== selectedNodeId) {
      setNodeAttr({
        [NODE_ATTRIBUTES.UUID]: props2.selected
      }, NODE_ATTRIBUTES.IS_SELECTED, !selected);
    }
    setNodeAttr(resolvedItem, NODE_ATTRIBUTES.IS_SELECTED, selected);
    selectedNodeId = getNodeId(resolvedItem);
    if (autoOpen && nodeList2.length === 1) {
      setOpen(resolvedItem, true, true);
    }
    if (getNodeAttr2(resolvedItem, NODE_ATTRIBUTES.IS_ASYNC)) {
      asyncNodeClick(resolvedItem).then(() => {
        nextTick(() => {
          nodeList2.shift();
          setSelect(nodeList2, selected, autoOpen);
        });
      });
    }
  };
  const resolveNodeAction = (node) => {
    if (typeof props2.nodeContentAction === "function") {
      return Reflect.apply(props2.nodeContentAction, globalThis, [{
        node
      }]);
    }
    if (typeof props2.nodeContentAction === "string") {
      return [props2.nodeContentAction];
    }
    if (Array.isArray(props2.nodeContentAction)) {
      return props2.nodeContentAction;
    }
    return ["selected", "expand", "click"];
  };
  const handleNodeContentClick = (item, e) => {
    const nodeActions = resolveNodeAction(item);
    if (nodeActions.includes("selected")) {
      setSelect(item, true, false);
    }
    if (nodeActions.includes("expand")) {
      if (!isNodeOpened(item)) {
        handleTreeNodeClick(item, e);
      }
    }
    if (nodeActions.includes("collapse")) {
      if (isNodeOpened(item)) {
        handleTreeNodeClick(item, e);
      }
    }
    if (nodeActions.includes("click")) {
      const eventName = EVENTS.NODE_CLICK;
      ctx.emit(eventName, item, resolveScopedSlotParam(item), getSchemaVal2(item[NODE_ATTRIBUTES.UUID]), e);
    }
  };
  const filterNextNode = (depth, node) => {
    if (isRootNode(node)) {
      return false;
    }
    const nodepath = getNodePath(node);
    const paths = `${nodepath}`.split("-").slice(0, depth + 1);
    const currentPath = paths.join("-");
    if (currentPath === nodepath) {
      return true;
    }
    const lastLevel = paths.pop();
    const nextLevel = parseInt(lastLevel, 10);
    paths.push(`${nextLevel + 1}`);
    const nextNodePath = paths.join("-");
    return schemaValues.value.some((val) => val[NODE_ATTRIBUTES.PATH] === nextNodePath);
  };
  const getVirtualLines = (node) => {
    if (!props2.levelLine) {
      return null;
    }
    const getNodeLineStyle = (dpth) => ({
      "--depth": dpth
    });
    const maxDeep = getNodeAttr2(node, NODE_ATTRIBUTES.DEPTH) + 1;
    return new Array(maxDeep).fill("").map((_2, index2) => index2).filter((depth) => filterNextNode(depth, node)).filter((depth) => depth > 0).map((index2) => createVNode("span", {
      "class": "node-virtual-line",
      "style": getNodeLineStyle(maxDeep - index2)
    }, null));
  };
  const renderTreeNode = (item) => {
    var _a, _b, _c, _d, _e;
    return createVNode("div", {
      "data-tree-node": getNodeId(item),
      "key": getNodeId(item),
      "class": getNodeRowClass(item, flatData.schema)
    }, [createVNode("div", {
      "class": getNodeItemClass(item, flatData.schema, props2),
      "style": getNodeItemStyle(item, props2, flatData),
      "onClick": (e) => handleNodeContentClick(item, e)
    }, [createVNode("div", {
      "class": [resolveClassName("node-action")],
      "onClick": (e) => handleNodeActionClick(e, item)
    }, [getActionIcon(item)]), createVNode("div", {
      "class": resolveClassName("node-content")
    }, [[getCheckboxRender(item), getNodePrefixIcon(item)], createVNode("span", {
      "class": resolveClassName("node-text")
    }, [(_c = (_b = (_a = ctx.slots).node) == null ? void 0 : _b.call(_a, extendNodeAttr(item))) != null ? _c : [getLabel(item, props2)]]), (_e = (_d = ctx.slots).nodeAppend) == null ? void 0 : _e.call(_d, extendNodeAttr(item))]), getVirtualLines(item)])]);
  };
  return {
    renderTreeNode,
    handleTreeNodeClick,
    deepAutoOpen,
    asyncNodeClick,
    setNodeAction,
    setNodeOpened,
    setSelect,
    setOpen
  };
};
var useNodeDrag = (props2, ctx, root, flatData) => {
  const {
    getSourceNodeByUID,
    getNodeParentIdById,
    getParentNodeData,
    getNodeAttr: getNodeAttr2,
    getNodePath,
    isRootNode
  } = useNodeAttribute(flatData, props2);
  const isNeedCheckDraggable = computed(() => typeof props2.disableDrag === "function");
  const isNeedCheckDroppable = computed(() => typeof props2.disableDrop === "function");
  const getTargetTreeNode = (e) => {
    const target = e.target;
    return target.closest("[data-tree-node]");
  };
  const getNodeByTargetTreeNode = (targetNode) => {
    var _a;
    const uid = (_a = targetNode == null ? void 0 : targetNode.dataset) == null ? void 0 : _a.treeNode;
    return getSourceNodeByUID(uid);
  };
  const handleTreeNodeMouseup = (e) => {
    const targetNode = getTargetTreeNode(e);
    targetNode.removeEventListener("mouseup", handleTreeNodeMouseup);
  };
  const handleTreeNodeMousedown = (e) => {
    const targetNode = getTargetTreeNode(e);
    const data2 = getNodeByTargetTreeNode(targetNode);
    if (data2.draggable === false || isNeedCheckDraggable.value && props2.disableDrag(data2)) {
      targetNode.classList.add("lesscode-bk-tree-drag-disabled");
      return;
    }
    targetNode.setAttribute("draggable", "true");
    targetNode.addEventListener("mouseup", handleTreeNodeMouseup);
  };
  const handleTreeNodeDragover = (e) => {
    e.preventDefault();
    const targetNode = getTargetTreeNode(e);
    const data2 = getNodeByTargetTreeNode(targetNode);
    ctx.emit(EVENTS.NODE_DRAG_OVER, e, targetNode, data2);
    if (isNeedCheckDroppable.value && (props2 == null ? void 0 : props2.disableDrop(data2))) {
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.dropEffect = "none";
      targetNode.classList.add("lesscode-bk-tree-drop-disabled");
      return;
    }
    targetNode.classList.add("lesscode-bk-tree-drop-active");
    const sourceNodeId = e.dataTransfer.getData("node-id");
    const targetNodeId = targetNode.getAttribute("data-tree-node");
    const transferEffect = isNodeSortable(sourceNodeId, targetNodeId) ? "move" : "none";
    e.dataTransfer.effectAllowed = transferEffect;
    e.dataTransfer.dropEffect = transferEffect;
  };
  const handleTreeNodeDragStart = (e) => {
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.dropEffect = "move";
    const targetNode = getTargetTreeNode(e);
    e.dataTransfer.setData("text/plain", "");
    e.dataTransfer.setData("node-id", targetNode.getAttribute("data-tree-node"));
    ctx.emit(EVENTS.NODE_DRAG_START, e, targetNode);
  };
  const handleTreeNodeDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const targetNode = getTargetTreeNode(e);
    targetNode.classList.remove("lesscode-bk-tree-drop-active", "lesscode-bk-tree-drop-disabled");
    const data2 = getNodeByTargetTreeNode(targetNode);
    if (isNeedCheckDroppable.value && props2.disableDrop(data2)) {
      return;
    }
    const sourceNodeId = e.dataTransfer.getData("node-id");
    const targetNodeId = targetNode.getAttribute("data-tree-node");
    Reflect.apply(props2.dragSort ? dragSortData : dragAsChildNode, globalThis, [sourceNodeId, targetNodeId]);
    ctx.emit(EVENTS.NODE_DROP, e, targetNode, data2);
  };
  const isNodeSortable = (sourceId, targetId) => {
    const sourcePath = getNodePath({
      [NODE_ATTRIBUTES.UUID]: sourceId
    });
    const targetPath = getNodePath({
      [NODE_ATTRIBUTES.UUID]: targetId
    });
    const sourceParentNodeId = getNodeParentIdById(sourceId);
    const targetParentNode = getNodeParentIdById(targetId);
    if (sourceParentNodeId === targetParentNode) {
      return true;
    }
    return sourcePath.indexOf(targetPath) === -1 && targetPath.indexOf(sourcePath) === -1;
  };
  const dragSortData = (sourceId, targetId) => {
    if (!isNodeSortable(sourceId, targetId)) {
      return;
    }
    const sourceNodeData = JSON.parse(JSON.stringify(getSourceNodeByUID(sourceId)));
    const targetNodeData = JSON.parse(JSON.stringify(getSourceNodeByUID(targetId)));
    const sourceNodeParent = getParentNodeData(sourceId);
    const targetNodeParent = getParentNodeData(targetId);
    const sourceNodeIndex = getNodeAttr2({
      [NODE_ATTRIBUTES.UUID]: sourceId
    }, NODE_ATTRIBUTES.INDEX);
    const targetNodeIndex = getNodeAttr2({
      [NODE_ATTRIBUTES.UUID]: targetId
    }, NODE_ATTRIBUTES.INDEX);
    sourceNodeParent == null ? void 0 : sourceNodeParent[props2.children].splice(sourceNodeIndex, 1, targetNodeData);
    targetNodeParent == null ? void 0 : targetNodeParent[props2.children].splice(targetNodeIndex, 1, sourceNodeData);
  };
  const dragAsChildNode = (sourceNodeId, targetNodeId) => {
    const sourceNodeData = getSourceNodeByUID(sourceNodeId);
    const targetNodeData = getSourceNodeByUID(targetNodeId);
    let parentNode = null;
    if (isRootNode({
      [NODE_ATTRIBUTES.UUID]: sourceNodeId
    })) {
      parentNode = props2.data;
    } else {
      const sourceNodeParentId = getNodeParentIdById(sourceNodeId);
      if (sourceNodeParentId !== void 0 && sourceNodeParentId !== null) {
        parentNode = getSourceNodeByUID(sourceNodeParentId);
        const sourceNodeIndex = getNodeAttr2({
          [NODE_ATTRIBUTES.UUID]: sourceNodeId
        }, NODE_ATTRIBUTES.INDEX);
        parentNode == null ? void 0 : parentNode[props2.children].splice(sourceNodeIndex, 1);
      }
    }
    if (!targetNodeData[props2.children]) {
      targetNodeData[props2.children] = [];
    }
    targetNodeData[props2.children].unshift(sourceNodeData);
  };
  const handleTreeNodeDragLeave = (e) => {
    e.preventDefault();
    const targetNode = getTargetTreeNode(e);
    targetNode.classList.remove("lesscode-bk-tree-drop-active", "lesscode-bk-tree-drop-disabled");
    ctx.emit(EVENTS.NODE_DRAG_LEAVE, e, targetNode);
  };
  onMounted(() => {
    if (props2.draggable && root.value) {
      const rootTree = root.value.$el;
      rootTree.addEventListener("mousedown", handleTreeNodeMousedown);
      rootTree.addEventListener("dragstart", handleTreeNodeDragStart);
      rootTree.addEventListener("dragover", handleTreeNodeDragover);
      rootTree.addEventListener("dragleave", handleTreeNodeDragLeave);
      rootTree.addEventListener("drop", handleTreeNodeDrop);
    }
  });
  onUnmounted(() => {
    if (props2.draggable && root.value) {
      const rootTree = root.value.$el;
      rootTree.removeEventListener("mousedown", handleTreeNodeMousedown);
      rootTree.removeEventListener("dragstart", handleTreeNodeDragStart);
      rootTree.removeEventListener("dragover", handleTreeNodeDragover);
      rootTree.removeEventListener("dragleave", handleTreeNodeDragLeave);
      rootTree.removeEventListener("drop", handleTreeNodeDrop);
    }
  });
};
var useSearch = (props2) => {
  var _a;
  const refSearch = toRef(props2, "search");
  const {
    openResultNode = false,
    resultType = "tree"
  } = (_a = props2.search) != null ? _a : {};
  const isCommonType = (val) => ["string", "number", "boolean"].includes(typeof val);
  const exactMath = (matchValue, itemValue) => matchValue === itemValue;
  const regMatch = (matchValue, itemValue) => new RegExp(`${matchValue}`, "i").test(`${itemValue}`);
  const matchFn = (match2, args) => Reflect.apply(match2, globalThis, args);
  const isSearchDisabled = refSearch.value === void 0 || refSearch.value === false;
  const searchFn = (itemValue, item) => {
    if (isSearchDisabled) {
      return true;
    }
    if (isCommonType(refSearch.value)) {
      return matchFn(regMatch, [refSearch.value, itemValue, item]);
    }
    const {
      value = "",
      match: match2 = "fuzzy"
    } = refSearch.value;
    const defultMatch = match2 === "fuzzy" ? regMatch : exactMath;
    const matchCallback = typeof match2 === "function" ? match2 : defultMatch;
    if (`${value}`.length === 0) {
      return true;
    }
    return matchFn(matchCallback, [value, itemValue, item]);
  };
  const isSearchActive = computed(() => refSearch.value !== false && (isCommonType(refSearch.value) ? `${refSearch.value}`.length > 0 : typeof refSearch.value === "object"));
  const isTreeUI = resultType === "tree";
  return {
    searchFn,
    refSearch,
    isSearchActive,
    isSearchDisabled,
    openResultNode,
    resultType,
    isTreeUI
  };
};
var useTreeInit = (props2) => {
  var _a;
  const getFlatdata = (props3, treeData = void 0, cachedSchema = []) => {
    const {
      data: data2,
      children
    } = props3;
    const checkedList = [];
    const outputData = [];
    let order2 = 0;
    const schema = /* @__PURE__ */ new Map();
    function loopUpdateNodeAttr(uuid2, attrName, attrValue, callFn) {
      if (uuid2 === void 0 || uuid2 === null) {
        return;
      }
      if (schema.has(uuid2) && ![NODE_ATTRIBUTES.UUID, NODE_ATTRIBUTES.PARENT_ID].includes(attrName)) {
        const target = schema.get(uuid2);
        if (Object.prototype.hasOwnProperty.call(target, attrName)) {
          if (typeof callFn === "function" && Reflect.apply(callFn, self, [target, attrName, attrValue])) {
            Object.assign(target, {
              [attrName]: attrValue
            });
            loopUpdateNodeAttr(target[NODE_ATTRIBUTES.PARENT_ID], attrName, attrValue, callFn);
          }
        }
      }
    }
    function getUid(item) {
      let uid = null;
      if (typeof props3.nodeKey === "string") {
        uid = item[props3.nodeKey] || uuid_1.v4();
      }
      return uid || item[NODE_ATTRIBUTES.UUID] || uuid_1.v4();
    }
    const cachedDefaultVal = {
      [NODE_ATTRIBUTES.IS_OPEN]: () => !!props3.expandAll,
      [NODE_ATTRIBUTES.IS_CHECKED]: () => false,
      [NODE_ATTRIBUTES.IS_MATCH]: () => true,
      [NODE_ATTRIBUTES.IS_SELECTED]: (uuid2) => props3.selected === uuid2,
      [NODE_ATTRIBUTES.IS_CACHED]: () => false,
      [NODE_ATTRIBUTES.IS_ASYNC]: () => null,
      [NODE_ATTRIBUTES.IS_LOADING]: () => false
    };
    function getCachedTreeNodeAttr(uuid2, node, cachedAttr, defVal = void 0) {
      let defaultValue = defVal;
      if (defVal === void 0 && typeof cachedDefaultVal[cachedAttr] === "function") {
        defaultValue = cachedDefaultVal[cachedAttr](uuid2, node);
      }
      const sourceAttr = NODE_SOURCE_ATTRS[cachedAttr];
      if (Object.prototype.hasOwnProperty.call(node, sourceAttr)) {
        return node[sourceAttr];
      }
      const cached = (cachedSchema || []).find((item) => item[NODE_ATTRIBUTES.UUID] === uuid2);
      let result = void 0;
      if (cached) {
        result = cached[cachedAttr];
      }
      if (result === void 0 || result === null) {
        result = defaultValue;
      }
      return result;
    }
    function isCachedTreeNodeSelected(uuid2, node) {
      if (!props3.selectable) {
        return false;
      }
      return getCachedTreeNodeAttr(uuid2, node, NODE_ATTRIBUTES.IS_SELECTED, props3.selected === uuid2);
    }
    function isNodeOpend(uuid2, item, parent) {
      var _a2;
      const isItemOpened = getCachedTreeNodeAttr(uuid2, item, NODE_ATTRIBUTES.IS_OPEN);
      const isParentOpened = schema.has(parent) ? (_a2 = schema.get(parent)) == null ? void 0 : _a2[NODE_ATTRIBUTES.IS_OPEN] : true;
      return isItemOpened && isParentOpened;
    }
    function validateIsOpenLoopFn(target) {
      return !target[NODE_ATTRIBUTES.IS_OPEN];
    }
    function flatten(array, depth = 0, parent = null, path = null) {
      const arrLength = array.length;
      for (let i2 = 0; i2 < arrLength; i2++) {
        const item = array[i2];
        if (Array.isArray(item)) {
          flatten(item, depth, parent, path);
        } else {
          if (typeof item === "object" && item !== null) {
            const currentPath = path !== null ? `${path}-${i2}` : `${i2}`;
            const uuid2 = `${getUid(item)}`;
            const hasChildren = !!(item[children] || []).length;
            let isOpened = getCachedTreeNodeAttr(uuid2, item, NODE_ATTRIBUTES.IS_OPEN);
            if (props3.autoOpenParentNode) {
              isOpened && loopUpdateNodeAttr(parent, NODE_ATTRIBUTES.IS_OPEN, true, validateIsOpenLoopFn);
            } else {
              isOpened = isNodeOpend(uuid2, item, parent);
            }
            Object.assign(item, {
              [NODE_ATTRIBUTES.UUID]: uuid2
            });
            const isChecked = props3.showCheckbox && getCachedTreeNodeAttr(uuid2, item, NODE_ATTRIBUTES.IS_CHECKED);
            if (isChecked) {
              checkedList.push(uuid2);
            }
            schema.set(uuid2, {
              [NODE_ATTRIBUTES.DEPTH]: depth,
              [NODE_ATTRIBUTES.INDEX]: i2,
              [NODE_ATTRIBUTES.UUID]: uuid2,
              [NODE_ATTRIBUTES.PARENT_ID]: parent,
              [NODE_ATTRIBUTES.HAS_CHILD]: hasChildren,
              [NODE_ATTRIBUTES.PATH]: currentPath,
              [NODE_ATTRIBUTES.IS_ROOT]: parent === null,
              [NODE_ATTRIBUTES.ORDER]: order2,
              [NODE_ATTRIBUTES.IS_SELECTED]: isCachedTreeNodeSelected(uuid2, item),
              [NODE_ATTRIBUTES.IS_MATCH]: getCachedTreeNodeAttr(uuid2, item, NODE_ATTRIBUTES.IS_MATCH),
              [NODE_ATTRIBUTES.IS_OPEN]: isOpened,
              [NODE_ATTRIBUTES.IS_CHECKED]: isChecked,
              [NODE_ATTRIBUTES.IS_CACHED]: getCachedTreeNodeAttr(uuid2, item, NODE_ATTRIBUTES.IS_CACHED),
              [NODE_ATTRIBUTES.IS_ASYNC]: getCachedTreeNodeAttr(uuid2, item, NODE_ATTRIBUTES.IS_ASYNC),
              [NODE_ATTRIBUTES.IS_LOADING]: getCachedTreeNodeAttr(uuid2, item, NODE_ATTRIBUTES.IS_LOADING),
              [children]: null
            });
            order2 += 1;
            outputData.push(__spreadProps(__spreadValues({}, JSON.parse(JSON.stringify(item, (k2, v2) => k2 === props3.children ? null : v2))), {
              [NODE_ATTRIBUTES.IS_OPEN]: isOpened,
              [children]: null
            }));
            if (Object.prototype.hasOwnProperty.call(item, children)) {
              flatten(item[children] || [], depth + 1, uuid2, currentPath);
            }
          }
        }
      }
    }
    flatten(treeData ? treeData : data2);
    if (props3.showCheckbox) {
      checkedList == null ? void 0 : checkedList.forEach((value) => {
        Array.from(schema.values()).filter((t2) => {
          var _a2;
          return (_a2 = t2[NODE_ATTRIBUTES.PATH]) == null ? void 0 : _a2.startsWith(schema.get(value)[NODE_ATTRIBUTES.PATH]);
        }).forEach((n2) => Object.assign(n2, {
          [NODE_ATTRIBUTES.IS_CHECKED]: true
        }));
        loopUpdateNodeAttr(value, NODE_ATTRIBUTES.IS_CHECKED, true, () => true);
      });
    }
    return [outputData, schema];
  };
  const formatData = getFlatdata(props2);
  const nextLoopEvents = /* @__PURE__ */ new Map();
  const afterSelectEvents = [];
  const afterSelectWatch = [];
  const flatData = reactive({
    data: formatData[0],
    schema: formatData[1],
    levelLineSchema: {}
  });
  const schemaValues = computed(() => Array.from(flatData.schema.values()));
  const {
    asyncNodeClick,
    deepAutoOpen
  } = useNodeAsync(props2, flatData);
  const onSelected = (event) => {
    afterSelectEvents.push(event);
  };
  const registerNextLoop = (key2, event, reset2 = true) => {
    if (reset2 && nextLoopEvents.has(key2)) {
      nextLoopEvents.delete(key2);
    }
    nextLoopEvents.set(key2, event);
  };
  const resolveEventOption = (event) => {
    if (typeof event === "function") {
      return {
        type: "loop",
        fn: event
      };
    }
    if (typeof event === "object" && typeof event.type === "string" && typeof event.fn === "function") {
      return event;
    }
    console.error("loop event error", event);
    return null;
  };
  const executeFn = (event) => {
    var _a2;
    const resoveEvent = resolveEventOption(event);
    if (resoveEvent !== null) {
      Reflect.apply(resoveEvent.fn, globalThis, []);
    }
    return (_a2 = resoveEvent == null ? void 0 : resoveEvent.type) != null ? _a2 : "once";
  };
  const executeNextEvent = () => {
    Array.from(nextLoopEvents.keys()).forEach((key2) => {
      const target = nextLoopEvents.get(key2);
      if (Array.isArray(target)) {
        const clearList = [];
        target.forEach((event, index2) => {
          const result = executeFn(event);
          if (result === "once") {
            clearList.unshift(index2);
          }
        });
        if (clearList.length) {
          clearList.forEach((index2) => target.splice(index2, 1));
        }
        if (target.length === 0) {
          nextLoopEvents.delete(key2);
        }
      } else {
        const result = executeFn(target);
        if (result === "once") {
          nextLoopEvents.delete(key2);
        }
      }
    });
  };
  watch(() => [props2.data], (newData) => {
    var _a2, _b;
    const formatData2 = getFlatdata(props2, newData, schemaValues.value);
    flatData.data = formatData2[0];
    flatData.schema = formatData2[1];
    if (((_a2 = props2.async) == null ? void 0 : _a2.callback) && ((_b = props2.async) == null ? void 0 : _b.deepAutoOpen) === "every") {
      deepAutoOpen();
    }
    executeNextEvent();
  }, {
    deep: true
  });
  if (props2.selectable) {
    onMounted(() => {
      watch(() => props2.selected, (newData) => {
        afterSelectWatch.length = 0;
        afterSelectEvents.forEach((event) => {
          Reflect.apply(event, globalThis, [newData]);
          afterSelectWatch.push(() => Reflect.apply(event, globalThis, [newData]));
        });
        registerNextLoop("afterSelectWatch", afterSelectWatch);
      }, {
        immediate: true
      });
    });
  }
  const afterDataUpdate = (callFn) => {
    registerNextLoop("afterDataUpdate", callFn);
  };
  if ((_a = props2.async) == null ? void 0 : _a.callback) {
    deepAutoOpen();
  }
  return {
    flatData,
    schemaValues,
    asyncNodeClick,
    deepAutoOpen,
    afterDataUpdate,
    registerNextLoop,
    onSelected
  };
};
var Component$9 = defineComponent({
  name: "Tree",
  props: treeProps,
  emits: TreeEmitEventsType,
  setup(props2, ctx) {
    const {
      flatData,
      schemaValues,
      onSelected,
      registerNextLoop
    } = useTreeInit(props2);
    const {
      setNodeAttr,
      checkNodeIsOpen,
      getNodeAttr: getNodeAttr2,
      getNodePath,
      isRootNode,
      isNodeOpened,
      isNodeChecked,
      isNodeMatched,
      hasChildNode
    } = useNodeAttribute(flatData, props2);
    const {
      searchFn,
      isSearchActive,
      refSearch,
      openResultNode,
      isTreeUI,
      isSearchDisabled
    } = useSearch(props2);
    if (!isSearchDisabled) {
      watch([refSearch], () => {
        flatData.data.forEach((item) => {
          const isMatch = searchFn(getLabel(item, props2), item);
          setNodeAttr(item, NODE_ATTRIBUTES.IS_MATCH, isMatch);
          if (openResultNode) {
            setOpen(item, true, true);
          }
        });
      });
    }
    const filterFn = (item) => {
      if (isSearchActive.value) {
        const treeUiFilter = () => isTreeUI ? schemaValues.value.some((schema) => {
          var _a;
          return ((_a = schema[NODE_ATTRIBUTES.PATH]) == null ? void 0 : _a.startsWith(getNodePath(item))) && schema[NODE_ATTRIBUTES.IS_MATCH];
        }) : false;
        return getNodeAttr2(item, NODE_ATTRIBUTES.IS_MATCH) || treeUiFilter();
      }
      return true;
    };
    const renderData = computed(() => flatData.data.filter((item) => checkNodeIsOpen(item) && filterFn(item)));
    const {
      renderTreeNode,
      handleTreeNodeClick,
      setNodeOpened,
      setOpen,
      setNodeAction,
      setSelect,
      asyncNodeClick
    } = useNodeAction(props2, ctx, flatData, renderData, schemaValues, {
      registerNextLoop
    });
    const setChecked = (item, checked = true) => {
      setNodeAction(resolveNodeItem(item), NODE_ATTRIBUTES.IS_CHECKED, checked);
    };
    onSelected((newData) => {
      setSelect(newData, true, props2.autoOpenParentNode);
    });
    const getData = () => flatData;
    ctx.expose({
      handleTreeNodeClick,
      isNodeChecked,
      isRootNode,
      isNodeOpened,
      isNodeMatched,
      hasChildNode,
      setOpen,
      setChecked,
      setNodeAction,
      setNodeOpened,
      setSelect,
      asyncNodeClick,
      getData
    });
    const root = ref();
    const {
      renderEmpty
    } = useEmpty(props2, ctx);
    useNodeDrag(props2, ctx, root, flatData);
    const renderTreeContent = (scopedData) => {
      var _a, _b, _c;
      if (scopedData.length) {
        return scopedData.map(renderTreeNode);
      }
      const emptyType = isSearchActive.value ? "search-empty" : "empty";
      return (_c = (_b = (_a = ctx.slots).empty) == null ? void 0 : _b.call(_a)) != null ? _c : renderEmpty(emptyType);
    };
    return () => createVNode(BkVirtualRender, {
      "class": resolveClassName("tree"),
      "style": getTreeStyle(null, props2),
      "list": renderData.value,
      "lineHeight": props2.lineHeight,
      "enabled": props2.virtualRender,
      "contentClassName": resolveClassName("container"),
      "throttleDelay": 0,
      "ref": root
    }, {
      default: (scoped) => renderTreeContent(scoped.data || [])
    });
  }
});
const BkTree = withInstall(Component$9);
const isCustomComponent = (node) => node.__v_isVNode;
var ComposeFormItem = defineComponent({
  name: "ComposeFormItem",
  props: {
    headBackgroundColor: {
      type: String,
      default: "#FAFBFD"
    },
    tailBackgroundColor: String
  },
  render() {
    if (!this.$slots.default) {
      return null;
    }
    const childrenArr = this.$slots.default();
    if (childrenArr.length > 1) {
      const childrenLength = childrenArr.length;
      let startIndex = 0;
      let headChildren = null;
      while (startIndex < childrenLength) {
        if (isCustomComponent(childrenArr[startIndex])) {
          headChildren = childrenArr[startIndex];
          break;
        }
        startIndex = startIndex + 1;
      }
      let tailIndex = childrenLength - 1;
      let tailChildren = null;
      while (tailIndex >= 0 && tailIndex > startIndex) {
        if (isCustomComponent(childrenArr[tailIndex])) {
          tailChildren = childrenArr[tailIndex];
          break;
        }
        tailIndex = tailIndex - 1;
      }
      if (headChildren && tailChildren) {
        if (!headChildren.props) {
          headChildren.props = {};
        }
        let headChildClass = "lesscode-bk-compose-form-item-head";
        if (headChildren.props.class) {
          headChildClass += ` ${headChildren.props.class}`;
        }
        if (this.headBackgroundColor) {
          headChildren.props.style = Object.assign(headChildren.props.style || {}, {
            "background-color": this.headBackgroundColor
          });
        }
        headChildren.props.class = headChildClass;
        if (!tailChildren.props) {
          tailChildren.props = {};
        }
        let tailChildStaticClass = "lesscode-bk-compose-form-item-tail";
        if (tailChildren.props.class) {
          tailChildStaticClass += ` ${tailChildren.props.class}`;
        }
        if (this.tailBackgroundColor) {
          tailChildren.props.style = Object.assign(tailChildren.props.style || {}, {
            "background-color": this.tailBackgroundColor
          });
        }
        tailChildren.props.class = tailChildStaticClass;
      }
    }
    return h$1("div", {
      class: "lesscode-bk-compose-form-item"
    }, childrenArr);
  }
});
const formProps = {
  formType: PropTypes.oneOf(["default", "vertical"]).def("default"),
  labelWidth: PropTypes.oneOfType([Number, String]).def(150),
  labelPosition: PropTypes.oneOf(["left", "center", "right"]),
  model: PropTypes.object,
  rules: PropTypes.object
};
const formEvents = {
  submit: null,
  validate: (property, result, message2) => lodash.exports.isString(property) && lodash.exports.isBoolean(result) && lodash.exports.isString(message2)
};
var Form = defineComponent({
  name: "Form",
  props: formProps,
  emits: formEvents,
  setup(props2, context) {
    let formItemInstanceList = [];
    const register = (formItemInstance) => {
      formItemInstanceList.push(formItemInstance);
    };
    const unregister = (formItemInstance) => {
      formItemInstanceList = formItemInstanceList.reduce((result, item) => {
        if (item !== formItemInstance) {
          result.push(item);
        }
        return result;
      }, []);
    };
    provide(formKey, {
      props: props2,
      emit: context.emit,
      register,
      unregister
    });
    const handleSubmit = (event) => {
      event.preventDefault();
      context.emit("submit");
    };
    const validate = (fields) => {
      let fieldMap = {};
      if (fields) {
        const fieldList = typeof fields === "string" ? [fields] : fields;
        fieldMap = fieldList.reduce((result, item) => __spreadProps(__spreadValues({}, result), {
          [item]: true
        }), {});
      } else {
        fieldMap = formItemInstanceList.reduce((result, item) => {
          if (item.property) {
            return __spreadProps(__spreadValues({}, result), {
              [item.property]: true
            });
          }
          return result;
        }, {});
      }
      return Promise.all(formItemInstanceList.reduce((result, formItem) => {
        if (fieldMap[formItem.property]) {
          result.push(formItem.validate());
        }
        return result;
      }, [])).then(() => Promise.resolve(props2.model));
    };
    const getValidateResult = () => Promise.all(formItemInstanceList.map((formItem) => formItem.validate(void 0, false))).then(() => true).catch(() => false);
    const clearValidate = (fields) => {
      let fieldMap = {};
      if (fields) {
        const fieldList = typeof fields === "string" ? [fields] : fields;
        fieldMap = fieldList.reduce((result, item) => __spreadProps(__spreadValues({}, result), {
          [item]: true
        }), {});
      } else {
        fieldMap = formItemInstanceList.reduce((result, item) => __spreadProps(__spreadValues({}, result), {
          [item.property]: true
        }), {});
      }
      formItemInstanceList.forEach((formItem) => fieldMap[formItem.property] && formItem.clearValidate());
    };
    return {
      handleSubmit,
      validate,
      getValidateResult,
      clearValidate
    };
  },
  render() {
    var _a, _b;
    const formClasses = classes({
      "lesscode-bk-form": true,
      [`lesscode-bk-form--${this.formType}`]: true
    });
    return createVNode("form", {
      "class": formClasses,
      "onSubmit": this.handleSubmit
    }, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)]);
  }
});
const getRuleMessage = (rule) => {
  if (typeof rule.message === "function") {
    return rule.message();
  }
  return rule.message;
};
var defaultValidator = {
  required: (value) => {
    if (typeof value === "number" || typeof value === "boolean" || _$1.isDate(value)) {
      return true;
    }
    return !_$1.isEmpty(value);
  },
  min: (value, min2) => value >= min2,
  max: (value, max2) => max2 >= value,
  email: (value) => /^[A-Za-z\d]+([-_.][A-Za-z\d]+)*@([A-Za-z\d]+[-.])+[A-Za-z\d]{2,4}$/.test(value),
  maxlength: (value, maxlength) => value.length <= maxlength,
  pattern: (value, pattern) => pattern.test(value)
};
const formItemProps = {
  label: PropTypes.string,
  labelWidth: PropTypes.oneOfType([Number, String]),
  labelPosition: PropTypes.oneOf(["left", "center", "right"]),
  property: PropTypes.string.def(""),
  required: PropTypes.bool.def(false),
  email: PropTypes.bool.def(false),
  max: PropTypes.number,
  min: PropTypes.number,
  maxlength: PropTypes.number,
  rules: PropTypes.array,
  autoCheck: PropTypes.bool.def(false),
  description: PropTypes.string,
  errorDisplayType: PropTypes.oneOf(["tooltips", "normal"]).def("normal")
};
const hasOwn = (obj, key2) => Object.prototype.hasOwnProperty.call(obj, key2);
const getRulesFromProps = (props2, t2) => {
  const rules = [];
  const label = props2.label || "";
  if (props2.required) {
    rules.push({
      required: true,
      validator: defaultValidator.required,
      message: `${label} ${t2.value.notBeEmpty}`,
      trigger: "change"
    });
  }
  if (props2.email) {
    rules.push({
      email: true,
      validator: defaultValidator.email,
      message: `${label} ${t2.value.incorrectFormat}`,
      trigger: "change"
    });
  }
  if (Number(props2.max) > -1) {
    rules.push({
      validator: (value) => defaultValidator.max(value, props2.max),
      message: `${label} ${t2.value.max} ${props2.max}`,
      trigger: "change"
    });
  }
  if (Number(props2.min) > -1) {
    rules.push({
      validator: (value) => defaultValidator.min(value, props2.min),
      message: `${label} ${t2.value.min} ${props2.min}`,
      trigger: "change"
    });
  }
  if (Number(props2.maxlength) > -1) {
    rules.push({
      validator: (value) => defaultValidator.maxlength(value, props2.maxlength),
      message: `${label} ${t2.value.maxLen} ${props2.maxlength}`,
      trigger: "change"
    });
  }
  return rules;
};
const mergeRules = (configRules, propRules, t2) => {
  let customRequired = false;
  let customEmail = false;
  const formatConfigRules = configRules.reduce((result, rule) => {
    let rulevalidator;
    if (rule.required) {
      rulevalidator = lodash.exports.isFunction(rule.validator) ? rule.validator : defaultValidator.required;
      customRequired = true;
    } else if (rule.email) {
      rulevalidator = lodash.exports.isFunction(rule.validator) ? rule.validator : defaultValidator.email;
      customEmail = true;
    } else if (Number(rule.max) > -1) {
      rulevalidator = (value) => defaultValidator.max(value, rule.max);
    } else if (Number(rule.min) > -1) {
      rulevalidator = (value) => defaultValidator.min(value, rule.max);
    } else if (Number(rule.maxlength) > -1) {
      rulevalidator = (value) => defaultValidator.min(value, rule.max);
    } else if (Object.prototype.toString.call(rule.pattern) === "[object RegExp]") {
      rulevalidator = (value) => defaultValidator.pattern(value, rule.pattern);
    } else if (lodash.exports.isFunction(rule.validator)) {
      rulevalidator = rule.validator;
    } else {
      return result;
    }
    result.push({
      validator: rulevalidator,
      message: rule.message || t2.value.verifyError,
      trigger: rule.trigger || "blur"
    });
    return result;
  }, []);
  const filterPropRules = propRules.reduce((result, ruleItem) => {
    if (ruleItem.required && customRequired) {
      return result;
    }
    if (ruleItem.email && customEmail) {
      return result;
    }
    result.push(ruleItem);
    return result;
  }, []);
  return [...filterPropRules, ...formatConfigRules];
};
const getTriggerRules = (trigger, rules) => rules.reduce((result, rule) => {
  if (!rule.trigger || !trigger) {
    result.push(rule);
    return result;
  }
  const ruleTriggerList = Array.isArray(rule.trigger) ? rule.trigger : [rule.trigger];
  if (ruleTriggerList.includes(trigger)) {
    result.push(rule);
  }
  return result;
}, []);
const isValid = (value) => value !== void 0;
var FormItem = defineComponent({
  name: "FormItem",
  directives: {
    bkTooltips: tooltips
  },
  props: formItemProps,
  setup(props2, context) {
    const t2 = useLocale("form");
    const form2 = useForm();
    const isForm = Boolean(form2);
    const parentFormItem = useFormItem();
    const isNested = Boolean(parentFormItem);
    const currentInstance = getCurrentInstance();
    const state = reactive({
      isError: false,
      errorMessage: ""
    });
    const isFormTypeVertical = computed(() => {
      if (!isForm) {
        return false;
      }
      return form2.props.formType === "vertical";
    });
    const isShowLabel = computed(() => {
      if (props2.label || context.slots.label) {
        return true;
      }
      return false;
    });
    const labelStyles = computed(() => {
      const styles = {
        width: "",
        paddingRight: "",
        textAlign: ""
      };
      const labelPosition = props2.labelPosition || isForm && form2.props.labelPosition;
      if (labelPosition) {
        styles["text-align"] = labelPosition;
      }
      if (form2.props.formType === "vertical" || !props2.label && isNested) {
        return styles;
      }
      const labelWidth = isValid(props2.labelWidth) ? props2.labelWidth : isForm && form2.props.labelWidth;
      if (isValid(labelWidth)) {
        styles.width = `${labelWidth}px`;
        styles.paddingRight = labelWidth ? "" : "0px";
      }
      return styles;
    });
    const contentStyles = computed(() => ({
      ["margin-left"]: labelStyles.value.width
    }));
    const validate = (trigger, showError = true) => {
      if (!props2.property || isForm && !form2.props.model) {
        return Promise.resolve(true);
      }
      let rules = [];
      if (isForm && form2.props.rules && hasOwn(form2.props.rules, props2.property)) {
        rules = form2.props.rules[props2.property];
      }
      if (props2.rules) {
        rules = props2.rules;
      }
      rules = getTriggerRules(trigger, mergeRules(rules, getRulesFromProps(props2, t2), t2));
      if (rules.length > 0 && showError) {
        state.isError = false;
        state.errorMessage = "";
      }
      const value = lodash.exports.get(form2.props.model, props2.property);
      const doValidate = (() => {
        let stepIndex = -1;
        return () => {
          stepIndex = stepIndex + 1;
          if (stepIndex >= rules.length) {
            form2.emit("validate", props2.property, true, "");
            return Promise.resolve(true);
          }
          const rule = rules[stepIndex];
          return Promise.resolve().then(() => {
            const result = rule.validator(value);
            const errorMessage = getRuleMessage(rule);
            if (typeof result !== "boolean" && typeof result.then === "function") {
              return result.then((data2) => {
                if (data2 === false) {
                  return Promise.reject(errorMessage);
                }
              }).then(() => doValidate(), () => {
                if (showError) {
                  state.isError = true;
                  state.errorMessage = errorMessage;
                }
                form2.emit("validate", props2.property, false, errorMessage);
                return Promise.reject(state.errorMessage);
              });
            }
            if (!result) {
              if (showError) {
                state.isError = true;
                state.errorMessage = typeof result === "string" ? result : errorMessage;
              }
              form2.emit("validate", props2.property, false, errorMessage);
              return Promise.reject(state.errorMessage);
            }
            return doValidate();
          });
        };
      })();
      return doValidate();
    };
    const clearValidate = () => {
      state.isError = false;
      state.errorMessage = "";
    };
    provide(formItemKey, __spreadProps(__spreadValues({}, props2), {
      validate,
      clearValidate
    }));
    onMounted(() => {
      if (isForm) {
        form2.register(currentInstance.proxy);
      }
    });
    onBeforeUnmount(() => {
      if (isForm) {
        form2.unregister(currentInstance.proxy);
      }
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      isShowLabel,
      labelStyles,
      contentStyles,
      isFormTypeVertical,
      validate,
      clearValidate
    });
  },
  render() {
    var _a, _b, _c, _d;
    const itemClassees = classes({
      "lesscode-bk-form-item": true,
      "is-error": this.isError,
      "is-required": this.required
    });
    const renderLabel = () => {
      if (this.$slots.label) {
        return this.$slots.label();
      }
      if (this.description) {
        return withDirectives(createVNode("span", {
          "class": {
            "lesscode-bk-form-label-description": Boolean(this.description)
          }
        }, [this.label]), [[resolveDirective("bk-tooltips"), this.description]]);
      }
      return this.label;
    };
    const renderError = () => {
      if (!this.isError) {
        return null;
      }
      if (this.errorDisplayType === "tooltips") {
        return withDirectives(createVNode("div", {
          "class": "lesscode-bk-form-error-tips"
        }, [createVNode(exclamationCircleShape, null, null)]), [[resolveDirective("bk-tooltips"), this.errorMessage]]);
      }
      return createVNode("div", {
        "class": "lesscode-bk-form-error"
      }, [this.$slots.error ? this.$slots.error(this.errorMessage) : this.errorMessage]);
    };
    return createVNode("div", {
      "class": itemClassees
    }, [this.isShowLabel && createVNode("div", {
      "class": "lesscode-bk-form-label",
      "style": this.labelStyles
    }, [renderLabel(), this.isFormTypeVertical && ((_b = (_a = this.$slots).labelAppend) == null ? void 0 : _b.call(_a))]), createVNode("div", {
      "class": "lesscode-bk-form-content",
      "style": this.contentStyles
    }, [(_d = (_c = this.$slots).default) == null ? void 0 : _d.call(_c), renderError()])]);
  }
});
const BkForm = withInstallProps(Form, { FormItem, ComposeFormItem });
const colProps = {
  span: PropTypes.number.def(1),
  offset: PropTypes.number.def(0),
  pull: PropTypes.number.def(0),
  push: PropTypes.number.def(0)
};
var Col = defineComponent({
  name: "Col",
  props: colProps,
  emits: [],
  setup(props2, ctx) {
    const {
      col,
      gutter,
      flex
    } = inject("containerProps");
    const {
      span,
      offset: offset2,
      pull,
      push
    } = props2;
    const realSpan = computed(() => span || col);
    provide("containerProps", {
      col: realSpan.value,
      gutter,
      flex
    });
    const formatPercentage = function(val) {
      return `${Number((val * 100).toFixed(3))}%`;
    };
    const style2 = computed(() => ({
      width: formatPercentage(realSpan.value / col),
      "padding-right": `${gutter / 2}px`,
      "padding-left": `${gutter / 2}px`,
      "margin-left": offset2 ? formatPercentage(offset2 / col) : null,
      right: pull ? formatPercentage(pull / col) : null,
      left: push ? formatPercentage(push / col) : null
    }));
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": "lesscode-bk-grid-col",
        "style": style2.value
      }, [(_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
const containerProps = {
  col: PropTypes.number.def(24),
  gutter: PropTypes.number.def(20),
  margin: PropTypes.number.def(20),
  flex: PropTypes.bool.def(false),
  extCls: PropTypes.string
};
var Container = defineComponent({
  name: "Container",
  props: containerProps,
  emits: [],
  setup(props2, ctx) {
    const {
      col,
      gutter,
      flex,
      extCls
    } = props2;
    provide("containerProps", {
      col,
      gutter,
      flex
    });
    const classes2 = computed(() => extCls ? `lesscode-bk-grid-container ${extCls}` : "lesscode-bk-grid-container");
    const style2 = computed(() => {
      const {
        margin
      } = props2;
      return {
        "padding-right": `${margin}px`,
        "padding-left": `${margin}px`
      };
    });
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": classes2.value,
        "style": style2.value
      }, [(_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
var Row = defineComponent({
  name: "Row",
  emits: [],
  setup(_props, ctx) {
    const {
      col,
      gutter,
      flex
    } = inject("containerProps");
    provide("containerProps", {
      col,
      gutter,
      flex
    });
    const style2 = computed(() => {
      const o2 = flex ? {
        display: ["-webkit-box", "-ms-flexbox", "flex"]
      } : {};
      return __spreadProps(__spreadValues({}, o2), {
        "margin-right": `-${gutter / 2}px`,
        "margin-left": `-${gutter / 2}px`
      });
    });
    return () => {
      var _a, _b;
      return createVNode("div", {
        "class": "lesscode-bk-grid-row",
        "style": style2.value
      }, [(_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a)]);
    };
  }
});
const BkContainer = withInstallProps(Container, { Row, Col });
var Dropdown = defineComponent({
  name: "Dropdown",
  props: {
    isShow: PropTypes.bool.def(false),
    placement: placementType$1(),
    trigger: triggerType$1(),
    disabled: PropTypes.bool.def(false),
    popoverOptions: PropTypes.object.def({}),
    extCls: PropTypes.string
  },
  emits: ["showChange", "show", "hide"],
  setup(_props, {
    emit
  }) {
    const handleShowChagne = (val) => {
      emit("showChange", val);
    };
    const afterShow = () => {
      emit("show");
      handleShowChagne(true);
    };
    const afterHidden = () => {
      emit("hide");
      handleShowChagne(false);
    };
    const popoverRef = ref(null);
    return {
      afterShow,
      afterHidden,
      popoverRef
    };
  },
  render() {
    const wrapperClasses = classes({
      "lesscode-bk-dropdown": true
    }, this.$props.extCls);
    const basePopoverOptions = {
      theme: "light lesscode-bk-dropdown-popover",
      trigger: this.trigger,
      arrow: false,
      placement: this.placement,
      isShow: this.isShow,
      disabled: this.disabled
    };
    const popoverOptions = lodash.exports.merge(basePopoverOptions, this.popoverOptions);
    return createVNode("div", {
      "class": wrapperClasses
    }, [createVNode(BkPopover, mergeProps({
      "ref": "popoverRef"
    }, popoverOptions, {
      "onAfterShow": this.afterShow,
      "onAfterHidden": this.afterHidden
    }), {
      default: () => {
        var _a, _b;
        return createVNode("div", {
          "class": "lesscode-bk-dropdown-reference"
        }, [createTextVNode(" "), (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a), createTextVNode(" ")]);
      },
      content: () => {
        var _a, _b;
        return createVNode("div", {
          "class": "lesscode-bk-dropdown-content"
        }, [createTextVNode(" "), (_b = (_a = this.$slots).content) == null ? void 0 : _b.call(_a), createTextVNode(" ")]);
      }
    })]);
  }
});
var DropdownItem = defineComponent({
  name: "DropdownItem",
  props: {
    extCls: PropTypes.string
  },
  emits: ["click"],
  setup(props2, {
    emit
  }) {
    const handleClick = (evt) => {
      evt.stopPropagation();
      emit("click", evt);
    };
    const wrapperCLasses = computed(() => ["lesscode-bk-dropdown-item", props2.extCls]);
    return {
      wrapperCLasses,
      handleClick
    };
  },
  render() {
    var _a, _b;
    return createVNode("li", {
      "class": this.wrapperCLasses,
      "onClick": this.handleClick
    }, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)]);
  }
});
var DropdownMenu = defineComponent({
  name: "DropdownMenu",
  props: {
    extCls: PropTypes.string
  },
  setup(props2) {
    const wrapperCLasses = computed(() => ["lesscode-bk-dropdown-menu", props2.extCls]);
    return {
      wrapperCLasses
    };
  },
  render() {
    var _a, _b;
    return createVNode("ul", {
      "class": this.wrapperCLasses
    }, [(_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a)]);
  }
});
const BkDropdown = withInstallProps(Dropdown, { DropdownMenu, DropdownItem });
var CascaderPanel = defineComponent({
  name: "CascaderPanel",
  props: {
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def("auto"),
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def(216),
    store: PropTypes.object.def({}),
    separator: PropTypes.string.def(""),
    suggestions: PropTypes.arrayOf(A()),
    isFiltering: PropTypes.bool.def(false),
    searchKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).def(""),
    modelValue: PropTypes.arrayOf(PropTypes.oneOfType([q(), String, Number]))
  },
  emits: ["update:modelValue"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("select");
    const {
      store
    } = props2;
    const menus = reactive({
      list: [props2.store.getNodes()]
    });
    const activePath = ref([]);
    const checkValue = ref([]);
    const getSizeComputed = (value) => {
      if (typeof value === "number") {
        return `${value}px`;
      }
      return value;
    };
    const panelHeight = getSizeComputed(props2.height);
    const panelWidth = getSizeComputed(props2.width);
    const updateCheckValue = (value) => {
      if (value.length === 0) {
        menus.list = menus.list.slice(0, 1);
        activePath.value = [];
      }
      value.forEach((id) => {
        const node = store.getNodeById(id);
        nodeExpandHandler(node);
      });
      checkValue.value = value;
    };
    const nodeCheckHandler = (node) => {
      if (node.isDisabled) {
        return;
      }
      if (node.config.multiple) {
        checkValue.value = store.getCheckedNodes().map((node2) => node2.path);
      } else {
        checkValue.value = node.path;
      }
      emit("update:modelValue", checkValue.value);
    };
    const nodeExpandHandler = (node) => {
      var _a;
      if (!node || (node == null ? void 0 : node.isDisabled))
        return;
      menus.list = menus.list.slice(0, node.level);
      activePath.value = activePath.value.slice(0, node.level - 1);
      if ((_a = node.children) == null ? void 0 : _a.length) {
        menus.list.push(node.children);
        activePath.value.push(node);
        return;
      }
      if (store.config.isRemote && !node.isLeaf) {
        node.loading = true;
        const updateNodes = (nodeData) => {
          store.appendNodes(nodeData, node || null);
          menus.list.push(node.children);
          activePath.value.push(node);
          node.loading = false;
        };
        store.config.remoteMethod(node, updateNodes);
      }
    };
    const nodeEvent = (node) => {
      const {
        trigger,
        checkAnyLevel,
        multiple
      } = node.config;
      const events = {
        onClick: (e) => {
          if (!node.isLeaf || multiple)
            e.stopPropagation();
          trigger === "click" && nodeExpandHandler(node);
          checkAnyLevel && !multiple && nodeCheckHandler(node);
          node.isLeaf && !multiple && nodeCheckHandler(node);
        },
        onMouseenter: () => {
          trigger === "hover" && nodeExpandHandler(node);
        }
      };
      return events;
    };
    const searchPanelEvents = (node) => {
      const {
        multiple
      } = node.config;
      const events = {
        onClick: (e) => {
          if (multiple) {
            e.stopPropagation();
            checkNode(node, !node.checked);
            return;
          }
          nodeExpandHandler(node);
          node.isLeaf && !multiple && nodeCheckHandler(node);
        }
      };
      return events;
    };
    const noDataText = t2.value.noData;
    const isNodeInPath = (node) => {
      const currentLevel = activePath.value[node.level - 1] || {};
      return currentLevel.id === node.id;
    };
    const isCheckedNode = (node, checkValue2) => {
      const {
        multiple
      } = node.config;
      if (multiple) {
        return checkValue2.some((val) => arrayEqual(val, node.path));
      }
      return arrayEqual(checkValue2, node.path);
    };
    const checkNode = (node, value) => {
      node.setNodeCheck(value ? value : false);
      nodeCheckHandler(node);
    };
    const iconRender = (node) => node.loading ? createVNode(spinner, {
      "class": "icon-spinner"
    }, null) : createVNode(angleRight, {
      "class": "icon-angle-right"
    }, null);
    watch(() => props2.modelValue, (value) => {
      updateCheckValue(value);
    }, {
      immediate: true
    });
    watch(() => props2.store, (value) => {
      menus.list = [value.getNodes()];
    });
    return {
      menus,
      activePath,
      nodeExpandHandler,
      isNodeInPath,
      nodeEvent,
      isCheckedNode,
      checkValue,
      checkNode,
      iconRender,
      panelWidth,
      panelHeight,
      searchPanelEvents,
      noDataText
    };
  },
  render() {
    const emptyWidth = parseInt(this.panelWidth, 10) > 200 ? this.panelWidth : `${200}px`;
    const searchPanelRender = () => this.suggestions.length ? createVNode("ul", {
      "class": [resolveClassName("cascader-panel"), "lesscode-bk-scroll-y"],
      "style": {
        height: this.panelHeight,
        width: this.panelWidth
      }
    }, [this.suggestions.map((node) => createVNode("li", mergeProps({
      "class": [resolveClassName("cascader-node"), {
        "is-selected": this.isNodeInPath(node)
      }, {
        "is-disabled": node.isDisabled
      }, {
        "is-checked": this.isCheckedNode(node, this.checkValue)
      }]
    }, this.searchPanelEvents(node)), [node.pathNames.join(this.separator)]))]) : createVNode("div", {
      "class": resolveClassName("cascader-search-empty"),
      "style": {
        width: emptyWidth
      }
    }, [createVNode("span", null, [createTextVNode("\u6682\u65E0\u641C\u7D22\u7ED3\u679C")])]);
    return createVNode("div", {
      "class": resolveClassName("cascader-panel-wrapper")
    }, [this.isFiltering ? searchPanelRender() : this.menus.list.map((menu2) => createVNode("ul", {
      "class": [resolveClassName("cascader-panel"), "lesscode-bk-scroll-y"],
      "style": {
        height: this.panelHeight,
        width: this.panelWidth
      }
    }, [menu2.length ? menu2.map((node) => {
      var _a, _b;
      return createVNode("li", mergeProps({
        "class": [resolveClassName("cascader-node"), {
          "is-selected": this.isNodeInPath(node)
        }, {
          "is-disabled": node.isDisabled
        }, {
          "is-checked": !node.config.multiple && this.isCheckedNode(node, this.checkValue)
        }]
      }, Object.assign(this.nodeEvent(node), node.config.multiple ? {} : {})), [node.config.multiple && createVNode(BkCheckbox, {
        "disabled": node.isDisabled,
        "modelValue": node.checked,
        "onUpdate:modelValue": ($event) => node.checked = $event,
        "indeterminate": node.isIndeterminate,
        "style": "margin-right: 5px",
        "onChange": (val) => this.checkNode(node, val)
      }, null), (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
        node,
        data: node.data
      }), !node.isLeaf ? this.iconRender(node) : ""]);
    }) : createVNode("div", {
      "class": resolveClassName("cascader-panel-empty-wrapper")
    }, [this.noDataText])]))]);
  }
});
function isNodeDisabled(node) {
  if (node.data.disabled) {
    return true;
  }
  if (node.level !== 1) {
    return isNodeDisabled(node.parent);
  }
  return node.data.disabled;
}
class Node$1 {
  constructor(node, config, parent) {
    this.data = node;
    this.config = config;
    this.parent = parent || null;
    this.leaf = node.leaf;
    this.level = !this.parent ? 1 : this.parent.level + 1;
    this.initState();
  }
  initState() {
    const { idKey, nameKey, childrenKey } = this.config;
    this.id = this.data[idKey];
    this.name = this.data[nameKey];
    this.loading = false;
    this.loaded = false;
    this.checked = false;
    const childrenData = this.data[childrenKey];
    this.children = (childrenData || []).map((child) => new Node$1(child, this.config, this));
    this.pathNodes = this.calculateNodesPath();
    this.path = this.pathNodes.map((node) => node.id);
    this.pathNames = this.pathNodes.map((node) => node.name);
  }
  get isLeaf() {
    var _a;
    if (this.config.isRemote) {
      const isLeaf = this.leaf || (this.loaded ? !this.children.length : false);
      return isLeaf;
    }
    return !(Array.isArray(this.children) && ((_a = this.children) == null ? void 0 : _a.length) !== 0);
  }
  get isDisabled() {
    return isNodeDisabled(this);
  }
  broadcast(event, checkStatus) {
    const handlerName = `onParent${capitalize(event)}`;
    this.children.forEach((child) => {
      var _a;
      if (child) {
        child.broadcast(event, checkStatus);
        (_a = child[handlerName]) == null ? void 0 : _a.call(child, checkStatus);
      }
    });
  }
  emit(event) {
    var _a;
    const { parent } = this;
    const handlerName = `onChild${capitalize(event)}`;
    if (parent) {
      (_a = parent[handlerName]) == null ? void 0 : _a.call(parent);
      parent.emit(event);
    }
  }
  onParentCheck(checked) {
    if (!this.isDisabled) {
      this.setCheckState(checked);
    }
  }
  onChildCheck() {
    const { children } = this;
    const validChildren = children.filter((child) => !child.isDisabled);
    const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;
    this.setCheckState(checked);
  }
  setCheckState(checked) {
    const totalNum = this.children.length;
    const checkedNum = this.children.reduce((c2, p2) => {
      const tempNum = p2.isIndeterminate ? 0.5 : 0;
      const num = p2.checked ? 1 : tempNum;
      return c2 + num;
    }, 0);
    this.checked = checked;
    this.isIndeterminate = checkedNum !== totalNum && checkedNum > 0;
  }
  setNodeCheck(status) {
    if (this.checked !== status) {
      if (this.config.checkAnyLevel) {
        this.checked = status;
        return;
      }
      this.broadcast("check", status);
      this.setCheckState(status);
      this.emit("check");
    }
  }
  calculateNodesPath() {
    const nodes = [this];
    let { parent } = this;
    while (parent) {
      nodes.unshift(parent);
      parent = parent.parent;
    }
    return nodes;
  }
}
const flatNodes = (data2, leafOnly) => data2.reduce((acc, node) => {
  if (node.isLeaf) {
    acc.push(node);
  } else {
    !leafOnly && acc.push(node);
    acc = acc.concat(flatNodes(node.children, leafOnly));
  }
  return acc;
}, []);
class Store {
  constructor(props2) {
    const { list } = props2;
    this.data = list;
    this.config = props2;
    this.nodes = this.data.map((node) => new Node$1(node, this.config));
  }
  getNodes() {
    return this.nodes;
  }
  clearChecked() {
    this.getFlattedNodes().forEach((node) => {
      node.checked = false;
      node.isIndeterminate = false;
    });
  }
  removeTag(tag2) {
    this.getFlattedNodes().find((node) => {
      if (arrayEqual(tag2, node.path)) {
        node.checked = false;
        return true;
      }
      return false;
    });
  }
  getFlattedNodes(leafOnly = false) {
    return flatNodes(this.nodes, leafOnly);
  }
  setNodesCheck(nodes) {
    this.getFlattedNodes().forEach((node) => {
      node.checked = false;
      const checkedNode = nodes.find((nodeValue) => arrayEqual(node.path, nodeValue));
      if (checkedNode) {
        const currentNode = this.getNodeByValue(checkedNode);
        currentNode.checked = true;
      }
    });
  }
  getCheckedNodes() {
    return this.getFlattedNodes().filter((node) => node.checked);
  }
  getNodeByValue(value) {
    var _a;
    const nodes = this.getFlattedNodes().filter((node) => arrayEqual(node.path, value));
    return (_a = nodes[0]) != null ? _a : null;
  }
  getNodeById(id) {
    return this.getFlattedNodes().find((node) => node.id === id);
  }
  appendNode(nodeData, parentNode) {
    const node = new Node$1(nodeData, this.config, parentNode);
    const children = parentNode ? parentNode.children : this.nodes;
    children.push(node);
  }
  appendNodes(nodeDataList, parentNode) {
    nodeDataList.forEach((node) => this.appendNode(node, parentNode));
  }
}
var Component$8 = defineComponent({
  name: "Cascader",
  directives: {
    bkTooltips: tooltips
  },
  components: {
    CascaderPanel,
    BkPopover,
    Tag: BkTag
  },
  props: {
    modelValue: PropTypes.arrayOf(PropTypes.oneOfType([q(), String, Number])),
    list: PropTypes.array.def([]),
    placeholder: PropTypes.string.def(""),
    behavior: PropTypes.string.def("normal"),
    filterable: PropTypes.bool.def(false),
    multiple: PropTypes.bool.def(false),
    disabled: PropTypes.bool.def(false),
    clearable: PropTypes.bool.def(true),
    trigger: PropTypes.string.def("click"),
    checkAnyLevel: PropTypes.bool.def(false),
    isRemote: PropTypes.bool.def(false),
    remoteMethod: PropTypes.func,
    showCompleteName: PropTypes.bool.def(true),
    idKey: PropTypes.string.def("id"),
    nameKey: PropTypes.string.def("name"),
    childrenKey: PropTypes.string.def("children"),
    separator: PropTypes.string.def("/"),
    limitOneLine: PropTypes.bool.def(false),
    extCls: PropTypes.string.def(""),
    scrollHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def(216),
    scrollWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).def("auto"),
    collapseTags: {
      type: Boolean,
      default: true
    },
    floatMode: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue", "change", "clear", "toggle", "focus"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("select");
    const {
      separator: separator2,
      multiple
    } = props2;
    const {
      isHover,
      setHover,
      cancelHover
    } = useHover();
    const store = ref(new Store(props2));
    const selectedText = ref("");
    const selectedTags = ref([]);
    const {
      modelValue
    } = toRefs(props2);
    const cascaderPanel = ref();
    const searchKey = ref("");
    const suggestions = ref([]);
    const isFiltering = ref(false);
    const isEdit = ref(false);
    const isFocus = ref(false);
    const checkedValue = computed({
      get: () => modelValue.value,
      set: (value) => {
        emit("update:modelValue", value);
      }
    });
    const popover2 = ref(null);
    const bkCascaderRef = ref(null);
    const inputRef = ref(null);
    const placeholder = computed(() => props2.placeholder ? props2.placeholder : t2.value.pleaseSelect);
    const getShowText = (node) => props2.showCompleteName ? node.pathNames.join(separator2) : node.pathNames[node.pathNames.length - 1];
    const updateSearchKey = () => {
      searchKey.value = selectedText.value;
    };
    const updateValue = (val) => {
      var _a;
      if (multiple) {
        store.value.setNodesCheck(val);
        selectedTags.value = store.value.getCheckedNodes().map((node) => ({
          text: getShowText(node),
          key: node.id
        }));
        selectedText.value = selectedTags.value.map((item) => item.text).join(", ");
        return;
      }
      !props2.checkAnyLevel && ((_a = popover2 == null ? void 0 : popover2.value) == null ? void 0 : _a.hide());
      if (val.length === 0) {
        selectedText.value = "";
      } else {
        const node = store.value.getNodeByValue(val);
        if (!node)
          return;
        selectedText.value = getShowText(node);
      }
      updateSearchKey();
    };
    const handleClear = (e) => {
      e.stopPropagation();
      store.value.clearChecked();
      searchKey.value = "";
      updateValue([]);
      emit("update:modelValue", []);
      emit("clear", JSON.parse(JSON.stringify(props2.modelValue)));
    };
    const removeTag = (value, index2, e) => {
      e.stopPropagation();
      const current = JSON.parse(JSON.stringify(value));
      const tag2 = current.splice(index2, 1)[0];
      isEdit.value = true;
      store.value.removeTag(tag2);
      updateValue(current);
      emit("update:modelValue", store.value.getCheckedNodes().map((node) => node.path));
      setTimeout(() => {
        isEdit.value = isFocus.value;
      });
    };
    const modelValueChangeHandler = (value, oldValue) => {
      var _a;
      updateValue(value);
      emit("update:modelValue", value);
      oldValue !== void 0 && emit("change", value);
      (_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.focus();
    };
    const listChangeHandler = () => {
      store.value = new Store(props2);
      updateValue(props2.modelValue);
    };
    const popoverChangeEmitter = (val) => {
      emit("toggle", val.isShow);
      isEdit.value = val.isShow;
      isFocus.value = val.isShow;
      nextTick(() => {
        var _a;
        val && ((_a = inputRef.value) == null ? void 0 : _a.focus());
      });
      val.isShow && focusEmitter();
      if (!val.isShow) {
        isFiltering.value = false;
      }
    };
    const searchInputHandler = debounce(200, (e) => {
      const target = e.target;
      searchKey.value = target.value;
      if (searchKey.value === "") {
        isFiltering.value = false;
        return;
      }
      isFiltering.value = true;
      const targetNodes = store.value.getFlattedNodes().filter((node) => {
        if (props2.checkAnyLevel) {
          return node.pathNames.join(props2.separator).includes(searchKey.value);
        }
        return node.isLeaf && node.pathNames.join(props2.separator).includes(searchKey.value);
      });
      suggestions.value = targetNodes;
      !(popover2 == null ? void 0 : popover2.value.isShow) && (popover2 == null ? void 0 : popover2.value.show());
    });
    const focusEmitter = () => {
      emit("focus");
    };
    watch(() => props2.modelValue, modelValueChangeHandler, {
      immediate: true
    });
    watch(() => props2.list, listChangeHandler, {
      deep: true,
      immediate: true
    });
    const tagList = computed(() => selectedTags.value.map((item) => item.text));
    const isCollapse = computed(() => props2.collapseTags ? props2.collapseTags && isFocus.value : props2.collapseTags);
    const isEditMode = computed(() => props2.collapseTags ? props2.collapseTags && isEdit.value : props2.collapseTags);
    const {
      overflowTagIndex
    } = useTagsOverflow(bkCascaderRef, isEditMode, tagList);
    return {
      calcuPlaceholder: placeholder,
      bkCascaderRef,
      inputRef,
      overflowTagIndex,
      isCollapse,
      isFocus,
      store,
      updateValue,
      selectedText,
      checkedValue,
      handleClear,
      isHover,
      setHover,
      popover: popover2,
      cancelHover,
      selectedTags,
      removeTag,
      cascaderPanel,
      popoverChangeEmitter,
      searchKey,
      suggestions,
      isFiltering,
      searchInputHandler,
      focusEmitter,
      tagList,
      isEdit
    };
  },
  render() {
    const suffixIcon = () => {
      if (this.clearable && this.isHover && !this.disabled) {
        return createVNode(close$1, {
          "class": resolveClassName("icon-clear-icon"),
          "onClick": this.handleClear
        }, null);
      }
      return createVNode(angleUp, {
        "class": resolveClassName("icon-angle-up")
      }, null);
    };
    this.overflowTagIndex = this.overflowTagIndex === 0 ? 1 : this.overflowTagIndex;
    const collapseTooltip = this.tagList.reduce((acc, cur, curIndex) => {
      if (this.overflowTagIndex !== null && curIndex >= this.overflowTagIndex) {
        acc.push(cur);
      }
      return acc;
    }, []);
    const renderTags = () => {
      if (this.limitOneLine) {
        return createVNode("span", {
          "class": "cascader-selected-text"
        }, [this.selectedText]);
      }
      return createVNode("div", {
        "class": "cascader-tag-list"
      }, [this.tagList.map((tag2, index2) => {
        const isOverflow = !this.isCollapse && this.overflowTagIndex !== null && index2 >= this.overflowTagIndex;
        return createVNode("span", {
          "class": "tag-item",
          "style": {
            display: isOverflow ? "none" : ""
          },
          "key": tag2
        }, [createVNode("span", {
          "class": "tag-item-name"
        }, [tag2]), createVNode(error, {
          "class": resolveClassName("icon-clear-icon"),
          "onClick": (e) => {
            e.stopPropagation();
            this.removeTag(this.modelValue, index2, e);
          }
        }, null)]);
      }), this.overflowTagIndex !== null && !this.isCollapse && withDirectives(createVNode(BkTag, {
        "style": "margin-top: 0"
      }, {
        default: () => [createTextVNode("+"), this.selectedTags.length - this.overflowTagIndex]
      }), [[resolveDirective("bk-tooltips"), collapseTooltip.join(", ")]])]);
    };
    const textRender = () => this.multiple ? null : createVNode("span", null, [this.selectedText]);
    const popoverRender = () => createVNode(BkPopover, {
      "placement": "bottom-start",
      "theme": `light ${resolveClassName("cascader-popover")}`,
      "trigger": "click",
      "arrow": false,
      "disabled": this.disabled,
      "class": resolveClassName("cascader-popover-wrapper"),
      "ref": "popover",
      "onAfterHidden": this.popoverChangeEmitter,
      "onAfterShow": this.popoverChangeEmitter,
      "boundary": "body"
    }, {
      default: () => this.$slots.trigger ? this.$slots.trigger({
        selected: this.modelValue
      }) : createVNode("div", {
        "class": [resolveClassName("cascader-name"), "lesscode-bk-scroll-y"]
      }, [this.multiple && this.selectedTags.length > 0 && renderTags(), this.filterable ? (this.isCollapse || this.selectedTags.length === 0) && createVNode("input", {
        "class": [resolveClassName("cascader-search-input"), {
          "is-disabled": this.disabled
        }],
        "type": "text",
        "onInput": this.searchInputHandler,
        "placeholder": this.calcuPlaceholder,
        "value": this.searchKey,
        "disabled": this.disabled,
        "ref": "inputRef"
      }, null) : textRender()]),
      content: () => createVNode("div", {
        "class": resolveClassName("cascader-popover")
      }, [createVNode(CascaderPanel, {
        "store": this.store,
        "ref": "cascaderPanel",
        "width": this.scrollWidth,
        "height": this.scrollHeight,
        "search-key": this.searchKey,
        "separator": this.separator,
        "is-filtering": this.isFiltering,
        "suggestions": this.suggestions,
        "modelValue": this.checkedValue,
        "onUpdate:modelValue": ($event) => this.checkedValue = $event
      }, {
        default: (scope) => this.$slots.default ? this.$slots.default(scope) : createVNode("span", {
          "class": resolveClassName("cascader-node-name")
        }, [scope.node.name])
      })])
    });
    return createVNode("div", {
      "class": [resolveClassName("cascader-wrapper"), this.floatMode ? "float-mode" : ""]
    }, [this.$slots.trigger ? popoverRender() : createVNode("div", {
      "class": [resolveClassName("cascader"), this.extCls, {
        "is-unselected": this.modelValue.length === 0,
        "is-hover": this.isHover,
        "is-filterable": this.filterable,
        "is-focus": this.isFocus,
        "is-disabled": this.disabled,
        "is-simplicity": this.behavior === "simplicity"
      }],
      "tabindex": "0",
      "data-placeholder": this.calcuPlaceholder,
      "onMouseenter": this.setHover,
      "onMouseleave": this.cancelHover,
      "ref": "bkCascaderRef"
    }, [suffixIcon(), popoverRender()])]);
  }
});
const BkCascader = withInstallProps(Component$8, { CascaderPanel });
var SliderButton = defineComponent({
  name: "SliderButton",
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    params: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["emitChange", "resetSize", "update:modelValue"],
  setup(props2, {
    emit
  }) {
    const dragging = ref(false);
    const isClick = ref(false);
    const startY = ref(0);
    const startX = ref(0);
    const startPosition = ref(0);
    const newPosition = ref(null);
    const oldValue = ref(props2.modelValue);
    const currentY = ref(0);
    const currentX = ref(0);
    const isMove = ref(false);
    const button2 = ref(null);
    const tip = computed(() => {
      var _a, _b;
      let tip2 = "";
      if ((_a = props2.params.customContent) == null ? void 0 : _a[props2.modelValue]) {
        const customContent = props2.params.customContent[props2.modelValue];
        tip2 = customContent.tip || customContent.label || "";
      }
      const placement = props2.params.vertical ? PlacementEnum.RIGHT : PlacementEnum.TOP;
      if ((_b = props2.params) == null ? void 0 : _b.showTip) {
        return {
          content: props2.params.formatterTipLabel(`${tip2 || (props2 == null ? void 0 : props2.modelValue) || "0"}`),
          placement
        };
      }
      return {
        content: "",
        placement
      };
    });
    const currentPosition = computed(() => `${(props2.modelValue - props2.params.minValue) / (props2.params.maxValue - props2.params.minValue) * 100}%`);
    const wrapperStyle = computed(() => props2.params.vertical ? {
      bottom: currentPosition.value
    } : {
      left: currentPosition.value
    });
    const buttonLabel = computed(() => props2.params.formatterButtonLabel(props2.modelValue));
    const onButtonDown = (event) => {
      if (props2.params.disable)
        return;
      event.preventDefault();
      onDragStart(event);
      on(window, "mousemove", onDragging);
      on(window, "touchmove", onDragging);
      on(window, "mouseup", onDragEnd);
      on(window, "touchend", onDragEnd);
    };
    const onDragStart = (event) => {
      dragging.value = true;
      isClick.value = true;
      if (props2.params.vertical) {
        startY.value = event.clientY;
      } else {
        startX.value = event.clientX;
      }
      startPosition.value = parseFloat(currentPosition.value);
      newPosition.value = startPosition.value;
    };
    const onDragging = (event) => {
      if (dragging.value) {
        isClick.value = false;
        emit("resetSize");
        let diff3 = 0;
        if (props2.params.vertical) {
          currentY.value = event.clientY;
          diff3 = (startY.value - currentY.value) / props2.params.sliderSize * 100;
        } else {
          currentX.value = event.clientX;
          diff3 = (currentX.value - startX.value) / props2.params.sliderSize * 100;
        }
        newPosition.value = startPosition.value + diff3;
        setPosition(newPosition.value);
      }
    };
    const onDragEnd = () => {
      isMove.value = false;
      if (dragging.value) {
        setTimeout(() => {
          dragging.value = false;
          if (!isClick.value) {
            setPosition(newPosition.value);
            emit("emitChange");
          }
        }, 0);
        off(window, "mousemove", onDragging);
        off(window, "touchmove", onDragging);
        off(window, "mouseup", onDragEnd);
        off(window, "touchend", onDragEnd);
      }
    };
    const setPosition = (position) => {
      if (position === null || isNaN(position))
        return;
      if (position < 0) {
        newPosition.value = 0;
      } else if (position > 100) {
        newPosition.value = 100;
      }
      const lengthPerStep = 100 / ((props2.params.maxValue - props2.params.minValue) / props2.params.step);
      const steps2 = Math.round(position / lengthPerStep);
      let value = steps2 * lengthPerStep * (props2.params.maxValue - props2.params.minValue) * 0.01 + props2.params.minValue;
      value = parseFloat(value.toFixed(props2.params.precision));
      emit("update:modelValue", value);
      if (!dragging.value && props2.modelValue !== oldValue.value) {
        oldValue.value = props2.modelValue;
      }
    };
    const renderDom = () => createVNode("div", {
      "class": ["lesscode-bk-slider-button", props2.params.vertical ? "vertical" : "horizontal", {
        grabbing: dragging.value
      }],
      "ref": button2,
      "tabindex": "0",
      "style": wrapperStyle.value,
      "onClick": (event) => event.stopPropagation(),
      "onMousedown": onButtonDown
    }, [Boolean(tip.value.content) ? createVNode(BkPopover, {
      "content": tip.value.content,
      "theme": "dark",
      "placement": tip.value.placement,
      "boundary": document.body
    }, {
      default: () => [createVNode("div", {
        "class": ["slider-button", {
          "slider-button-disable": props2.params.disable
        }]
      }, null)]
    }) : createVNode("div", {
      "class": ["slider-button", {
        "slider-button-disable": props2.params.disable
      }]
    }, null), props2.params.showButtonLabel && !props2.params.showIntervalLabel ? createVNode("div", {
      "class": ["slider-button-label", props2.params.vertical ? "vertical" : "horizontal"]
    }, [buttonLabel.value]) : void 0]);
    return {
      renderDom,
      setPosition,
      tip
    };
  },
  render() {
    return this.renderDom();
  }
});
const on = (element, event, handler) => {
  if (element && event && handler) {
    element.addEventListener(event, handler, false);
  }
};
const off = (element, event, handler) => {
  if (element && event && handler) {
    element.removeEventListener(event, handler, false);
  }
};
var Component$7 = defineComponent({
  name: "Slider",
  props: {
    modelValue: PropTypes.oneOfType([PropTypes.array, PropTypes.number]),
    extCls: {
      type: String,
      default: ""
    },
    vertical: {
      type: Boolean,
      default: false
    },
    height: {
      type: String,
      default: "200px"
    },
    disable: {
      type: Boolean,
      default: false
    },
    showTip: {
      type: Boolean,
      default: false
    },
    maxValue: {
      type: [Number],
      default: 100
    },
    minValue: {
      type: [Number],
      default: 0
    },
    step: {
      type: [Number],
      default: 1
    },
    range: {
      type: Boolean,
      default: false
    },
    showInterval: {
      type: Boolean,
      default: false
    },
    showIntervalLabel: {
      type: Boolean,
      default: false
    },
    showButtonLabel: {
      type: Boolean,
      default: false
    },
    showBetweenLabel: {
      type: Boolean,
      default: false
    },
    showInput: {
      type: Boolean,
      default: false
    },
    customContent: {
      type: Object,
      default: null
    },
    formatterLabel: {
      type: Function,
      default: (value) => value
    },
    formatterButtonLabel: {
      type: Function,
      default: (value) => value
    },
    formatterTipLabel: {
      type: Function,
      default: (value) => value
    }
  },
  emits: ["update:modelValue", "change"],
  setup(props2, {
    slots,
    emit
  }) {
    const sliderSize = ref(1);
    const firstValue = ref(null);
    const secondValue = ref(null);
    const oldValue = ref(null);
    const firstInput = ref(0);
    const secondInput = ref(0);
    const slider2 = ref(null);
    const firstbutton = ref(null);
    const secondbutton = ref(null);
    const curButtonRef = ref(null);
    const precision = computed(() => {
      const precisions = [props2.minValue, props2.maxValue, props2.step].map((item) => {
        const decimal = `${item}`.split(".")[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max.apply(null, precisions);
    });
    const rangeMinValue = computed(() => Math.min(firstValue.value, secondValue.value));
    const rangeMaxValue = computed(() => Math.max(firstValue.value, secondValue.value));
    const barSize = computed(() => props2.range ? `${100 * (rangeMaxValue.value - rangeMinValue.value) / (props2.maxValue - props2.minValue)}%` : `${100 * (firstValue.value - props2.minValue) / (props2.maxValue - props2.minValue)}%`);
    const barStart = computed(() => props2.range ? `${100 * (rangeMinValue.value - props2.minValue) / (props2.maxValue - props2.minValue)}%` : "0%");
    const barStyle = computed(() => props2.vertical ? {
      height: barSize.value,
      bottom: barStart.value
    } : {
      width: barSize.value,
      left: barStart.value
    });
    const intervals = computed(() => {
      if (!props2.showInterval || props2.minValue > props2.maxValue)
        return [];
      if (props2.step === 0) {
        console.warn("WARNNING:step should not be 0");
        return [];
      }
      const stopCount = (props2.maxValue - props2.minValue) / props2.step;
      const stepWidth = 100 * props2.step / (props2.maxValue - props2.minValue);
      const result = [];
      for (let i2 = 1; i2 < stopCount; i2++) {
        result.push(i2 * stepWidth);
      }
      if (props2.range) {
        return result.filter((step) => step < 100 * (rangeMinValue.value - props2.minValue) / (props2.maxValue - props2.minValue) || step > 100 * (rangeMaxValue.value - props2.minValue) / (props2.maxValue - props2.minValue));
      }
      return result.filter((step) => step > 100 * (firstValue.value - props2.minValue) / (props2.maxValue - props2.minValue));
    });
    const runwayStyle = computed(() => props2.vertical ? {
      height: props2.height,
      width: "4px"
    } : {});
    const intervalLabels = computed(() => {
      if (!props2.showIntervalLabel)
        return [];
      if (props2.step === 0) {
        console.warn("WARNNING:step should not be 0");
        return [];
      }
      const stepWidth = 100 * props2.step / (props2.maxValue - props2.minValue);
      const result = [];
      for (let i2 = props2.minValue, j2 = 0; i2 <= props2.maxValue; i2 += props2.step, j2++) {
        const item = {
          stepWidth: j2 * stepWidth,
          stepLabel: props2.formatterLabel(i2)
        };
        result.push(item);
      }
      return result;
    });
    const showSecondInput = computed(() => Array.isArray(props2.modelValue));
    const customList = computed(() => {
      if (!props2.customContent) {
        return [];
      }
      return Object.keys(props2.customContent).sort((a2, b2) => Number(a2) - Number(b2)).filter((value) => Number(value) >= props2.minValue && Number(value) <= props2.maxValue).map((item) => {
        const {
          tip
        } = props2.customContent[item];
        const {
          label
        } = props2.customContent[item];
        return {
          tip: tip || label || "",
          label: label || "",
          percent: (Number(item) - props2.minValue) / (props2.maxValue - props2.minValue) * 100
        };
      });
    });
    const buttonParms = computed(() => ({
      vertical: props2.vertical,
      showTip: props2.showTip,
      disable: props2.disable,
      maxValue: props2.maxValue,
      minValue: props2.minValue,
      step: props2.step,
      precision: precision.value,
      showButtonLabel: props2.showButtonLabel,
      formatterButtonLabel: props2.formatterButtonLabel,
      showIntervalLabel: props2.showIntervalLabel,
      customContent: props2.customContent,
      sliderSize: sliderSize.value,
      formatterTipLabel: props2.formatterTipLabel
    }));
    watch(() => props2.modelValue, () => {
      setValues();
    });
    watch(() => firstValue.value, (val) => {
      if (props2.range) {
        emit("update:modelValue", [rangeMinValue.value, rangeMaxValue.value]);
      } else {
        emit("update:modelValue", val);
      }
      firstInput.value = val;
    });
    watch(() => secondValue.value, (val) => {
      emit("update:modelValue", [rangeMinValue.value, rangeMaxValue.value]);
      secondInput.value = val;
    });
    onMounted(() => {
      if (props2.range) {
        if (Array.isArray(props2.modelValue)) {
          firstValue.value = Math.max(props2.minValue, Number(props2.modelValue[0]));
          secondValue.value = Math.min(props2.maxValue, Number(props2.modelValue[1]));
        } else {
          firstValue.value = props2.minValue;
          secondValue.value = props2.maxValue;
        }
        oldValue.value = [firstValue.value, secondValue.value];
      } else {
        if (typeof props2.modelValue !== "number" || isNaN(props2.modelValue)) {
          firstValue.value = props2.minValue;
        } else {
          firstValue.value = Math.min(props2.maxValue, Math.max(props2.minValue, props2.modelValue));
        }
        oldValue.value = firstValue.value;
      }
      resetSize();
      on(window, "resize", resetSize());
    });
    const resetSize = () => {
      if (slider2.value) {
        sliderSize.value = slider2.value[`client${props2.vertical ? "Height" : "Width"}`];
      }
    };
    const setButtonPos = (event) => {
      var _a, _b;
      event.stopPropagation();
      if (props2.disable)
        return;
      resetSize();
      if (props2.vertical) {
        const offsetBottom = (_a = slider2.value) == null ? void 0 : _a.getBoundingClientRect().bottom;
        setPosition((offsetBottom - event.clientY) / sliderSize.value * 100);
      } else {
        const offsetLeft = (_b = slider2.value) == null ? void 0 : _b.getBoundingClientRect().left;
        setPosition((event.clientX - offsetLeft) / sliderSize.value * 100);
      }
      emitChange();
    };
    const valueChanged = () => {
      if (props2.range) {
        return ![rangeMinValue.value, rangeMaxValue.value].every((item, index2) => item === oldValue.value[index2]);
      }
      return props2.modelValue !== oldValue.value;
    };
    const setValues = () => {
      if (props2.minValue > props2.maxValue) {
        console.error("min should not be greater than max.");
        return;
      }
      const val = props2.modelValue;
      if (props2.range && Array.isArray(val)) {
        if (val[1] < props2.minValue) {
          emit("update:modelValue", [props2.minValue, props2.minValue]);
        } else if (val[0] > props2.maxValue) {
          emit("update:modelValue", [props2.maxValue, props2.maxValue]);
        } else if (val[0] < props2.minValue) {
          emit("update:modelValue", [props2.minValue, val[1]]);
        } else if (val[1] > props2.maxValue) {
          emit("update:modelValue", [val[0], props2.maxValue]);
        } else {
          firstValue.value = Number(val[0]);
          secondValue.value = Number(val[1]);
          if (valueChanged()) {
            oldValue.value = val.slice();
          }
        }
      } else if (!props2.range && typeof val === "number" && !isNaN(val)) {
        if (val < props2.minValue) {
          emit("update:modelValue", props2.minValue);
        } else if (val > props2.maxValue) {
          emit("update:modelValue", props2.maxValue);
        } else {
          firstValue.value = val;
          if (valueChanged()) {
            oldValue.value = val;
          }
        }
      }
    };
    const emitChange = async () => {
      await nextTick();
      emit("change", props2.range ? [rangeMinValue.value, rangeMaxValue.value] : props2.modelValue);
    };
    const getIntervalStyle = (position) => props2.vertical ? {
      bottom: `${position}%`
    } : {
      left: `${position}%`
    };
    const setPosition = (percent) => {
      if (!props2.range) {
        firstbutton.value.setPosition(percent);
        return;
      }
      const targetValue = props2.minValue + percent * (props2.maxValue - props2.minValue) / 100;
      if (Math.abs(rangeMinValue.value - targetValue) < Math.abs(rangeMaxValue.value - targetValue)) {
        curButtonRef.value = firstValue.value < secondValue.value ? firstbutton.value : secondbutton.value;
      } else {
        curButtonRef.value = firstValue.value > secondValue.value ? firstbutton.value : secondbutton.value;
      }
      curButtonRef.value.setPosition(percent);
    };
    const firstInputChange = (v2) => {
      if (v2 === "") {
        return;
      }
      const val = parseFloat(v2);
      if (val < props2.minValue) {
        firstInput.value = props2.minValue;
        firstValue.value = props2.minValue;
      } else if (val > props2.maxValue) {
        firstInput.value = props2.maxValue;
        firstValue.value = props2.maxValue;
      } else {
        firstValue.value = val;
      }
    };
    const secondInputChange = (v2) => {
      if (v2 === "" || typeof v2 === "number") {
        return;
      }
      const val = parseFloat(v2);
      if (val < props2.minValue) {
        secondInput.value = props2.minValue;
        secondValue.value = props2.minValue;
      } else if (val > props2.maxValue) {
        secondInput.value = props2.maxValue;
        secondValue.value = props2.maxValue;
      } else {
        secondValue.value = val;
      }
    };
    const betweenLabelStyle = (postion) => {
      let value = 0;
      if (postion === "start") {
        value = props2.vertical ? props2.maxValue : props2.minValue;
      } else {
        value = props2.vertical ? props2.minValue : props2.maxValue;
      }
      if (props2.showButtonLabel && [firstValue.value, secondValue.value].includes(value)) {
        return "0";
      }
      return "1";
    };
    const renderDom = () => {
      var _a, _b;
      return createVNode("div", {
        "class": ["lesscode-bk-slider", props2.extCls]
      }, [(_a = slots.start) == null ? void 0 : _a.call(slots), createVNode("div", {
        "class": "lesscode-bk-slider-runway",
        "ref": slider2,
        "style": runwayStyle.value,
        "onClick": setButtonPos
      }, [createVNode("div", {
        "class": ["lesscode-bk-slider-bar", props2.vertical ? "vertical" : "horizontal", {
          disable: props2.disable
        }],
        "style": barStyle.value
      }, null), props2.showInterval ? intervals.value.map((interval, index2) => createVNode("div", {
        "key": index2,
        "class": ["lesscode-bk-slider-interval", {
          vertical: props2.vertical
        }],
        "style": getIntervalStyle(interval)
      }, null)) : void 0, props2.customContent ? customList.value.map((custom, index2) => createVNode("div", {
        "key": index2,
        "class": ["lesscode-bk-slider-interval", {
          vertical: props2.vertical
        }],
        "style": getIntervalStyle(custom.percent)
      }, null)) : void 0, props2.showBetweenLabel || props2.showIntervalLabel || props2.customContent ? createVNode("div", {
        "class": ["lesscode-bk-slider-labels", props2.vertical ? "vertical" : "horizontal"]
      }, [function() {
        if (props2.showBetweenLabel) {
          return [createVNode("div", {
            "class": "label-start",
            "style": [{
              opacity: betweenLabelStyle("start")
            }]
          }, [props2.formatterLabel(props2.minValue)]), createVNode("div", {
            "class": "label-end",
            "style": [{
              opacity: betweenLabelStyle("end")
            }]
          }, [props2.formatterLabel(props2.maxValue)])];
        }
        if (props2.showIntervalLabel) {
          return intervalLabels.value.map((intervalLabel, index2) => createVNode("div", {
            "class": ["lesscode-bk-slider-label", props2.vertical ? "vertical" : "horizontal"],
            "key": index2,
            "style": getIntervalStyle(intervalLabel.stepWidth)
          }, [intervalLabel.stepLabel]));
        }
        if (props2.customContent) {
          return customList.value.map((item, index2) => createVNode("div", {
            "class": ["lesscode-bk-slider-label", props2.vertical ? "vertical" : "horizontal"],
            "key": index2,
            "style": getIntervalStyle(item.percent)
          }, [item.label]));
        }
        return void 0;
      }()]) : void 0, createVNode(SliderButton, {
        "modelValue": firstValue.value,
        "onUpdate:modelValue": ($event) => firstValue.value = $event,
        "ref": firstbutton,
        "params": buttonParms.value,
        "onEmitChange": emitChange,
        "onResetSize": resetSize
      }, null), props2.range ? createVNode(SliderButton, {
        "modelValue": secondValue.value,
        "onUpdate:modelValue": ($event) => secondValue.value = $event,
        "ref": secondbutton,
        "params": buttonParms.value,
        "onEmitChange": emitChange,
        "onResetSize": resetSize
      }, null) : void 0]), props2.showInput && !props2.vertical ? createVNode("div", {
        "class": "lesscode-bk-slider-input"
      }, [createVNode("div", {
        "class": "input-item"
      }, [createVNode(BkInput, {
        "type": "number",
        "modelValue": firstInput.value,
        "max": props2.maxValue,
        "min": props2.minValue,
        "onChange": firstInputChange
      }, null)]), showSecondInput.value && secondValue.value ? [createVNode("div", {
        "class": "input-center"
      }, [createTextVNode("\uFF5E")]), createVNode("div", {
        "class": "input-item"
      }, [createVNode(BkInput, {
        "type": "number",
        "modelValue": secondInput.value,
        "max": props2.maxValue,
        "min": props2.minValue,
        "onChange": secondInputChange
      }, null)])] : void 0]) : void 0, (_b = slots.end) == null ? void 0 : _b.call(slots)]);
    };
    return {
      renderDom
    };
  },
  render() {
    return this.renderDom();
  }
});
const Slider = withInstall(Component$7);
var Component$6 = defineComponent({
  name: "ResizeLayout",
  props: {
    placement: PropTypes.placement().def("left"),
    min: PropTypes.number.def(3),
    max: PropTypes.number.def(Infinity),
    triggerWidth: PropTypes.number.def(5),
    triggerOffset: PropTypes.number.def(3),
    initialDivide: PropTypes.oneOfType([String, Number]).def("20%"),
    immediate: PropTypes.bool,
    disabled: PropTypes.bool,
    collapsible: PropTypes.bool,
    autoMinimize: PropTypes.oneOfType([Boolean, Number]).def(false),
    border: PropTypes.bool.def(true)
  },
  emits: ["before-resize", "resizing", "after-resize", "collapse-change"],
  setup(props2, {
    emit
  }) {
    const {
      placement,
      initialDivide,
      triggerOffset,
      triggerWidth,
      max: max2,
      min: min2,
      immediate,
      autoMinimize
    } = toRefs(props2);
    const collapsed = ref(false);
    const asideContentVisible = ref(true);
    const minimized = ref(false);
    const limitMax = ref(null);
    const state = ref({});
    const bkResizeLayoutRef = ref(null);
    const resizeProxyRef = ref(null);
    const resizeMaskRef = ref(null);
    const asideRef = ref(null);
    const vertical = computed(() => ["left", "right"].includes(placement.value));
    const cssPropKey = computed(() => vertical.value ? "width" : "height");
    const asideStyle = computed(() => {
      let divide = initialDivide.value;
      if (typeof divide === "number") {
        divide = `${divide}px`;
      }
      return {
        [cssPropKey.value]: divide
      };
    });
    const triggerStyle = computed(() => {
      const style2 = {
        [`margin-${placement.value}`]: `${triggerOffset.value - triggerWidth.value}px`,
        [cssPropKey.value]: `${triggerWidth.value}px`
      };
      return style2;
    });
    const parseAutoMinimize = computed(() => {
      if (autoMinimize.value) {
        return typeof autoMinimize.value === "boolean" ? 50 : autoMinimize.value;
      }
      return 0;
    });
    const setMaxLimit = () => {
      const rect = bkResizeLayoutRef.value.getBoundingClientRect();
      limitMax.value = vertical.value ? rect.width : rect.height;
    };
    const observer = new ResizeObserver(setMaxLimit);
    const updateResizeProxyStyle = () => {
      resizeProxyRef.value.style.visibility = "visible";
      switch (placement.value) {
        case "left":
          resizeProxyRef.value.style.inset = `0 auto auto ${state.value.aside.width}px`;
          break;
        case "right":
          resizeProxyRef.value.style.inset = `0  ${state.value.aside.width}px auto auto`;
          break;
        case "top":
          resizeProxyRef.value.style.inset = `${state.value.aside.height}px auto auto 0`;
          break;
        case "bottom":
          resizeProxyRef.value.style.inset = `auto auto ${state.value.aside.height}px 0`;
          break;
      }
    };
    const updateResizeMaskStyle = () => {
      resizeMaskRef.value.style.display = "block";
      resizeMaskRef.value.style.cursor = vertical.value ? "col-resize" : "row-resize";
    };
    const getRealValue = (current) => Math.min(max2.value, Math.max(min2.value, current), limitMax.value - triggerWidth.value);
    const handleMousedown = (event) => {
      emit("before-resize", event);
      const asideRect = asideRef.value.getBoundingClientRect();
      state.value = Object.freeze({
        mouse: {
          clientX: event.clientX,
          clientY: event.clientY
        },
        aside: {
          width: asideRect.width,
          height: asideRect.height
        }
      });
      updateResizeMaskStyle();
      if (!immediate.value) {
        updateResizeProxyStyle();
      }
      document.onselectstart = () => false;
      document.ondragstart = () => false;
      const resizingCallback = (value) => {
        emit("resizing", value);
      };
      const handleMouseMove = (event2) => {
        let delta;
        switch (placement.value) {
          case "top":
            delta = event2.clientY - state.value.mouse.clientY;
            break;
          case "right":
            delta = state.value.mouse.clientX - event2.clientX;
            break;
          case "bottom":
            delta = state.value.mouse.clientY - event2.clientY;
            break;
          case "left":
            delta = event2.clientX - state.value.mouse.clientX;
        }
        const current = state.value.aside[cssPropKey.value] + delta;
        const realValue = getRealValue(current) + triggerOffset.value;
        const pixel = `${realValue}px`;
        if (immediate.value) {
          asideRef.value.style[cssPropKey.value] = pixel;
        } else {
          resizeProxyRef.value.style[placement.value] = pixel;
        }
        resizingCallback(realValue);
      };
      const handleMouseUp = () => {
        resizeProxyRef.value.style.visibility = "hidden";
        resizeMaskRef.value.style.display = "none";
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
        document.onselectstart = null;
        document.ondragstart = null;
        nextTick(() => {
          setupAutoMinimize();
          emit("after-resize", parseFloat(resizeProxyRef.value.style[placement.value]));
        });
        if (immediate.value) {
          return false;
        }
        asideRef.value.style[cssPropKey.value] = resizeProxyRef.value.style[placement.value];
      };
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    };
    const setupAutoMinimize = () => {
      if (!autoMinimize.value) {
        return false;
      }
      const asideRect = asideRef.value.getBoundingClientRect();
      minimized.value = collapsed.value = asideRect[cssPropKey.value] <= parseAutoMinimize.value;
      if (!minimized.value) {
        asideContentVisible.value = true;
        return false;
      }
      setupAsideAnimation();
      nextTick(() => {
        asideRef.value.setAttribute(`data-${cssPropKey.value}`, asideStyle.value[cssPropKey.value]);
      });
    };
    const setCollapse = (collapse2) => {
      collapsed.value = typeof collapse2 === "boolean" ? collapse2 : !collapsed.value;
      setupAsideAnimation();
      emit("collapse-change", collapsed.value);
    };
    const setupAsideAnimation = () => {
      const asideRect = asideRef.value.getBoundingClientRect();
      setupAsideListener(!collapsed.value);
      if (collapsed.value) {
        asideRef.value.setAttribute(`data-${cssPropKey.value}`, `${asideRect[cssPropKey.value]}px`);
        asideRef.value.style[cssPropKey.value] = props2.collapsible ? "0px" : "5px";
      } else {
        asideContentVisible.value = true;
        asideRef.value.style[cssPropKey.value] = asideRef.value.getAttribute(`data-${cssPropKey.value}`);
      }
    };
    const setupAsideListener = (visible) => {
      const removeClass2 = () => {
        asideContentVisible.value = visible;
        asideRef.value.style.transition = "";
        asideRef.value.removeEventListener("transitionend", removeClass2);
      };
      asideRef.value.addEventListener("transitionend", removeClass2);
      asideRef.value.style.transition = `${cssPropKey.value} cubic-bezier(0.4, 0, 0.2, 1) .3s`;
    };
    onMounted(() => {
      observer.observe(bkResizeLayoutRef.value);
    });
    onBeforeUnmount(() => {
      observer.unobserve(bkResizeLayoutRef.value);
    });
    return {
      collapsed,
      asideContentVisible,
      minimized,
      limitMax,
      state,
      vertical,
      cssPropKey,
      bkResizeLayoutRef,
      resizeProxyRef,
      resizeMaskRef,
      asideRef,
      triggerStyle,
      asideStyle,
      handleMousedown,
      setCollapse
    };
  },
  render() {
    var _a, _b, _c, _d, _e, _f;
    const bkResizeLayoutClass = ["lesscode-bk-resize-layout", `lesscode-bk-resize-layout-${this.placement}`, {
      "lesscode-bk-resize-layout-collapsed": this.collapsed,
      "lesscode-bk-resize-layout-border": this.border,
      "lesscode-bk-resize-layout-collapsible": this.collapsible
    }];
    return createVNode("div", {
      "ref": "bkResizeLayoutRef",
      "class": bkResizeLayoutClass
    }, [createVNode("aside", {
      "class": "lesscode-bk-resize-layout-aside",
      "ref": "asideRef",
      "style": this.asideStyle
    }, [withDirectives(createVNode("div", {
      "class": "lesscode-bk-resize-layout-aside-content"
    }, [(_b = (_a = this.$slots).aside) == null ? void 0 : _b.call(_a)]), [[vShow, this.asideContentVisible]]), withDirectives(createVNode("i", {
      "class": "lesscode-bk-resize-trigger",
      "style": this.triggerStyle,
      "onMousedown": withModifiers(this.handleMousedown, ["left"])
    }, null), [[vShow, !this.disabled && (!this.collapsed || this.autoMinimize)]]), withDirectives(createVNode("i", {
      "class": ["lesscode-bk-resize-proxy", this.placement],
      "ref": "resizeProxyRef"
    }, null), [[vShow, !this.collapsed || this.autoMinimize]]), this.collapsible && (((_d = (_c = this.$slots)["collapse-trigger"]) == null ? void 0 : _d.call(_c)) || (this.collapsed ? createVNode(angleRight, {
      "class": "lesscode-bk-resize-collapse",
      "onClick": this.setCollapse
    }, null) : createVNode(angleLeft, {
      "class": "lesscode-bk-resize-collapse",
      "onClick": this.setCollapse
    }, null)))]), createVNode("main", {
      "class": "lesscode-bk-resize-layout-main"
    }, [(_f = (_e = this.$slots).main) == null ? void 0 : _f.call(_e)]), createVNode("div", {
      "class": "lesscode-bk-resize-mask",
      "ref": "resizeMaskRef"
    }, null)]);
  }
});
const BkResizeLayout = withInstall(Component$6);
const timelineProps = {
  list: PropTypes.array.def([]),
  titleAble: PropTypes.bool.def(false),
  extCls: PropTypes.string
};
var Component$5 = defineComponent({
  name: "Timeline",
  props: timelineProps,
  emits: ["select"],
  setup(props2, {
    emit
  }) {
    const defaultTimelines = ref([]);
    const updateTimelines = (timelines) => {
      const defaults = [];
      timelines.forEach((timeline2) => {
        var _a;
        defaults.push({
          tag: timeline2.tag,
          content: timeline2.content,
          type: timeline2.type,
          size: timeline2.size,
          color: timeline2.color,
          icon: timeline2.icon,
          filled: timeline2.filled,
          border: (_a = timeline2.border) != null ? _a : true
        });
      });
      defaultTimelines.value.splice(0, defaultTimelines.value.length, ...defaults);
    };
    const init = () => {
      var _a;
      defaultTimelines.value.splice(0, defaultTimelines.value.length, ...[{
        tag: "\u6B65\u9AA41",
        content: "\u5185\u5BB91"
      }, {
        tag: "\u6B65\u9AA42",
        content: "\u5185\u5BB92"
      }, {
        tag: "\u6B65\u9AA43",
        content: "\u5185\u5BB93"
      }]);
      if ((_a = props2.list) == null ? void 0 : _a.length) {
        updateTimelines(props2.list);
      }
    };
    const titleSelect = (item) => {
      try {
        emit("select", item);
      } catch (e) {
        console.warn(e);
      }
    };
    onMounted(init);
    watch(() => props2.list, () => {
      updateTimelines(props2.list);
    }, {
      deep: true
    });
    return {
      defaultTimelines,
      titleSelect
    };
  },
  render() {
    const isIcon = (timeline2) => {
      const {
        icon
      } = timeline2;
      if (icon) {
        return typeof icon === "object" || typeof icon === "function";
      }
      return false;
    };
    const makeClass = (item) => {
      const timelineClsPrefix = "lesscode-bk-timeline";
      const dotColors = ["blue", "red", "green", "yellow", "gray"];
      const timelineThemeCls = item.type ? `${timelineClsPrefix}-${item.type}` : `${timelineClsPrefix}-default`;
      const timelineSizeCls = item.size ? `${timelineClsPrefix}-${item.size}` : "";
      const timelineFilledCls = item.filled ? `${timelineClsPrefix}-filled` : "";
      const timelinesColorsCls = item.color && dotColors.includes(item.color) ? `${timelineClsPrefix}-${item.color}` : "";
      const timelineCustomIcon = isIcon(item) ? `${timelineClsPrefix}-custom` : "";
      const timelinesCls = classes({}, `${timelineClsPrefix} ${timelineThemeCls} ${timelineSizeCls} ${timelinesColorsCls} ${timelineFilledCls} ${timelineCustomIcon}`);
      return timelinesCls;
    };
    const getContent = (item) => this.$slots.content ? createVNode("div", {
      "class": "lesscode-bk-timeline-content"
    }, [this.$slots.content(item)]) : createVNode("div", {
      "class": "lesscode-bk-timeline-content",
      "innerHTML": item.content
    }, null);
    return createVNode("ul", {
      "class": ["lesscode-bk-timeline", this.extCls]
    }, [this.defaultTimelines.map((item) => {
      var _a, _b, _c;
      return createVNode("li", {
        "class": ["lesscode-bk-timeline-dot", makeClass(item)]
      }, [isIcon(item) ? createVNode("div", {
        "class": "lesscode-bk-timeline-icon",
        "style": {
          border: item.border ? `2px solid ${item.color}` : "0px",
          borderRadius: item.border ? "50%" : "0"
        }
      }, [createVNode("span", {
        "class": "lesscode-bk-timeline-icon-inner"
      }, [typeof item.icon === "function" ? createVNode(item.icon, null, null) : item.icon])]) : "", createVNode("div", {
        "class": "lesscode-bk-timeline-section"
      }, [createVNode("div", {
        "class": "lesscode-bk-timeline-title",
        "onClick": () => {
          this.titleSelect(item);
        }
      }, [(_c = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, item)) != null ? _c : createVNode("span", {
        "innerHTML": item.tag
      }, null)]), item.content ? getContent(item) : ""])]);
    })]);
  }
});
const BkTimeline = withInstall(Component$5);
const processProps = {
  list: PropTypes.array.def([]),
  controllable: PropTypes.bool.def(false),
  showSteps: PropTypes.bool.def(false),
  curProcess: PropTypes.number.def(0),
  displayKey: PropTypes.string.def("content"),
  extCls: PropTypes.string
};
var Component$4 = defineComponent({
  name: "Process",
  props: processProps,
  emits: ["update:curProcess", "click"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("process");
    const lang = useLocale("lang");
    const defaultProcessList = ref([]);
    const paddingBottom = ref(0);
    const init = () => {
      var _a;
      defaultProcessList.value.splice(0, defaultProcessList.value.length, ...[{
        content: t2.value.step1
      }, {
        content: t2.value.step2
      }, {
        content: t2.value.step3
      }, {
        content: t2.value.step4
      }]);
      if ((_a = props2.list) == null ? void 0 : _a.length) {
        defaultProcessList.value.splice(0, defaultProcessList.value.length, ...props2.list);
      }
    };
    watch(() => lang.value, () => {
      init();
    });
    const jumpTo = async (index2) => {
      try {
        if (props2.controllable && index2 !== props2.curProcess) {
          emit("update:curProcess", index2);
          emit("click", index2);
        }
      } catch (e) {
        console.warn(e);
      }
    };
    onMounted(init);
    return {
      defaultProcessList,
      paddingBottom,
      jumpTo
    };
  },
  render() {
    const processClsPrefix = "lesscode-bk-process";
    const processCls = classes({
      [`${this.extCls}`]: !!this.extCls
    }, `${processClsPrefix}`);
    const isLoadingStatus = (item) => item.status === "loading";
    const isErrorStatus = (item) => item.status === "error";
    const isDone = (index2) => this.curProcess >= index2 + 1 || this.defaultProcessList[index2].status === "done";
    const isIcon = (item) => item.icon ? item.icon : "";
    const renderIcon = (index2, item) => {
      if (index2 === this.curProcess - 1 && isLoadingStatus(item)) {
        return createVNode(circle, {
          "class": "lesscode-bk-icon lesscode-bk-process-icon icon-loading"
        }, null);
      }
      if (index2 === this.curProcess - 1 && isErrorStatus(item)) {
        return createVNode(error, {
          "class": "lesscode-bk-process-icon icon-error"
        }, null);
      }
      if (index2 === this.curProcess - 1 && isIcon(item)) {
        return createVNode("span", {
          "class": "lesscode-bk-process-icon-custom"
        }, [createVNode(item.icon, null, null)]);
      }
      if (isDone(index2)) {
        return createVNode(done, {
          "class": "lesscode-bk-process-icon-done"
        }, null);
      }
    };
    return createVNode("div", {
      "class": processCls
    }, [createVNode("ul", {
      "style": {
        paddingBottom: `${this.paddingBottom}px`
      }
    }, [this.defaultProcessList.map((item, index2) => createVNode("li", {
      "onClick": () => {
        this.jumpTo(index2 + 1);
      },
      "style": {
        cursor: this.controllable ? "pointer" : ""
      },
      "class": {
        success: this.curProcess >= index2 + 1,
        current: isLoadingStatus(item) && index2 === this.curProcess - 1,
        error: isErrorStatus(item) && index2 === this.curProcess - 1
      }
    }, [createVNode("div", null, [createVNode("span", {
      "class": "display"
    }, [item[this.displayKey]]), renderIcon(index2, item)])]))])]);
  }
});
const BkProcess = withInstall(Component$4);
const CLASS_PREFIX = "lesscode-bk-upload";
var EThemes = /* @__PURE__ */ ((EThemes2) => {
  EThemes2["BUTTON"] = "button";
  EThemes2["DRAGGABLE"] = "draggable";
  EThemes2["PICTURE"] = "picture";
  return EThemes2;
})(EThemes || {});
var EUploadStatus = /* @__PURE__ */ ((EUploadStatus2) => {
  EUploadStatus2["NEW"] = "new";
  EUploadStatus2["UPLOADING"] = "uploading";
  EUploadStatus2["SUCCESS"] = "success";
  EUploadStatus2["FAIL"] = "fail";
  return EUploadStatus2;
})(EUploadStatus || {});
const themes$1 = [EThemes.BUTTON, EThemes.DRAGGABLE, EThemes.PICTURE];
var uploadProps = {
  theme: {
    type: String,
    default: "draggable",
    validator: (val) => {
      if (!val || themes$1.includes(val)) {
        return true;
      }
      console.error(`invalid theme, ${val}, the theme must be one of \u3010${themes$1.join(" | ")}\u3011`);
      return false;
    }
  },
  files: {
    type: Array,
    default: () => []
  },
  name: {
    type: String,
    default: "upload_file"
  },
  multiple: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean,
    default: false
  },
  autoUpload: {
    type: Boolean,
    default: true
  },
  accept: {
    type: String
  },
  delayTime: {
    type: Number,
    default: 0
  },
  url: {
    type: String,
    required: false
  },
  method: {
    type: String,
    default: "post"
  },
  size: {
    type: [Number, Object],
    default() {
      return {
        maxFileSize: 5,
        maxImgSize: 1
      };
    }
  },
  handleResCode: {
    type: Function,
    default(res) {
      if (res && res.code === 0) {
        return true;
      }
      return false;
    }
  },
  headers: {
    type: Object,
    default: () => ({})
  },
  header: {
    type: [Array, Object],
    default: () => []
  },
  tip: {
    type: String,
    default: ""
  },
  validateName: {
    type: RegExp
  },
  withCredentials: {
    type: Boolean,
    default: false
  },
  limit: Number,
  data: {
    type: [Array, Object],
    default: () => []
  },
  formDataAttributes: {
    type: [Array, Object],
    default: () => []
  },
  extCls: {
    type: String,
    default: ""
  },
  customRequest: Function,
  beforeUpload: {
    type: Function
  },
  beforeRemove: {
    type: Function
  },
  sliceUpload: {
    type: Boolean,
    default: false
  },
  sliceUrl: {
    type: String,
    default: ""
  },
  mergeUrl: {
    type: String,
    default: ""
  },
  chunkSize: {
    type: Number,
    default: 10
  }
};
function _isSlot(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
var UploadList = defineComponent({
  name: "UploadList",
  props: {
    theme: uploadProps.theme,
    disabled: uploadProps.disabled,
    files: uploadProps.files,
    multiple: uploadProps.multiple
  },
  emits: ["remove", "retry"],
  setup(props2, {
    slots,
    emit
  }) {
    const t2 = useLocale("upload");
    const {
      theme,
      disabled,
      multiple
    } = toRefs(props2);
    const classBlock = `${CLASS_PREFIX}-list`;
    const isPhotowall = computed(() => theme.value === EThemes.PICTURE);
    const isSinglePhoto = computed(() => isPhotowall.value && !multiple.value);
    const classNames = computed(() => classes({
      [classBlock]: true,
      [`${classBlock}--${theme.value}`]: true,
      [`${classBlock}--disabled`]: disabled.value
    }));
    function formatSize(value) {
      const uints = ["Bytes", "KB", "MB", "GB", "TB"];
      const index2 = Math.floor(Math.log(value) / Math.log(1024));
      const size = value / 1024 ** index2;
      return `${size.toFixed(2)}${uints[index2]}`;
    }
    function handleRemove(file, e) {
      emit("remove", file, e);
    }
    function handleRetry(file, e) {
      emit("retry", file, e);
    }
    const Photowall = () => {
      let _slot;
      return createVNode(TransitionGroup, {
        "name": `${classBlock}__item`
      }, _isSlot(_slot = props2.files.map((file) => {
        const classNames2 = classes({
          [`${classBlock}__item`]: true,
          [`${classBlock}__item-picture`]: true,
          [`${classBlock}__item--${file.status}`]: true
        });
        return createVNode("li", {
          "key": file.uid,
          "class": classNames2
        }, [(slots == null ? void 0 : slots.file) ? slots.file({
          file
        }) : PhotoItem(file)]);
      })) ? _slot : {
        default: () => [_slot]
      });
    };
    const PhotoItem = (file) => [withDirectives(createVNode("img", {
      "src": file.url,
      "class": `${classBlock}__picture-item-thumbnail`,
      "alt": ""
    }, null), [[vShow, file.status !== "uploading"]]), createVNode(Fragment, null, [file.status === "uploading" && createVNode(BkProgress, {
      "class": `${classBlock}__picture-item-progress`,
      "type": "circle",
      "color": "#3a84ff",
      "bgColor": "#333",
      "width": 50,
      "titleStyle": {
        color: "#fff"
      },
      "percent": file.percentage
    }, null)]), createVNode(Fragment, null, [!disabled.value && createVNode("div", {
      "class": `${classBlock}__picture-item-actions`
    }, [createVNode(del, {
      "class": "action-icon",
      "onClick": (e) => handleRemove(file, e)
    }, null)])])];
    const Normal = () => {
      let _slot2;
      return createVNode(TransitionGroup, {
        "name": `${classBlock}__item`
      }, _isSlot(_slot2 = props2.files.map((file) => {
        const classNames2 = classes({
          [`${classBlock}__item`]: true,
          [`${classBlock}__item--${file.status}`]: true
        });
        return createVNode("li", {
          "key": file.uid,
          "class": classNames2
        }, [(slots == null ? void 0 : slots.file) ? slots.file({
          file
        }) : NormalItem(file)]);
      })) ? _slot2 : {
        default: () => [_slot2]
      });
    };
    const FileIcon = (file) => {
      var _a;
      const rawType = (_a = file == null ? void 0 : file.raw) == null ? void 0 : _a.type;
      const [type] = (rawType == null ? void 0 : rawType.split("/")) || "";
      const iconMap = {
        text: textFill,
        image: imageFill,
        application: textFill,
        video: videoFill,
        audio: audioFill
      };
      let icon = iconMap[type] || textFill;
      const zipType = ["application/zip", "application/rar", "application/tar", "application/gz", "application/x-gzip"];
      if (zipType.includes(rawType)) {
        icon = archiveFill;
      }
      return h$1(icon, {
        class: `${classBlock}__item-file-icon`
      });
    };
    const NormalItem = (file) => [createVNode("div", {
      "class": `${classBlock}__item-icon`
    }, [file.isPic ? createVNode("img", {
      "src": file.url,
      "class": `${classBlock}__item-thumbnail`,
      "alt": ""
    }, null) : FileIcon(file)]), createVNode("div", {
      "class": `${classBlock}__item-summary`
    }, [createVNode("div", {
      "class": `${classBlock}__item-name`,
      "title": file.name
    }, [file.name]), file.status !== "uploading" && createVNode("div", {
      "class": `${classBlock}__item-message`,
      "title": file.statusText
    }, [file.status === "success" && createVNode(Fragment, null, [createVNode(done, {
      "class": `${classBlock}__item-message-success-icon`
    }, null), file.statusText || t2.value.uploadSuccess]), file.status === "fail" && createVNode(Fragment, null, [file.statusText || t2.value.uploadFailed])]), file.status === "uploading" && createVNode(BkProgress, {
      "class": `${classBlock}__item-progress`,
      "showText": false,
      "percent": file.percentage,
      "size": "small"
    }, null), file.status !== "fail" && createVNode("div", {
      "class": `${classBlock}__item-speed`
    }, [withDirectives(createVNode("span", {
      "class": `${classBlock}__item-speed-size`
    }, [formatSize(file.size)]), [[vShow, file.size]]), withDirectives(createVNode("span", {
      "class": `${classBlock}__item-speed-percentage`
    }, [file.percentage, createTextVNode("%")]), [[vShow, file.status === "uploading"]])]), !disabled.value && createVNode("div", {
      "class": `${classBlock}__item-actions`
    }, [file.status === "fail" && createVNode(rightTurnLine, {
      "class": `${classBlock}__item-retry-icon`,
      "onClick": (e) => handleRetry(file, e)
    }, null), createVNode(del, {
      "class": `${classBlock}__item-del-icon`,
      "onClick": (e) => handleRemove(file, e)
    }, null)])])];
    return () => {
      var _a;
      return createVNode(Fragment, null, [isSinglePhoto.value ? (slots == null ? void 0 : slots.innerTrigger) && (slots == null ? void 0 : slots.innerTrigger((_a = props2.files) == null ? void 0 : _a[0])) : createVNode("ul", {
        "class": classNames.value
      }, [isPhotowall.value ? Photowall() : Normal(), (slots == null ? void 0 : slots.innerTrigger) && (slots == null ? void 0 : slots.innerTrigger())])]);
    };
  }
});
var UploadTrigger = defineComponent({
  name: "UploadTrigger",
  props: {
    theme: uploadProps.theme,
    disabled: uploadProps.disabled,
    multiple: uploadProps.multiple,
    accept: uploadProps.accept,
    file: {
      type: Object
    }
  },
  emits: ["change", "remove"],
  setup(props2, {
    slots,
    emit
  }) {
    const t2 = useLocale("upload");
    const {
      theme,
      disabled,
      file,
      multiple,
      accept
    } = toRefs(props2);
    const classBlock = `${CLASS_PREFIX}-trigger`;
    const isButton = computed(() => theme.value === EThemes.BUTTON);
    const isDrag = computed(() => theme.value === EThemes.DRAGGABLE);
    const isPicture = computed(() => theme.value === EThemes.PICTURE);
    const isSinglePicture = computed(() => isPicture.value && !multiple.value);
    const acceptTypes = computed(() => isPicture.value && !accept.value ? "image/png,image/jpeg,image/jpg" : accept.value);
    const inputEl = ref(null);
    const classNames = computed(() => {
      var _a, _b, _c;
      return classes({
        [classBlock]: true,
        [`${classBlock}--${theme.value}`]: true,
        [`${classBlock}--single-picture`]: isSinglePicture.value,
        [`${classBlock}--has-file`]: (_a = file.value) != null ? _a : false,
        [`${classBlock}--${(_b = file.value) == null ? void 0 : _b.status}`]: (_c = file.value) != null ? _c : false,
        [`${classBlock}--dragover`]: dragover.value,
        [`${classBlock}--disabled`]: disabled.value
      });
    });
    const invoke = () => {
      inputEl.value.value = null;
      inputEl.value.click();
    };
    const handleFileChange = (e) => {
      const {
        files
      } = e.target;
      emit("change", Array.from(files));
    };
    const handleClick = () => {
      if (props2.disabled) {
        return;
      }
      invoke();
    };
    const handleKeydown = (e) => {
      if (e.defaultPrevented || e.target !== e.currentTarget) {
        return;
      }
      if (e.code === "Enter" || e.code === "Space") {
        invoke();
      }
      e.preventDefault();
    };
    function handleRemove(file2, e) {
      emit("remove", file2, e);
      e.stopPropagation();
      e.preventDefault();
    }
    const dragover = ref(false);
    const Dragger = () => {
      const handleDrop = (e) => {
        if (disabled.value) {
          return;
        }
        e.preventDefault();
        dragover.value = false;
        const files = Array.from(e.dataTransfer.files);
        if (!acceptTypes.value) {
          emit("change", files);
          return;
        }
        const filesFiltered = files.filter((file2) => {
          const {
            type,
            name
          } = file2;
          const extension = name.includes(".") ? `.${name.split(".").pop()}` : "";
          const baseType = type.replace(/\/.*$/, "");
          return acceptTypes.value.split(",").map((type2) => type2.trim()).filter((type2) => type2).some((acceptedType) => {
            if (acceptedType.startsWith(".")) {
              return extension === acceptedType;
            }
            if (/\/\*$/.test(acceptedType)) {
              return baseType === acceptedType.replace(/\/\*$/, "");
            }
            if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
              return type === acceptedType;
            }
            return false;
          });
        });
        emit("change", filesFiltered);
      };
      const handleDragover = (e) => {
        e.preventDefault();
        dragover.value = true;
      };
      const handleDragleave = () => {
        dragover.value = false;
      };
      const classNames2 = classes({
        [`${classBlock}__draggable`]: true
      });
      return createVNode("div", {
        "class": classNames2,
        "onDrop": handleDrop,
        "onDragover": handleDragover,
        "onDragleave": handleDragleave
      }, [slots.default ? slots.default() : createVNode(Fragment, null, [createVNode(upload, {
        "class": `${classBlock}__draggable-icon`
      }, null), createVNode("div", {
        "class": `${classBlock}__draggable-text`
      }, [t2.value.drapFileOr, createVNode("span", {
        "class": `${classBlock}__draggable-upload-link`
      }, [t2.value.clickUpload])])])]);
    };
    const Picture = () => createVNode(Fragment, null, [isSinglePicture.value && props2.file ? SinglePicture(props2.file) : DefaultPicture()]);
    const DefaultPicture = () => createVNode(Fragment, null, [slots.default ? slots.default() : createVNode("div", {
      "class": `${classBlock}__picture-inner`
    }, [createVNode(plus, {
      "class": `${classBlock}__picture-icon`
    }, null), createVNode("div", {
      "class": `${classBlock}__picture-text`
    }, [t2.value.clickUpload])])]);
    const SinglePicture = (file2) => [withDirectives(createVNode("img", {
      "src": file2.url,
      "class": `${classBlock}__picture-thumbnail`,
      "alt": ""
    }, null), [[vShow, file2.status !== "uploading"]]), createVNode(Fragment, null, [file2.status === "uploading" && createVNode(BkProgress, {
      "class": `${classBlock}__picture-progress`,
      "type": "circle",
      "color": "#3a84ff",
      "bgColor": "#333",
      "width": 50,
      "titleStyle": {
        color: "#fff"
      },
      "percent": file2.percentage
    }, null)]), createVNode(Fragment, null, [!props2.disabled && createVNode("div", {
      "class": `${classBlock}__picture-actions`
    }, [createVNode(del, {
      "class": "action-icon",
      "onClick": (e) => handleRemove(file2, e)
    }, null)])])];
    const Button = () => createVNode(BkButton, {
      "disabled": disabled.value
    }, {
      default: () => [createVNode(upload, {
        "class": `${classBlock}__button-icon`
      }, null), createVNode("span", {
        "class": `${classBlock}__button-text`
      }, [t2.value.uploadLabel])]
    });
    const Trigger = () => {
      if (isButton.value)
        return Button();
      if (isDrag.value)
        return Dragger();
      if (isPicture.value)
        return Picture();
    };
    return () => {
      var _a;
      return createVNode("div", {
        "class": classNames.value,
        "tabindex": "0",
        "onClick": handleClick,
        "onKeydown": handleKeydown
      }, [slots.trigger ? [slots.trigger(), (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)] : Trigger(), createVNode("input", {
        "ref": inputEl,
        "class": `${classBlock}__input-file`,
        "tabindex": "-1",
        "onChange": handleFileChange,
        "accept": acceptTypes.value,
        "multiple": multiple.value,
        "disabled": disabled.value,
        "type": "file"
      }, null)]);
    };
  }
});
var sparkMd5 = { exports: {} };
(function(module, exports) {
  (function(factory) {
    {
      module.exports = factory();
    }
  })(function(undefined$1) {
    var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    function md5cycle(x2, k2) {
      var a2 = x2[0], b2 = x2[1], c2 = x2[2], d2 = x2[3];
      a2 += (b2 & c2 | ~b2 & d2) + k2[0] - 680876936 | 0;
      a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
      d2 += (a2 & b2 | ~a2 & c2) + k2[1] - 389564586 | 0;
      d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
      c2 += (d2 & a2 | ~d2 & b2) + k2[2] + 606105819 | 0;
      c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
      b2 += (c2 & d2 | ~c2 & a2) + k2[3] - 1044525330 | 0;
      b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
      a2 += (b2 & c2 | ~b2 & d2) + k2[4] - 176418897 | 0;
      a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
      d2 += (a2 & b2 | ~a2 & c2) + k2[5] + 1200080426 | 0;
      d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
      c2 += (d2 & a2 | ~d2 & b2) + k2[6] - 1473231341 | 0;
      c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
      b2 += (c2 & d2 | ~c2 & a2) + k2[7] - 45705983 | 0;
      b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
      a2 += (b2 & c2 | ~b2 & d2) + k2[8] + 1770035416 | 0;
      a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
      d2 += (a2 & b2 | ~a2 & c2) + k2[9] - 1958414417 | 0;
      d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
      c2 += (d2 & a2 | ~d2 & b2) + k2[10] - 42063 | 0;
      c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
      b2 += (c2 & d2 | ~c2 & a2) + k2[11] - 1990404162 | 0;
      b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
      a2 += (b2 & c2 | ~b2 & d2) + k2[12] + 1804603682 | 0;
      a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
      d2 += (a2 & b2 | ~a2 & c2) + k2[13] - 40341101 | 0;
      d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
      c2 += (d2 & a2 | ~d2 & b2) + k2[14] - 1502002290 | 0;
      c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
      b2 += (c2 & d2 | ~c2 & a2) + k2[15] + 1236535329 | 0;
      b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
      a2 += (b2 & d2 | c2 & ~d2) + k2[1] - 165796510 | 0;
      a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
      d2 += (a2 & c2 | b2 & ~c2) + k2[6] - 1069501632 | 0;
      d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
      c2 += (d2 & b2 | a2 & ~b2) + k2[11] + 643717713 | 0;
      c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
      b2 += (c2 & a2 | d2 & ~a2) + k2[0] - 373897302 | 0;
      b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
      a2 += (b2 & d2 | c2 & ~d2) + k2[5] - 701558691 | 0;
      a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
      d2 += (a2 & c2 | b2 & ~c2) + k2[10] + 38016083 | 0;
      d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
      c2 += (d2 & b2 | a2 & ~b2) + k2[15] - 660478335 | 0;
      c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
      b2 += (c2 & a2 | d2 & ~a2) + k2[4] - 405537848 | 0;
      b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
      a2 += (b2 & d2 | c2 & ~d2) + k2[9] + 568446438 | 0;
      a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
      d2 += (a2 & c2 | b2 & ~c2) + k2[14] - 1019803690 | 0;
      d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
      c2 += (d2 & b2 | a2 & ~b2) + k2[3] - 187363961 | 0;
      c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
      b2 += (c2 & a2 | d2 & ~a2) + k2[8] + 1163531501 | 0;
      b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
      a2 += (b2 & d2 | c2 & ~d2) + k2[13] - 1444681467 | 0;
      a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
      d2 += (a2 & c2 | b2 & ~c2) + k2[2] - 51403784 | 0;
      d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
      c2 += (d2 & b2 | a2 & ~b2) + k2[7] + 1735328473 | 0;
      c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
      b2 += (c2 & a2 | d2 & ~a2) + k2[12] - 1926607734 | 0;
      b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
      a2 += (b2 ^ c2 ^ d2) + k2[5] - 378558 | 0;
      a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
      d2 += (a2 ^ b2 ^ c2) + k2[8] - 2022574463 | 0;
      d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
      c2 += (d2 ^ a2 ^ b2) + k2[11] + 1839030562 | 0;
      c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
      b2 += (c2 ^ d2 ^ a2) + k2[14] - 35309556 | 0;
      b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
      a2 += (b2 ^ c2 ^ d2) + k2[1] - 1530992060 | 0;
      a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
      d2 += (a2 ^ b2 ^ c2) + k2[4] + 1272893353 | 0;
      d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
      c2 += (d2 ^ a2 ^ b2) + k2[7] - 155497632 | 0;
      c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
      b2 += (c2 ^ d2 ^ a2) + k2[10] - 1094730640 | 0;
      b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
      a2 += (b2 ^ c2 ^ d2) + k2[13] + 681279174 | 0;
      a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
      d2 += (a2 ^ b2 ^ c2) + k2[0] - 358537222 | 0;
      d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
      c2 += (d2 ^ a2 ^ b2) + k2[3] - 722521979 | 0;
      c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
      b2 += (c2 ^ d2 ^ a2) + k2[6] + 76029189 | 0;
      b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
      a2 += (b2 ^ c2 ^ d2) + k2[9] - 640364487 | 0;
      a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
      d2 += (a2 ^ b2 ^ c2) + k2[12] - 421815835 | 0;
      d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
      c2 += (d2 ^ a2 ^ b2) + k2[15] + 530742520 | 0;
      c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
      b2 += (c2 ^ d2 ^ a2) + k2[2] - 995338651 | 0;
      b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
      a2 += (c2 ^ (b2 | ~d2)) + k2[0] - 198630844 | 0;
      a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
      d2 += (b2 ^ (a2 | ~c2)) + k2[7] + 1126891415 | 0;
      d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
      c2 += (a2 ^ (d2 | ~b2)) + k2[14] - 1416354905 | 0;
      c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
      b2 += (d2 ^ (c2 | ~a2)) + k2[5] - 57434055 | 0;
      b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
      a2 += (c2 ^ (b2 | ~d2)) + k2[12] + 1700485571 | 0;
      a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
      d2 += (b2 ^ (a2 | ~c2)) + k2[3] - 1894986606 | 0;
      d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
      c2 += (a2 ^ (d2 | ~b2)) + k2[10] - 1051523 | 0;
      c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
      b2 += (d2 ^ (c2 | ~a2)) + k2[1] - 2054922799 | 0;
      b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
      a2 += (c2 ^ (b2 | ~d2)) + k2[8] + 1873313359 | 0;
      a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
      d2 += (b2 ^ (a2 | ~c2)) + k2[15] - 30611744 | 0;
      d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
      c2 += (a2 ^ (d2 | ~b2)) + k2[6] - 1560198380 | 0;
      c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
      b2 += (d2 ^ (c2 | ~a2)) + k2[13] + 1309151649 | 0;
      b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
      a2 += (c2 ^ (b2 | ~d2)) + k2[4] - 145523070 | 0;
      a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
      d2 += (b2 ^ (a2 | ~c2)) + k2[11] - 1120210379 | 0;
      d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
      c2 += (a2 ^ (d2 | ~b2)) + k2[2] + 718787259 | 0;
      c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
      b2 += (d2 ^ (c2 | ~a2)) + k2[9] - 343485551 | 0;
      b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
      x2[0] = a2 + x2[0] | 0;
      x2[1] = b2 + x2[1] | 0;
      x2[2] = c2 + x2[2] | 0;
      x2[3] = d2 + x2[3] | 0;
    }
    function md5blk(s2) {
      var md5blks = [], i2;
      for (i2 = 0; i2 < 64; i2 += 4) {
        md5blks[i2 >> 2] = s2.charCodeAt(i2) + (s2.charCodeAt(i2 + 1) << 8) + (s2.charCodeAt(i2 + 2) << 16) + (s2.charCodeAt(i2 + 3) << 24);
      }
      return md5blks;
    }
    function md5blk_array(a2) {
      var md5blks = [], i2;
      for (i2 = 0; i2 < 64; i2 += 4) {
        md5blks[i2 >> 2] = a2[i2] + (a2[i2 + 1] << 8) + (a2[i2 + 2] << 16) + (a2[i2 + 3] << 24);
      }
      return md5blks;
    }
    function md51(s2) {
      var n2 = s2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi;
      for (i2 = 64; i2 <= n2; i2 += 64) {
        md5cycle(state, md5blk(s2.substring(i2 - 64, i2)));
      }
      s2 = s2.substring(i2 - 64);
      length = s2.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i2 = 0; i2 < length; i2 += 1) {
        tail[i2 >> 2] |= s2.charCodeAt(i2) << (i2 % 4 << 3);
      }
      tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
      if (i2 > 55) {
        md5cycle(state, tail);
        for (i2 = 0; i2 < 16; i2 += 1) {
          tail[i2] = 0;
        }
      }
      tmp = n2 * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(state, tail);
      return state;
    }
    function md51_array(a2) {
      var n2 = a2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi;
      for (i2 = 64; i2 <= n2; i2 += 64) {
        md5cycle(state, md5blk_array(a2.subarray(i2 - 64, i2)));
      }
      a2 = i2 - 64 < n2 ? a2.subarray(i2 - 64) : new Uint8Array(0);
      length = a2.length;
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (i2 = 0; i2 < length; i2 += 1) {
        tail[i2 >> 2] |= a2[i2] << (i2 % 4 << 3);
      }
      tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
      if (i2 > 55) {
        md5cycle(state, tail);
        for (i2 = 0; i2 < 16; i2 += 1) {
          tail[i2] = 0;
        }
      }
      tmp = n2 * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(state, tail);
      return state;
    }
    function rhex(n2) {
      var s2 = "", j2;
      for (j2 = 0; j2 < 4; j2 += 1) {
        s2 += hex_chr[n2 >> j2 * 8 + 4 & 15] + hex_chr[n2 >> j2 * 8 & 15];
      }
      return s2;
    }
    function hex(x2) {
      var i2;
      for (i2 = 0; i2 < x2.length; i2 += 1) {
        x2[i2] = rhex(x2[i2]);
      }
      return x2.join("");
    }
    if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592")
      ;
    if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
      (function() {
        function clamp2(val, length) {
          val = val | 0 || 0;
          if (val < 0) {
            return Math.max(val + length, 0);
          }
          return Math.min(val, length);
        }
        ArrayBuffer.prototype.slice = function(from, to) {
          var length = this.byteLength, begin = clamp2(from, length), end2 = length, num, target, targetArray, sourceArray;
          if (to !== undefined$1) {
            end2 = clamp2(to, length);
          }
          if (begin > end2) {
            return new ArrayBuffer(0);
          }
          num = end2 - begin;
          target = new ArrayBuffer(num);
          targetArray = new Uint8Array(target);
          sourceArray = new Uint8Array(this, begin, num);
          targetArray.set(sourceArray);
          return target;
        };
      })();
    }
    function toUtf8(str) {
      if (/[\u0080-\uFFFF]/.test(str)) {
        str = unescape(encodeURIComponent(str));
      }
      return str;
    }
    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
      var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i2;
      for (i2 = 0; i2 < length; i2 += 1) {
        arr[i2] = str.charCodeAt(i2);
      }
      return returnUInt8Array ? arr : buff;
    }
    function arrayBuffer2Utf8Str(buff) {
      return String.fromCharCode.apply(null, new Uint8Array(buff));
    }
    function concatenateArrayBuffers(first, second, returnUInt8Array) {
      var result = new Uint8Array(first.byteLength + second.byteLength);
      result.set(new Uint8Array(first));
      result.set(new Uint8Array(second), first.byteLength);
      return returnUInt8Array ? result : result.buffer;
    }
    function hexToBinaryString(hex2) {
      var bytes = [], length = hex2.length, x2;
      for (x2 = 0; x2 < length - 1; x2 += 2) {
        bytes.push(parseInt(hex2.substr(x2, 2), 16));
      }
      return String.fromCharCode.apply(String, bytes);
    }
    function SparkMD52() {
      this.reset();
    }
    SparkMD52.prototype.append = function(str) {
      this.appendBinary(toUtf8(str));
      return this;
    };
    SparkMD52.prototype.appendBinary = function(contents) {
      this._buff += contents;
      this._length += contents.length;
      var length = this._buff.length, i2;
      for (i2 = 64; i2 <= length; i2 += 64) {
        md5cycle(this._hash, md5blk(this._buff.substring(i2 - 64, i2)));
      }
      this._buff = this._buff.substring(i2 - 64);
      return this;
    };
    SparkMD52.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, i2, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
      for (i2 = 0; i2 < length; i2 += 1) {
        tail[i2 >> 2] |= buff.charCodeAt(i2) << (i2 % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD52.prototype.reset = function() {
      this._buff = "";
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD52.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      };
    };
    SparkMD52.prototype.setState = function(state) {
      this._buff = state.buff;
      this._length = state.length;
      this._hash = state.hash;
      return this;
    };
    SparkMD52.prototype.destroy = function() {
      delete this._hash;
      delete this._buff;
      delete this._length;
    };
    SparkMD52.prototype._finish = function(tail, length) {
      var i2 = length, tmp, lo, hi;
      tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
      if (i2 > 55) {
        md5cycle(this._hash, tail);
        for (i2 = 0; i2 < 16; i2 += 1) {
          tail[i2] = 0;
        }
      }
      tmp = this._length * 8;
      tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
      lo = parseInt(tmp[2], 16);
      hi = parseInt(tmp[1], 16) || 0;
      tail[14] = lo;
      tail[15] = hi;
      md5cycle(this._hash, tail);
    };
    SparkMD52.hash = function(str, raw) {
      return SparkMD52.hashBinary(toUtf8(str), raw);
    };
    SparkMD52.hashBinary = function(content, raw) {
      var hash2 = md51(content), ret = hex(hash2);
      return raw ? hexToBinaryString(ret) : ret;
    };
    SparkMD52.ArrayBuffer = function() {
      this.reset();
    };
    SparkMD52.ArrayBuffer.prototype.append = function(arr) {
      var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i2;
      this._length += arr.byteLength;
      for (i2 = 64; i2 <= length; i2 += 64) {
        md5cycle(this._hash, md5blk_array(buff.subarray(i2 - 64, i2)));
      }
      this._buff = i2 - 64 < length ? new Uint8Array(buff.buffer.slice(i2 - 64)) : new Uint8Array(0);
      return this;
    };
    SparkMD52.ArrayBuffer.prototype.end = function(raw) {
      var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i2, ret;
      for (i2 = 0; i2 < length; i2 += 1) {
        tail[i2 >> 2] |= buff[i2] << (i2 % 4 << 3);
      }
      this._finish(tail, length);
      ret = hex(this._hash);
      if (raw) {
        ret = hexToBinaryString(ret);
      }
      this.reset();
      return ret;
    };
    SparkMD52.ArrayBuffer.prototype.reset = function() {
      this._buff = new Uint8Array(0);
      this._length = 0;
      this._hash = [1732584193, -271733879, -1732584194, 271733878];
      return this;
    };
    SparkMD52.ArrayBuffer.prototype.getState = function() {
      var state = SparkMD52.prototype.getState.call(this);
      state.buff = arrayBuffer2Utf8Str(state.buff);
      return state;
    };
    SparkMD52.ArrayBuffer.prototype.setState = function(state) {
      state.buff = utf8Str2ArrayBuffer(state.buff, true);
      return SparkMD52.prototype.setState.call(this, state);
    };
    SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
    SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
    SparkMD52.ArrayBuffer.hash = function(arr, raw) {
      var hash2 = md51_array(new Uint8Array(arr)), ret = hex(hash2);
      return raw ? hexToBinaryString(ret) : ret;
    };
    return SparkMD52;
  });
})(sparkMd5);
var SparkMD5 = sparkMd5.exports;
function getRes(xhr) {
  const res = xhr.responseText || xhr.response;
  if (!res) {
    return res;
  }
  try {
    return JSON.parse(res);
  } catch {
    return res;
  }
}
const ajaxUpload = (option) => {
  if (typeof XMLHttpRequest === "undefined") {
    throw new Error("XMLHttpRequest is undefined");
  }
  const xhr = new XMLHttpRequest();
  const { action } = option;
  if (xhr.upload) {
    xhr.upload.addEventListener("progress", (event) => {
      const progressEvent = event;
      progressEvent.percent = event.total > 0 ? event.loaded / event.total * 100 : 0;
      option.onProgress(progressEvent);
    });
  }
  const formData = new FormData();
  if (option.data) {
    let appendData = option.data;
    if (!Array.isArray(appendData)) {
      appendData = [appendData];
    }
    appendData.forEach((data2) => {
      for (const [key2, value] of Object.entries(data2)) {
        if (Array.isArray(value))
          formData.append(key2, ...value);
        else
          formData.append(key2, value);
      }
    });
  }
  if (option.formDataAttributes) {
    let appendData = option.formDataAttributes;
    if (!Array.isArray(appendData)) {
      appendData = [appendData];
    }
    appendData.forEach((item) => {
      if (Array.isArray(item.value))
        formData.append(item.name, ...item.value);
      else
        formData.append(item.name, item.value);
    });
  }
  formData.append(option.filename, option.file, option.file.name);
  xhr.addEventListener("error", () => {
    option.onError(new Error("An error occurred during upload"));
  });
  xhr.addEventListener("load", () => {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(new Error("An error occurred during upload"));
    }
    option.onSuccess(getRes(xhr));
  });
  xhr.addEventListener("loadend", () => {
    option.onComplete();
  });
  xhr.open(option.method, action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  if (option.header) {
    if (Array.isArray(option.header)) {
      option.header.forEach((head) => {
        const headerKey = head.name;
        const headerVal = head.value;
        xhr.setRequestHeader(headerKey, headerVal);
      });
    } else {
      const headerKey = option.header.name;
      const headerVal = option.header.value;
      xhr.setRequestHeader(headerKey, headerVal);
    }
  }
  const headers = option.headers || {};
  if (headers instanceof Headers) {
    headers.forEach((value, key2) => xhr.setRequestHeader(key2, value));
  } else {
    for (const [key2, value] of Object.entries(headers)) {
      if (isNullOrUndef(value))
        continue;
      xhr.setRequestHeader(key2, String(value));
    }
  }
  xhr.send(formData);
  return xhr;
};
const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
const ajaxSliceUpload = async (option) => {
  const chunkSize = option.chunkSize * 1024 * 1024;
  const { file } = option;
  if (!file) {
    throw new Error("File not found");
  }
  const blockCount = Math.ceil(file.size / chunkSize);
  const hash2 = await hashFile(file, chunkSize);
  const progressList = [];
  sliceSend(option, file, blockCount, hash2, progressList, chunkSize);
  await Promise.all(progressList).then(() => {
    const data2 = {
      size: file.size,
      name: file.name,
      total: blockCount,
      hash: hash2
    };
    const req = new XMLHttpRequest();
    req.open(option.method, option.mergeUrl, true);
    req.onreadystatechange = () => {
      if (req.readyState === 4) {
        if (req.status < 200 || req.status >= 300) {
          return option.onError(new Error("An error occurred during upload"));
        }
        option.onSuccess(getRes(req));
      }
    };
    req.onloadend = () => {
      option.onComplete();
    };
    req.setRequestHeader("Content-type", "application/JSON");
    req.send(JSON.stringify(data2));
  });
};
const sliceSend = (option, file, blockCount, hash2, progressList, chunkSize) => {
  for (let i2 = 0; i2 < blockCount; i2++) {
    const pooltask = new Promise((resolve, reject) => {
      const start2 = i2 * chunkSize;
      const end2 = Math.min(file.size, start2 + chunkSize);
      const formData = new FormData();
      if (option.data) {
        let appendData = option.data;
        if (!Array.isArray(appendData)) {
          appendData = [appendData];
        }
        appendData.forEach((data2) => {
          for (const [key2, value] of Object.entries(data2)) {
            if (Array.isArray(value))
              formData.append(key2, ...value);
            else
              formData.append(key2, value);
          }
        });
      }
      if (option.formDataAttributes) {
        let appendData = option.formDataAttributes;
        if (!Array.isArray(appendData)) {
          appendData = [appendData];
        }
        appendData.forEach((item) => {
          if (Array.isArray(item.value))
            formData.append(item.name, ...item.value);
          else
            formData.append(item.name, item.value);
        });
      }
      formData.append("file", blobSlice.call(file, start2, end2));
      formData.append("name", file.name);
      formData.append("total", blockCount.toString());
      formData.append("index", i2.toString());
      formData.append("size", file.size.toString());
      formData.append("hash", hash2.toString());
      const xhr = new XMLHttpRequest();
      xhr.onreadystatechange = () => {
        if (xhr.readyState === 4) {
          const res = getRes(xhr);
          if (xhr.status < 200 || xhr.status >= 300) {
            reject(res);
            option.onError(new Error("An error occurred during upload"));
          } else {
            resolve("reponseText");
          }
        }
      };
      xhr.upload.addEventListener("progress", (event) => {
        const progressEvent = event;
        option.onProgress(progressEvent, i2);
      }, false);
      if (option.withCredentials && "withCredentials" in xhr) {
        xhr.withCredentials = true;
      }
      xhr.open(option.method, option.sliceUrl, true);
      if (option.header) {
        if (Array.isArray(option.header)) {
          option.header.forEach((head) => {
            const headerKey = head.name;
            const headerVal = head.value;
            xhr.setRequestHeader(headerKey, headerVal);
          });
        } else {
          const headerKey = option.header.name;
          const headerVal = option.header.value;
          xhr.setRequestHeader(headerKey, headerVal);
        }
      }
      const headers = option.headers || {};
      if (headers instanceof Headers) {
        headers.forEach((value, key2) => xhr.setRequestHeader(key2, value));
      } else {
        for (const [key2, value] of Object.entries(headers)) {
          if (isNullOrUndef(value))
            continue;
          xhr.setRequestHeader(key2, String(value));
        }
      }
      xhr.send(formData);
    });
    progressList.push(pooltask);
  }
};
const hashFile = (file, chunkSize) => new Promise((resolve, reject) => {
  const chunks = Math.ceil(file.size / chunkSize);
  let currentChunk = 0;
  const spark = new SparkMD5.ArrayBuffer();
  const fileReader = new FileReader();
  function loadNext() {
    const start2 = currentChunk * chunkSize;
    const end2 = start2 + chunkSize >= file.size ? file.size : start2 + chunkSize;
    fileReader.readAsArrayBuffer(blobSlice.call(file, start2, end2));
  }
  fileReader.onload = (e) => {
    spark.append(e.target.result);
    currentChunk += 1;
    if (currentChunk < chunks) {
      loadNext();
    } else {
      const result = spark.end();
      const sparkMd52 = new SparkMD5();
      sparkMd52.append(result);
      sparkMd52.append(file.name);
      const hexHash = sparkMd52.end();
      resolve(hexHash);
    }
  };
  fileReader.onerror = () => {
    reject(new Error("File slcie failed"));
  };
  loadNext();
}).catch((err) => {
  console.log(err);
});
function buildFileId(index2) {
  return Date.now() + index2;
}
var useFileHandler = (props2, hooks) => {
  const maxImgSize = computed(() => {
    var _a;
    if (typeof props2.size === "number") {
      return props2.size;
    }
    return (_a = props2 == null ? void 0 : props2.size) == null ? void 0 : _a.maxImgSize;
  });
  const maxFileSize = computed(() => {
    var _a;
    if (typeof props2.size === "number") {
      return props2.size;
    }
    return (_a = props2 == null ? void 0 : props2.size) == null ? void 0 : _a.maxImgSize;
  });
  const fileList = ref([]);
  function findFile(rawFile) {
    return fileList.value.find((item) => item.uid === rawFile.uid);
  }
  let activeIndex = 0;
  function handlePreprocess(file) {
    var _a;
    activeIndex += 1;
    file.uid = buildFileId(activeIndex);
    const uploadFile = {
      uid: file.uid,
      name: file.name,
      status: EUploadStatus.NEW,
      size: file.size,
      raw: file
    };
    const isImage = file.type.startsWith("image/");
    let error2 = null;
    if (isImage) {
      try {
        uploadFile.url = window.URL.createObjectURL(file);
      } catch (err) {
        console.error(err);
      }
      uploadFile.isPic = true;
    }
    if (props2.validateName && !((_a = props2.validateName) == null ? void 0 : _a.test(uploadFile.name))) {
      uploadFile.status = EUploadStatus.FAIL;
      uploadFile.statusText = "invalid filename";
      error2 = new Error(uploadFile.statusText);
    }
    if (isImage && file.size > maxImgSize.value * 1024 ** 2) {
      uploadFile.status = EUploadStatus.FAIL;
      uploadFile.statusText = "invalid file size";
      error2 = new Error(uploadFile.statusText);
    }
    if (!isImage && file.size > maxFileSize.value * 1024 ** 2) {
      uploadFile.status = EUploadStatus.FAIL;
      uploadFile.statusText = "invalid file size";
      error2 = new Error(uploadFile.statusText);
    }
    fileList.value.push(uploadFile);
    return error2;
  }
  async function handleRemove(file) {
    var _a;
    const uploadFile = file instanceof File ? findFile(file) : file;
    const remove = (file2) => {
      var _a2;
      hooks.onRemove(file2, fileList.value);
      fileList.value.splice(fileList.value.indexOf(uploadFile), 1);
      if ((_a2 = file2.url) == null ? void 0 : _a2.startsWith("blob:")) {
        URL.revokeObjectURL(file2.url);
      }
    };
    if (props2.beforeRemove) {
      const before = await ((_a = props2.beforeRemove) == null ? void 0 : _a.call(props2, uploadFile, fileList.value));
      if (before !== false) {
        remove(uploadFile);
      }
    } else {
      remove(uploadFile);
    }
  }
  async function handleError(err, rawFile, res) {
    const file = findFile(rawFile);
    if (!file)
      return;
    file.status = "fail";
    file.statusText = err.message;
    file.response = res;
  }
  async function handleSuccess(res, rawFile) {
    const file = findFile(rawFile);
    if (!file)
      return;
    file.status = "success";
    file.response = res;
  }
  async function handleProgress(event, rawFile) {
    const file = findFile(rawFile);
    if (!file)
      return;
    file.status = "uploading";
    file.percentage = Math.round(event.percent);
  }
  watch(() => props2.files, (files) => {
    fileList.value = files.map((file) => {
      var _a, _b;
      activeIndex += 1;
      return __spreadProps(__spreadValues({}, file), {
        uid: (_a = file.uid) != null ? _a : buildFileId(activeIndex),
        status: (_b = file.status) != null ? _b : EUploadStatus.SUCCESS
      });
    });
  }, { immediate: true, deep: true });
  return {
    fileList,
    handlePreprocess,
    handleRemove,
    handleError,
    handleSuccess,
    handleProgress
  };
};
var Component$3 = defineComponent({
  name: "Upload",
  props: uploadProps,
  emits: ["exceed", "progress", "success", "error", "delete", "done"],
  setup(props2, {
    slots,
    emit,
    expose
  }) {
    const requests = shallowRef({});
    const isPhotowall = computed(() => props2.theme === EThemes.PICTURE);
    const isSinglePhoto = computed(() => isPhotowall.value && !props2.multiple);
    const classNames = computed(() => {
      var _a;
      return classes({
        [CLASS_PREFIX]: true,
        [`${CLASS_PREFIX}--${props2.theme}`]: true,
        [`${CLASS_PREFIX}--disabled`]: props2.disabled,
        [`${CLASS_PREFIX}--single-picture`]: isSinglePhoto.value,
        [props2.extCls]: (_a = props2.extCls) != null ? _a : false
      });
    });
    const triggerProps = computed(() => ({
      theme: props2.theme,
      multiple: props2.multiple,
      disabled: props2.disabled,
      accept: props2.accept
    }));
    function onRemove(file, fileList2) {
      abort(file);
      emit("delete", file, fileList2);
    }
    const {
      fileList,
      handlePreprocess,
      handleRemove,
      handleProgress,
      handleSuccess,
      handleError
    } = useFileHandler(props2, {
      onRemove
    });
    function handleFiles(files) {
      if (!files.length) {
        return;
      }
      if (props2.limit && fileList.value.length + files.length > props2.limit) {
        emit("exceed", files, fileList.value);
        return;
      }
      let sendFiles = files;
      if (!props2.multiple || props2.limit === 1) {
        sendFiles = files.slice(0, 1);
      }
      for (const file of sendFiles) {
        const rawFile = file;
        const error2 = handlePreprocess(rawFile);
        if (error2) {
          emit("error", rawFile, fileList.value, error2);
          return;
        }
        if (props2.autoUpload) {
          upload2(rawFile, sendFiles);
        }
      }
    }
    function handleRetry(file) {
      send(file.raw);
    }
    async function upload2(file, sendFiles) {
      var _a;
      if (!props2.beforeUpload) {
        return send(file, sendFiles);
      }
      let beforeResult;
      try {
        beforeResult = await ((_a = props2.beforeUpload) == null ? void 0 : _a.call(props2, file));
      } catch {
        beforeResult = false;
      }
      if (beforeResult === false) {
        handleRemove(file);
        return;
      }
      send(file, sendFiles);
    }
    function send(file, sendFiles) {
      const {
        headers,
        header,
        data: data2,
        formDataAttributes,
        method,
        withCredentials,
        name: filename,
        url,
        sliceUrl,
        mergeUrl,
        chunkSize,
        customRequest
      } = props2;
      const {
        uid
      } = file;
      const options = {
        headers,
        header,
        withCredentials,
        file,
        data: data2,
        formDataAttributes,
        method,
        filename,
        action: url,
        sliceUrl,
        mergeUrl,
        chunkSize,
        onProgress: (event) => {
          handleProgress(event, file);
          emit("progress", event, file, fileList.value);
        },
        onSuccess: (res) => {
          var _a;
          const result = res;
          if ((_a = props2 == null ? void 0 : props2.handleResCode) == null ? void 0 : _a.call(props2, result)) {
            handleSuccess(res, file);
            emit("success", res, file, fileList.value);
          } else {
            const err = new Error((result == null ? void 0 : result.message) || "unknow error");
            handleError(err, file, res);
            emit("error", file, fileList.value, err);
          }
          delete requests.value[uid];
        },
        onError: (err) => {
          handleError(err, file);
          emit("error", file, fileList.value, err);
          delete requests.value[uid];
        },
        onComplete: () => {
          if (sendFiles && sendFiles.indexOf(file) === sendFiles.length - 1) {
            emit("done", fileList.value);
          }
        }
      };
      let uploadFn = props2.sliceUpload ? ajaxSliceUpload : ajaxUpload;
      if (customRequest) {
        uploadFn = customRequest;
      }
      const request = uploadFn(options);
      requests.value[uid] = request;
      if (request instanceof Promise) {
        request.then(options.onSuccess, options.onError);
      }
    }
    function abort(file) {
      let reqs = requests.value;
      if (file) {
        reqs = {
          [file.uid]: requests.value[file.uid]
        };
      }
      Object.keys(reqs).forEach((uid) => {
        if (reqs[uid] instanceof XMLHttpRequest) {
          const xhr = reqs[uid];
          xhr == null ? void 0 : xhr.abort();
        }
        delete requests.value[uid];
      });
    }
    onBeforeUnmount(() => {
      fileList.value.forEach(({
        url
      }) => {
        if (url == null ? void 0 : url.startsWith("blob:"))
          URL.revokeObjectURL(url);
      });
    });
    expose({
      handleRemove,
      handleRetry
    });
    return () => createVNode("div", {
      "class": classNames.value
    }, [!isPhotowall.value && createVNode(UploadTrigger, mergeProps(triggerProps.value, {
      "onChange": handleFiles
    }), slots), slots.tip ? slots.tip() : props2.tip && createVNode("div", {
      "class": `${CLASS_PREFIX}__tip`
    }, [props2.tip]), createVNode(UploadList, {
      "files": fileList.value,
      "theme": props2.theme,
      "disabled": props2.disabled,
      "multiple": props2.multiple,
      "onRemove": handleRemove,
      "onRetry": handleRetry
    }, {
      innerTrigger: (file) => isPhotowall.value && createVNode(UploadTrigger, mergeProps(triggerProps.value, {
        "file": file,
        "onChange": handleFiles,
        "onRemove": handleRemove
      }), slots),
      file: slots.file
    })]);
  }
});
const Upload = withInstall(Component$3);
function Diff$1() {
}
Diff$1.prototype = {
  diff: function diff(oldString, newString) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    var self2 = this;
    function done2(value) {
      if (callback) {
        setTimeout(function() {
          callback(void 0, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }];
    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      return done2([{
        value: this.join(newString),
        count: newString.length
      }]);
    }
    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = void 0;
        var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
        if (addPath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath$1(removePath);
          self2.pushComponent(basePath.components, void 0, true);
        } else {
          basePath = addPath;
          basePath.newPos++;
          self2.pushComponent(basePath.components, true, void 0);
        }
        _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done2(buildValues$1(self2, basePath.components, newString, oldString, self2.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent: function pushComponent(components2, added, removed) {
    var last = components2[components2.length - 1];
    if (last && last.added === added && last.removed === removed) {
      components2[components2.length - 1] = {
        count: last.count + 1,
        added,
        removed
      };
    } else {
      components2.push({
        count: 1,
        added,
        removed
      });
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }
    basePath.newPos = newPos;
    return oldPos;
  },
  equals: function equals(left2, right2) {
    if (this.options.comparator) {
      return this.options.comparator(left2, right2);
    } else {
      return left2 === right2 || this.options.ignoreCase && left2.toLowerCase() === right2.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i2 = 0; i2 < array.length; i2++) {
      if (array[i2]) {
        ret.push(array[i2]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split("");
  },
  join: function join(chars) {
    return chars.join("");
  }
};
function buildValues$1(diff3, components2, newString, oldString, useLongestToken) {
  var componentPos = 0, componentLen = components2.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components2[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i2) {
          var oldValue = oldString[oldPos + i2];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff3.join(value);
      } else {
        component.value = diff3.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff3.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components2[componentPos - 1].added) {
        var tmp = components2[componentPos - 1];
        components2[componentPos - 1] = components2[componentPos];
        components2[componentPos] = tmp;
      }
    }
  }
  var lastComponent = components2[componentLen - 1];
  if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff3.equals("", lastComponent.value)) {
    components2[componentLen - 2].value += lastComponent.value;
    components2.pop();
  }
  return components2;
}
function clonePath$1(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}
var extendedWordChars$1 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace$1 = /\S/;
var wordDiff$1 = new Diff$1();
wordDiff$1.equals = function(left2, right2) {
  if (this.options.ignoreCase) {
    left2 = left2.toLowerCase();
    right2 = right2.toLowerCase();
  }
  return left2 === right2 || this.options.ignoreWhitespace && !reWhitespace$1.test(left2) && !reWhitespace$1.test(right2);
};
wordDiff$1.tokenize = function(value) {
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (var i2 = 0; i2 < tokens.length - 1; i2++) {
    if (!tokens[i2 + 1] && tokens[i2 + 2] && extendedWordChars$1.test(tokens[i2]) && extendedWordChars$1.test(tokens[i2 + 2])) {
      tokens[i2] += tokens[i2 + 2];
      tokens.splice(i2 + 1, 2);
      i2--;
    }
  }
  return tokens;
};
var lineDiff$1 = new Diff$1();
lineDiff$1.tokenize = function(value) {
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i2 = 0; i2 < linesAndNewlines.length; i2++) {
    var line = linesAndNewlines[i2];
    if (i2 % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }
  return retLines;
};
function diffLines(oldStr, newStr, callback) {
  return lineDiff$1.diff(oldStr, newStr, callback);
}
var sentenceDiff$1 = new Diff$1();
sentenceDiff$1.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff$1 = new Diff$1();
cssDiff$1.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var objectPrototypeToString$1 = Object.prototype.toString;
var jsonDiff$1 = new Diff$1();
jsonDiff$1.useLongestToken = true;
jsonDiff$1.tokenize = lineDiff$1.tokenize;
jsonDiff$1.castInput = function(value) {
  var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k2, v2) {
    return typeof v2 === "undefined" ? undefinedReplacement : v2;
  } : _this$options$stringi;
  return typeof value === "string" ? value : JSON.stringify(canonicalize$1(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff$1.equals = function(left2, right2) {
  return Diff$1.prototype.equals.call(jsonDiff$1, left2.replace(/,([\r\n])/g, "$1"), right2.replace(/,([\r\n])/g, "$1"));
};
function canonicalize$1(obj, stack, replacementStack, replacer, key2) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key2, obj);
  }
  var i2;
  for (i2 = 0; i2 < stack.length; i2 += 1) {
    if (stack[i2] === obj) {
      return replacementStack[i2];
    }
  }
  var canonicalizedObj;
  if (objectPrototypeToString$1.call(obj) === "[object Array]") {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i2 = 0; i2 < obj.length; i2 += 1) {
      canonicalizedObj[i2] = canonicalize$1(obj[i2], stack, replacementStack, replacer, key2);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof$1(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i2 = 0; i2 < sortedKeys.length; i2 += 1) {
      _key = sortedKeys[i2];
      canonicalizedObj[_key] = canonicalize$1(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff$1 = new Diff$1();
arrayDiff$1.tokenize = function(value) {
  return value.slice();
};
arrayDiff$1.join = arrayDiff$1.removeEmpty = function(value) {
  return value;
};
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }
  if (typeof options.context === "undefined") {
    options.context = 4;
  }
  var diff3 = diffLines(oldStr, newStr, options);
  diff3.push({
    value: "",
    lines: []
  });
  function contextLines(lines) {
    return lines.map(function(entry) {
      return " " + entry;
    });
  }
  var hunks = [];
  var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
  var _loop = function _loop2(i3) {
    var current = diff3[i3], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
    current.lines = lines;
    if (current.added || current.removed) {
      var _curRange;
      if (!oldRangeStart) {
        var prev = diff3[i3 - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;
        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      }
      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
        return (current.added ? "+" : "-") + entry;
      })));
      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      if (oldRangeStart) {
        if (lines.length <= options.context * 2 && i3 < diff3.length - 2) {
          var _curRange2;
          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange3;
          var contextSize = Math.min(lines.length, options.context);
          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };
          if (i3 >= diff3.length - 2 && lines.length <= options.context) {
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {
              curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
            }
            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push("\\ No newline at end of file");
            }
          }
          hunks.push(hunk);
          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }
      oldLine += lines.length;
      newLine += lines.length;
    }
  };
  for (var i2 = 0; i2 < diff3.length; i2++) {
    _loop(i2);
  }
  return {
    oldFileName,
    newFileName,
    oldHeader,
    newHeader,
    hunks
  };
}
function formatPatch(diff3) {
  var ret = [];
  if (diff3.oldFileName == diff3.newFileName) {
    ret.push("Index: " + diff3.oldFileName);
  }
  ret.push("===================================================================");
  ret.push("--- " + diff3.oldFileName + (typeof diff3.oldHeader === "undefined" ? "" : "	" + diff3.oldHeader));
  ret.push("+++ " + diff3.newFileName + (typeof diff3.newHeader === "undefined" ? "" : "	" + diff3.newHeader));
  for (var i2 = 0; i2 < diff3.hunks.length; i2++) {
    var hunk = diff3.hunks[i2];
    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    ret.push.apply(ret, hunk.lines);
  }
  return ret.join("\n") + "\n";
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
}
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}
var LineType;
(function(LineType2) {
  LineType2["INSERT"] = "insert";
  LineType2["DELETE"] = "delete";
  LineType2["CONTEXT"] = "context";
})(LineType || (LineType = {}));
var OutputFormatType = {
  LINE_BY_LINE: "line-by-line",
  SIDE_BY_SIDE: "side-by-side"
};
var LineMatchingType = {
  LINES: "lines",
  WORDS: "words",
  NONE: "none"
};
var DiffStyleType = {
  WORD: "word",
  CHAR: "char"
};
var specials = [
  "-",
  "[",
  "]",
  "/",
  "{",
  "}",
  "(",
  ")",
  "*",
  "+",
  "?",
  ".",
  "\\",
  "^",
  "$",
  "|"
];
var regex = RegExp("[" + specials.join("\\") + "]", "g");
function escapeForRegExp(str) {
  return str.replace(regex, "\\$&");
}
function unifyPath(path) {
  return path ? path.replace(/\\/g, "/") : path;
}
function hashCode(text) {
  var i2, chr, len;
  var hash2 = 0;
  for (i2 = 0, len = text.length; i2 < len; i2++) {
    chr = text.charCodeAt(i2);
    hash2 = (hash2 << 5) - hash2 + chr;
    hash2 |= 0;
  }
  return hash2;
}
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function getExtension(filename, language) {
  var filenameParts = filename.split(".");
  return filenameParts.length > 1 ? filenameParts[filenameParts.length - 1] : language;
}
function startsWithAny(str, prefixes) {
  return prefixes.reduce(function(startsWith, prefix) {
    return startsWith || str.startsWith(prefix);
  }, false);
}
var baseDiffFilenamePrefixes = ["a/", "b/", "i/", "w/", "c/", "o/"];
function getFilename(line, linePrefix, extraPrefix) {
  var prefixes = extraPrefix !== void 0 ? __spreadArray(__spreadArray([], baseDiffFilenamePrefixes, true), [extraPrefix], false) : baseDiffFilenamePrefixes;
  var FilenameRegExp = linePrefix ? new RegExp("^".concat(escapeForRegExp(linePrefix), ' "?(.+?)"?$')) : new RegExp('^"?(.+?)"?$');
  var _a = FilenameRegExp.exec(line) || [], _b = _a[1], filename = _b === void 0 ? "" : _b;
  var matchingPrefix = prefixes.find(function(p2) {
    return filename.indexOf(p2) === 0;
  });
  var fnameWithoutPrefix = matchingPrefix ? filename.slice(matchingPrefix.length) : filename;
  return fnameWithoutPrefix.replace(/\s+\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d+)? [+-]\d{4}.*$/, "");
}
function getSrcFilename(line, srcPrefix) {
  return getFilename(line, "---", srcPrefix);
}
function getDstFilename(line, dstPrefix) {
  return getFilename(line, "+++", dstPrefix);
}
function parse(diffInput, config) {
  if (config === void 0) {
    config = {};
  }
  var files = [];
  var currentFile = null;
  var currentBlock = null;
  var oldLine = null;
  var oldLine2 = null;
  var newLine = null;
  var possibleOldName = null;
  var possibleNewName = null;
  var oldFileNameHeader = "--- ";
  var newFileNameHeader = "+++ ";
  var hunkHeaderPrefix = "@@";
  var oldMode = /^old mode (\d{6})/;
  var newMode = /^new mode (\d{6})/;
  var deletedFileMode = /^deleted file mode (\d{6})/;
  var newFileMode = /^new file mode (\d{6})/;
  var copyFrom = /^copy from "?(.+)"?/;
  var copyTo = /^copy to "?(.+)"?/;
  var renameFrom = /^rename from "?(.+)"?/;
  var renameTo = /^rename to "?(.+)"?/;
  var similarityIndex = /^similarity index (\d+)%/;
  var dissimilarityIndex = /^dissimilarity index (\d+)%/;
  var index2 = /^index ([\da-z]+)\.\.([\da-z]+)\s*(\d{6})?/;
  var binaryFiles = /^Binary files (.*) and (.*) differ/;
  var binaryDiff = /^GIT binary patch/;
  var combinedIndex = /^index ([\da-z]+),([\da-z]+)\.\.([\da-z]+)/;
  var combinedMode = /^mode (\d{6}),(\d{6})\.\.(\d{6})/;
  var combinedNewFile = /^new file mode (\d{6})/;
  var combinedDeletedFile = /^deleted file mode (\d{6}),(\d{6})/;
  var diffLines2 = diffInput.replace(/\\ No newline at end of file/g, "").replace(/\r\n?/g, "\n").split("\n");
  function saveBlock() {
    if (currentBlock !== null && currentFile !== null) {
      currentFile.blocks.push(currentBlock);
      currentBlock = null;
    }
  }
  function saveFile() {
    if (currentFile !== null) {
      if (!currentFile.oldName && possibleOldName !== null) {
        currentFile.oldName = possibleOldName;
      }
      if (!currentFile.newName && possibleNewName !== null) {
        currentFile.newName = possibleNewName;
      }
      if (currentFile.newName) {
        files.push(currentFile);
        currentFile = null;
      }
    }
    possibleOldName = null;
    possibleNewName = null;
  }
  function startFile() {
    saveBlock();
    saveFile();
    currentFile = {
      blocks: [],
      deletedLines: 0,
      addedLines: 0
    };
  }
  function startBlock(line) {
    saveBlock();
    var values;
    if (currentFile !== null) {
      if (values = /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@.*/.exec(line)) {
        currentFile.isCombined = false;
        oldLine = parseInt(values[1], 10);
        newLine = parseInt(values[2], 10);
      } else if (values = /^@@@ -(\d+)(?:,\d+)? -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@@.*/.exec(line)) {
        currentFile.isCombined = true;
        oldLine = parseInt(values[1], 10);
        oldLine2 = parseInt(values[2], 10);
        newLine = parseInt(values[3], 10);
      } else {
        if (line.startsWith(hunkHeaderPrefix)) {
          console.error("Failed to parse lines, starting in 0!");
        }
        oldLine = 0;
        newLine = 0;
        currentFile.isCombined = false;
      }
    }
    currentBlock = {
      lines: [],
      oldStartLine: oldLine,
      oldStartLine2: oldLine2,
      newStartLine: newLine,
      header: line
    };
  }
  function createLine(line) {
    if (currentFile === null || currentBlock === null || oldLine === null || newLine === null)
      return;
    var currentLine = {
      content: line
    };
    var addedPrefixes = currentFile.isCombined ? ["+ ", " +", "++"] : ["+"];
    var deletedPrefixes = currentFile.isCombined ? ["- ", " -", "--"] : ["-"];
    if (startsWithAny(line, addedPrefixes)) {
      currentFile.addedLines++;
      currentLine.type = LineType.INSERT;
      currentLine.oldNumber = void 0;
      currentLine.newNumber = newLine++;
    } else if (startsWithAny(line, deletedPrefixes)) {
      currentFile.deletedLines++;
      currentLine.type = LineType.DELETE;
      currentLine.oldNumber = oldLine++;
      currentLine.newNumber = void 0;
    } else {
      currentLine.type = LineType.CONTEXT;
      currentLine.oldNumber = oldLine++;
      currentLine.newNumber = newLine++;
    }
    currentBlock.lines.push(currentLine);
  }
  function existHunkHeader(line, lineIdx) {
    var idx = lineIdx;
    while (idx < diffLines2.length - 3) {
      if (line.startsWith("diff")) {
        return false;
      }
      if (diffLines2[idx].startsWith(oldFileNameHeader) && diffLines2[idx + 1].startsWith(newFileNameHeader) && diffLines2[idx + 2].startsWith(hunkHeaderPrefix)) {
        return true;
      }
      idx++;
    }
    return false;
  }
  diffLines2.forEach(function(line, lineIndex) {
    if (!line || line.startsWith("*")) {
      return;
    }
    var values;
    var prevLine = diffLines2[lineIndex - 1];
    var nxtLine = diffLines2[lineIndex + 1];
    var afterNxtLine = diffLines2[lineIndex + 2];
    if (line.startsWith("diff")) {
      startFile();
      var gitDiffStart = /^diff --git "?([a-ciow]\/.+)"? "?([a-ciow]\/.+)"?/;
      if (values = gitDiffStart.exec(line)) {
        possibleOldName = getFilename(values[1], void 0, config.dstPrefix);
        possibleNewName = getFilename(values[2], void 0, config.srcPrefix);
      }
      if (currentFile === null) {
        throw new Error("Where is my file !!!");
      }
      currentFile.isGitDiff = true;
      return;
    }
    if (!currentFile || !currentFile.isGitDiff && currentFile && line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader) && afterNxtLine.startsWith(hunkHeaderPrefix)) {
      startFile();
    }
    if (currentFile === null || currentFile === void 0 ? void 0 : currentFile.isTooBig) {
      return;
    }
    if (currentFile && (typeof config.diffMaxChanges === "number" && currentFile.addedLines + currentFile.deletedLines > config.diffMaxChanges || typeof config.diffMaxLineLength === "number" && line.length > config.diffMaxLineLength)) {
      currentFile.isTooBig = true;
      currentFile.addedLines = 0;
      currentFile.deletedLines = 0;
      currentFile.blocks = [];
      currentBlock = null;
      var message2 = typeof config.diffTooBigMessage === "function" ? config.diffTooBigMessage(files.length) : "Diff too big to be displayed";
      startBlock(message2);
      return;
    }
    if (line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader) || line.startsWith(newFileNameHeader) && prevLine.startsWith(oldFileNameHeader)) {
      if (currentFile && !currentFile.oldName && line.startsWith("--- ") && (values = getSrcFilename(line, config.srcPrefix))) {
        currentFile.oldName = values;
        currentFile.language = getExtension(currentFile.oldName, currentFile.language);
        return;
      }
      if (currentFile && !currentFile.newName && line.startsWith("+++ ") && (values = getDstFilename(line, config.dstPrefix))) {
        currentFile.newName = values;
        currentFile.language = getExtension(currentFile.newName, currentFile.language);
        return;
      }
    }
    if (currentFile && (line.startsWith(hunkHeaderPrefix) || currentFile.isGitDiff && currentFile.oldName && currentFile.newName && !currentBlock)) {
      startBlock(line);
      return;
    }
    if (currentBlock && (line.startsWith("+") || line.startsWith("-") || line.startsWith(" "))) {
      createLine(line);
      return;
    }
    var doesNotExistHunkHeader = !existHunkHeader(line, lineIndex);
    if (currentFile === null) {
      throw new Error("Where is my file !!!");
    }
    if (values = oldMode.exec(line)) {
      currentFile.oldMode = values[1];
    } else if (values = newMode.exec(line)) {
      currentFile.newMode = values[1];
    } else if (values = deletedFileMode.exec(line)) {
      currentFile.deletedFileMode = values[1];
      currentFile.isDeleted = true;
    } else if (values = newFileMode.exec(line)) {
      currentFile.newFileMode = values[1];
      currentFile.isNew = true;
    } else if (values = copyFrom.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.oldName = values[1];
      }
      currentFile.isCopy = true;
    } else if (values = copyTo.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.newName = values[1];
      }
      currentFile.isCopy = true;
    } else if (values = renameFrom.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.oldName = values[1];
      }
      currentFile.isRename = true;
    } else if (values = renameTo.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.newName = values[1];
      }
      currentFile.isRename = true;
    } else if (values = binaryFiles.exec(line)) {
      currentFile.isBinary = true;
      currentFile.oldName = getFilename(values[1], void 0, config.srcPrefix);
      currentFile.newName = getFilename(values[2], void 0, config.dstPrefix);
      startBlock("Binary file");
    } else if (binaryDiff.test(line)) {
      currentFile.isBinary = true;
      startBlock(line);
    } else if (values = similarityIndex.exec(line)) {
      currentFile.unchangedPercentage = parseInt(values[1], 10);
    } else if (values = dissimilarityIndex.exec(line)) {
      currentFile.changedPercentage = parseInt(values[1], 10);
    } else if (values = index2.exec(line)) {
      currentFile.checksumBefore = values[1];
      currentFile.checksumAfter = values[2];
      values[3] && (currentFile.mode = values[3]);
    } else if (values = combinedIndex.exec(line)) {
      currentFile.checksumBefore = [values[2], values[3]];
      currentFile.checksumAfter = values[1];
    } else if (values = combinedMode.exec(line)) {
      currentFile.oldMode = [values[2], values[3]];
      currentFile.newMode = values[1];
    } else if (values = combinedNewFile.exec(line)) {
      currentFile.newFileMode = values[1];
      currentFile.isNew = true;
    } else if (values = combinedDeletedFile.exec(line)) {
      currentFile.deletedFileMode = values[1];
      currentFile.isDeleted = true;
    }
  });
  saveBlock();
  saveFile();
  return files;
}
function Diff() {
}
Diff.prototype = {
  diff: function diff2(oldString, newString) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    var self2 = this;
    function done2(value) {
      if (callback) {
        setTimeout(function() {
          callback(void 0, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{
      newPos: -1,
      components: []
    }];
    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      return done2([{
        value: this.join(newString),
        count: newString.length
      }]);
    }
    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = void 0;
        var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
        if (addPath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self2.pushComponent(basePath.components, void 0, true);
        } else {
          basePath = addPath;
          basePath.newPos++;
          self2.pushComponent(basePath.components, true, void 0);
        }
        _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done2(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent: function pushComponent2(components2, added, removed) {
    var last = components2[components2.length - 1];
    if (last && last.added === added && last.removed === removed) {
      components2[components2.length - 1] = {
        count: last.count + 1,
        added,
        removed
      };
    } else {
      components2.push({
        count: 1,
        added,
        removed
      });
    }
  },
  extractCommon: function extractCommon2(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }
    basePath.newPos = newPos;
    return oldPos;
  },
  equals: function equals2(left2, right2) {
    if (this.options.comparator) {
      return this.options.comparator(left2, right2);
    } else {
      return left2 === right2 || this.options.ignoreCase && left2.toLowerCase() === right2.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty2(array) {
    var ret = [];
    for (var i2 = 0; i2 < array.length; i2++) {
      if (array[i2]) {
        ret.push(array[i2]);
      }
    }
    return ret;
  },
  castInput: function castInput2(value) {
    return value;
  },
  tokenize: function tokenize2(value) {
    return value.split("");
  },
  join: function join2(chars) {
    return chars.join("");
  }
};
function buildValues(diff3, components2, newString, oldString, useLongestToken) {
  var componentPos = 0, componentLen = components2.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components2[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i2) {
          var oldValue = oldString[oldPos + i2];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff3.join(value);
      } else {
        component.value = diff3.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff3.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components2[componentPos - 1].added) {
        var tmp = components2[componentPos - 1];
        components2[componentPos - 1] = components2[componentPos];
        components2[componentPos] = tmp;
      }
    }
  }
  var lastComponent = components2[componentLen - 1];
  if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff3.equals("", lastComponent.value)) {
    components2[componentLen - 2].value += lastComponent.value;
    components2.pop();
  }
  return components2;
}
function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}
var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left2, right2) {
  if (this.options.ignoreCase) {
    left2 = left2.toLowerCase();
    right2 = right2.toLowerCase();
  }
  return left2 === right2 || this.options.ignoreWhitespace && !reWhitespace.test(left2) && !reWhitespace.test(right2);
};
wordDiff.tokenize = function(value) {
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (var i2 = 0; i2 < tokens.length - 1; i2++) {
    if (!tokens[i2 + 1] && tokens[i2 + 2] && extendedWordChars.test(tokens[i2]) && extendedWordChars.test(tokens[i2 + 2])) {
      tokens[i2] += tokens[i2 + 2];
      tokens.splice(i2 + 1, 2);
      i2--;
    }
  }
  return tokens;
};
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}
var lineDiff = new Diff();
lineDiff.tokenize = function(value) {
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i2 = 0; i2 < linesAndNewlines.length; i2++) {
    var line = linesAndNewlines[i2];
    if (i2 % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }
  return retLines;
};
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value) {
  var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k2, v2) {
    return typeof v2 === "undefined" ? undefinedReplacement : v2;
  } : _this$options$stringi;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left2, right2) {
  return Diff.prototype.equals.call(jsonDiff, left2.replace(/,([\r\n])/g, "$1"), right2.replace(/,([\r\n])/g, "$1"));
};
function canonicalize(obj, stack, replacementStack, replacer, key2) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key2, obj);
  }
  var i2;
  for (i2 = 0; i2 < stack.length; i2 += 1) {
    if (stack[i2] === obj) {
      return replacementStack[i2];
    }
  }
  var canonicalizedObj;
  if (objectPrototypeToString.call(obj) === "[object Array]") {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i2 = 0; i2 < obj.length; i2 += 1) {
      canonicalizedObj[i2] = canonicalize(obj[i2], stack, replacementStack, replacer, key2);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i2 = 0; i2 < sortedKeys.length; i2 += 1) {
      _key = sortedKeys[i2];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};
function levenshtein(a2, b2) {
  if (a2.length === 0) {
    return b2.length;
  }
  if (b2.length === 0) {
    return a2.length;
  }
  var matrix = [];
  var i2;
  for (i2 = 0; i2 <= b2.length; i2++) {
    matrix[i2] = [i2];
  }
  var j2;
  for (j2 = 0; j2 <= a2.length; j2++) {
    matrix[0][j2] = j2;
  }
  for (i2 = 1; i2 <= b2.length; i2++) {
    for (j2 = 1; j2 <= a2.length; j2++) {
      if (b2.charAt(i2 - 1) === a2.charAt(j2 - 1)) {
        matrix[i2][j2] = matrix[i2 - 1][j2 - 1];
      } else {
        matrix[i2][j2] = Math.min(matrix[i2 - 1][j2 - 1] + 1, Math.min(matrix[i2][j2 - 1] + 1, matrix[i2 - 1][j2] + 1));
      }
    }
  }
  return matrix[b2.length][a2.length];
}
function newDistanceFn(str) {
  return function(x2, y2) {
    var xValue = str(x2).trim();
    var yValue = str(y2).trim();
    var lev = levenshtein(xValue, yValue);
    return lev / (xValue.length + yValue.length);
  };
}
function newMatcherFn(distance2) {
  function findBestMatch(a2, b2, cache) {
    if (cache === void 0) {
      cache = /* @__PURE__ */ new Map();
    }
    var bestMatchDist = Infinity;
    var bestMatch;
    for (var i2 = 0; i2 < a2.length; ++i2) {
      for (var j2 = 0; j2 < b2.length; ++j2) {
        var cacheKey = JSON.stringify([a2[i2], b2[j2]]);
        var md = void 0;
        if (!(cache.has(cacheKey) && (md = cache.get(cacheKey)))) {
          md = distance2(a2[i2], b2[j2]);
          cache.set(cacheKey, md);
        }
        if (md < bestMatchDist) {
          bestMatchDist = md;
          bestMatch = { indexA: i2, indexB: j2, score: bestMatchDist };
        }
      }
    }
    return bestMatch;
  }
  function group(a2, b2, level, cache) {
    if (level === void 0) {
      level = 0;
    }
    if (cache === void 0) {
      cache = /* @__PURE__ */ new Map();
    }
    var bm = findBestMatch(a2, b2, cache);
    if (!bm || a2.length + b2.length < 3) {
      return [[a2, b2]];
    }
    var a1 = a2.slice(0, bm.indexA);
    var b1 = b2.slice(0, bm.indexB);
    var aMatch = [a2[bm.indexA]];
    var bMatch = [b2[bm.indexB]];
    var tailA = bm.indexA + 1;
    var tailB = bm.indexB + 1;
    var a22 = a2.slice(tailA);
    var b22 = b2.slice(tailB);
    var group1 = group(a1, b1, level + 1, cache);
    var groupMatch = group(aMatch, bMatch, level + 1, cache);
    var group2 = group(a22, b22, level + 1, cache);
    var result = groupMatch;
    if (bm.indexA > 0 || bm.indexB > 0) {
      result = group1.concat(result);
    }
    if (a2.length > tailA || b2.length > tailB) {
      result = result.concat(group2);
    }
    return result;
  }
  return group;
}
var __assign$4 = globalThis && globalThis.__assign || function() {
  __assign$4 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
var CSSLineClass = {
  INSERTS: "d2h-ins",
  DELETES: "d2h-del",
  CONTEXT: "d2h-cntx",
  INFO: "d2h-info",
  INSERT_CHANGES: "d2h-ins d2h-change",
  DELETE_CHANGES: "d2h-del d2h-change"
};
var defaultRenderConfig = {
  matching: LineMatchingType.NONE,
  matchWordsThreshold: 0.25,
  maxLineLengthHighlight: 1e4,
  diffStyle: DiffStyleType.WORD
};
var separator = "/";
var distance = newDistanceFn(function(change) {
  return change.value;
});
var matcher = newMatcherFn(distance);
function isDevNullName(name) {
  return name.indexOf("dev/null") !== -1;
}
function removeInsElements(line) {
  return line.replace(/(<ins[^>]*>((.|\n)*?)<\/ins>)/g, "");
}
function removeDelElements(line) {
  return line.replace(/(<del[^>]*>((.|\n)*?)<\/del>)/g, "");
}
function toCSSClass(lineType) {
  switch (lineType) {
    case LineType.CONTEXT:
      return CSSLineClass.CONTEXT;
    case LineType.INSERT:
      return CSSLineClass.INSERTS;
    case LineType.DELETE:
      return CSSLineClass.DELETES;
  }
}
function prefixLength(isCombined) {
  return isCombined ? 2 : 1;
}
function escapeForHtml(str) {
  return str.slice(0).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}
function deconstructLine(line, isCombined, escape) {
  if (escape === void 0) {
    escape = true;
  }
  var indexToSplit = prefixLength(isCombined);
  return {
    prefix: line.substring(0, indexToSplit),
    content: escape ? escapeForHtml(line.substring(indexToSplit)) : line.substring(indexToSplit)
  };
}
function filenameDiff(file) {
  var oldFilename = unifyPath(file.oldName);
  var newFilename = unifyPath(file.newName);
  if (oldFilename !== newFilename && !isDevNullName(oldFilename) && !isDevNullName(newFilename)) {
    var prefixPaths = [];
    var suffixPaths = [];
    var oldFilenameParts = oldFilename.split(separator);
    var newFilenameParts = newFilename.split(separator);
    var oldFilenamePartsSize = oldFilenameParts.length;
    var newFilenamePartsSize = newFilenameParts.length;
    var i2 = 0;
    var j2 = oldFilenamePartsSize - 1;
    var k2 = newFilenamePartsSize - 1;
    while (i2 < j2 && i2 < k2) {
      if (oldFilenameParts[i2] === newFilenameParts[i2]) {
        prefixPaths.push(newFilenameParts[i2]);
        i2 += 1;
      } else {
        break;
      }
    }
    while (j2 > i2 && k2 > i2) {
      if (oldFilenameParts[j2] === newFilenameParts[k2]) {
        suffixPaths.unshift(newFilenameParts[k2]);
        j2 -= 1;
        k2 -= 1;
      } else {
        break;
      }
    }
    var finalPrefix = prefixPaths.join(separator);
    var finalSuffix = suffixPaths.join(separator);
    var oldRemainingPath = oldFilenameParts.slice(i2, j2 + 1).join(separator);
    var newRemainingPath = newFilenameParts.slice(i2, k2 + 1).join(separator);
    if (finalPrefix.length && finalSuffix.length) {
      return finalPrefix + separator + "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}" + separator + finalSuffix;
    } else if (finalPrefix.length) {
      return finalPrefix + separator + "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}";
    } else if (finalSuffix.length) {
      return "{" + oldRemainingPath + " \u2192 " + newRemainingPath + "}" + separator + finalSuffix;
    }
    return oldFilename + " \u2192 " + newFilename;
  } else if (!isDevNullName(newFilename)) {
    return newFilename;
  } else {
    return oldFilename;
  }
}
function getHtmlId(file) {
  return "d2h-".concat(hashCode(filenameDiff(file)).toString().slice(-6));
}
function getFileIcon(file) {
  var templateName = "file-changed";
  if (file.isRename) {
    templateName = "file-renamed";
  } else if (file.isCopy) {
    templateName = "file-renamed";
  } else if (file.isNew) {
    templateName = "file-added";
  } else if (file.isDeleted) {
    templateName = "file-deleted";
  } else if (file.newName !== file.oldName) {
    templateName = "file-renamed";
  }
  return templateName;
}
function diffHighlight(diffLine1, diffLine2, isCombined, config) {
  if (config === void 0) {
    config = {};
  }
  var _a = __assign$4(__assign$4({}, defaultRenderConfig), config), matching = _a.matching, maxLineLengthHighlight = _a.maxLineLengthHighlight, matchWordsThreshold = _a.matchWordsThreshold, diffStyle = _a.diffStyle;
  var line1 = deconstructLine(diffLine1, isCombined, false);
  var line2 = deconstructLine(diffLine2, isCombined, false);
  if (line1.content.length > maxLineLengthHighlight || line2.content.length > maxLineLengthHighlight) {
    return {
      oldLine: {
        prefix: line1.prefix,
        content: escapeForHtml(line1.content)
      },
      newLine: {
        prefix: line2.prefix,
        content: escapeForHtml(line2.content)
      }
    };
  }
  var diff3 = diffStyle === "char" ? diffChars(line1.content, line2.content) : diffWordsWithSpace(line1.content, line2.content);
  var changedWords = [];
  if (diffStyle === "word" && matching === "words") {
    var removed = diff3.filter(function(element) {
      return element.removed;
    });
    var added = diff3.filter(function(element) {
      return element.added;
    });
    var chunks = matcher(added, removed);
    chunks.forEach(function(chunk) {
      if (chunk[0].length === 1 && chunk[1].length === 1) {
        var dist = distance(chunk[0][0], chunk[1][0]);
        if (dist < matchWordsThreshold) {
          changedWords.push(chunk[0][0]);
          changedWords.push(chunk[1][0]);
        }
      }
    });
  }
  var highlightedLine = diff3.reduce(function(highlightedLine2, part) {
    var elemType = part.added ? "ins" : part.removed ? "del" : null;
    var addClass2 = changedWords.indexOf(part) > -1 ? ' class="d2h-change"' : "";
    var escapedValue = escapeForHtml(part.value);
    return elemType !== null ? "".concat(highlightedLine2, "<").concat(elemType).concat(addClass2, ">").concat(escapedValue, "</").concat(elemType, ">") : "".concat(highlightedLine2).concat(escapedValue);
  }, "");
  return {
    oldLine: {
      prefix: line1.prefix,
      content: removeInsElements(highlightedLine)
    },
    newLine: {
      prefix: line2.prefix,
      content: removeDelElements(highlightedLine)
    }
  };
}
var baseTemplatesPath$2 = "file-summary";
var iconsBaseTemplatesPath$2 = "icon";
function render(diffFiles, hoganUtils) {
  var files = diffFiles.map(function(file) {
    return hoganUtils.render(baseTemplatesPath$2, "line", {
      fileHtmlId: getHtmlId(file),
      oldName: file.oldName,
      newName: file.newName,
      fileName: filenameDiff(file),
      deletedLines: "-" + file.deletedLines,
      addedLines: "+" + file.addedLines
    }, {
      fileIcon: hoganUtils.template(iconsBaseTemplatesPath$2, getFileIcon(file))
    });
  }).join("\n");
  return hoganUtils.render(baseTemplatesPath$2, "wrapper", {
    filesNumber: diffFiles.length,
    files
  });
}
var __assign$3 = globalThis && globalThis.__assign || function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var defaultLineByLineRendererConfig = __assign$3(__assign$3({}, defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: 2500, maxLineSizeInBlockForComparison: 200 });
var genericTemplatesPath$1 = "generic";
var baseTemplatesPath$1 = "line-by-line";
var iconsBaseTemplatesPath$1 = "icon";
var tagsBaseTemplatesPath$1 = "tag";
var LineByLineRenderer = function() {
  function LineByLineRenderer2(hoganUtils, config) {
    if (config === void 0) {
      config = {};
    }
    this.hoganUtils = hoganUtils;
    this.config = __assign$3(__assign$3({}, defaultLineByLineRendererConfig), config);
  }
  LineByLineRenderer2.prototype.render = function(diffFiles) {
    var _this = this;
    var diffsHtml = diffFiles.map(function(file) {
      var diffs;
      if (file.blocks.length) {
        diffs = _this.generateFileHtml(file);
      } else {
        diffs = _this.generateEmptyDiff();
      }
      return _this.makeFileDiffHtml(file, diffs);
    }).join("\n");
    return this.hoganUtils.render(genericTemplatesPath$1, "wrapper", { content: diffsHtml });
  };
  LineByLineRenderer2.prototype.makeFileDiffHtml = function(file, diffs) {
    if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === 0)
      return "";
    var fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath$1, "file-diff");
    var filePathTemplate = this.hoganUtils.template(genericTemplatesPath$1, "file-path");
    var fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath$1, "file");
    var fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath$1, getFileIcon(file));
    return fileDiffTemplate.render({
      file,
      fileHtmlId: getHtmlId(file),
      diffs,
      filePath: filePathTemplate.render({
        fileDiffName: filenameDiff(file)
      }, {
        fileIcon: fileIconTemplate,
        fileTag: fileTagTemplate
      })
    });
  };
  LineByLineRenderer2.prototype.generateEmptyDiff = function() {
    return this.hoganUtils.render(genericTemplatesPath$1, "empty-diff", {
      contentClass: "d2h-code-line",
      CSSLineClass
    });
  };
  LineByLineRenderer2.prototype.generateFileHtml = function(file) {
    var _this = this;
    var matcher2 = newMatcherFn(newDistanceFn(function(e) {
      return deconstructLine(e.content, file.isCombined).content;
    }));
    return file.blocks.map(function(block) {
      var lines = _this.hoganUtils.render(genericTemplatesPath$1, "block-header", {
        CSSLineClass,
        blockHeader: file.isTooBig ? block.header : escapeForHtml(block.header),
        lineClass: "d2h-code-linenumber",
        contentClass: "d2h-code-line"
      });
      _this.applyLineGroupping(block).forEach(function(_a) {
        var contextLines = _a[0], oldLines = _a[1], newLines = _a[2];
        if (oldLines.length && newLines.length && !contextLines.length) {
          _this.applyRematchMatching(oldLines, newLines, matcher2).map(function(_a2) {
            var oldLines2 = _a2[0], newLines2 = _a2[1];
            var _b2 = _this.processChangedLines(file.isCombined, oldLines2, newLines2), left3 = _b2.left, right3 = _b2.right;
            lines += left3;
            lines += right3;
          });
        } else if (contextLines.length) {
          contextLines.forEach(function(line) {
            var _a2 = deconstructLine(line.content, file.isCombined), prefix = _a2.prefix, content = _a2.content;
            lines += _this.generateSingleLineHtml({
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              oldNumber: line.oldNumber,
              newNumber: line.newNumber
            });
          });
        } else if (oldLines.length || newLines.length) {
          var _b = _this.processChangedLines(file.isCombined, oldLines, newLines), left2 = _b.left, right2 = _b.right;
          lines += left2;
          lines += right2;
        } else {
          console.error("Unknown state reached while processing groups of lines", contextLines, oldLines, newLines);
        }
      });
      return lines;
    }).join("\n");
  };
  LineByLineRenderer2.prototype.applyLineGroupping = function(block) {
    var blockLinesGroups = [];
    var oldLines = [];
    var newLines = [];
    for (var i2 = 0; i2 < block.lines.length; i2++) {
      var diffLine = block.lines[i2];
      if (diffLine.type !== LineType.INSERT && newLines.length || diffLine.type === LineType.CONTEXT && oldLines.length > 0) {
        blockLinesGroups.push([[], oldLines, newLines]);
        oldLines = [];
        newLines = [];
      }
      if (diffLine.type === LineType.CONTEXT) {
        blockLinesGroups.push([[diffLine], [], []]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length === 0) {
        blockLinesGroups.push([[], [], [diffLine]]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length > 0) {
        newLines.push(diffLine);
      } else if (diffLine.type === LineType.DELETE) {
        oldLines.push(diffLine);
      }
    }
    if (oldLines.length || newLines.length) {
      blockLinesGroups.push([[], oldLines, newLines]);
      oldLines = [];
      newLines = [];
    }
    return blockLinesGroups;
  };
  LineByLineRenderer2.prototype.applyRematchMatching = function(oldLines, newLines, matcher2) {
    var comparisons = oldLines.length * newLines.length;
    var maxLineSizeInBlock = Math.max.apply(null, [0].concat(oldLines.concat(newLines).map(function(elem) {
      return elem.content.length;
    })));
    var doMatching = comparisons < this.config.matchingMaxComparisons && maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison && (this.config.matching === "lines" || this.config.matching === "words");
    return doMatching ? matcher2(oldLines, newLines) : [[oldLines, newLines]];
  };
  LineByLineRenderer2.prototype.processChangedLines = function(isCombined, oldLines, newLines) {
    var fileHtml = {
      right: "",
      left: ""
    };
    var maxLinesNumber = Math.max(oldLines.length, newLines.length);
    for (var i2 = 0; i2 < maxLinesNumber; i2++) {
      var oldLine = oldLines[i2];
      var newLine = newLines[i2];
      var diff3 = oldLine !== void 0 && newLine !== void 0 ? diffHighlight(oldLine.content, newLine.content, isCombined, this.config) : void 0;
      var preparedOldLine = oldLine !== void 0 && oldLine.oldNumber !== void 0 ? __assign$3(__assign$3({}, diff3 !== void 0 ? {
        prefix: diff3.oldLine.prefix,
        content: diff3.oldLine.content,
        type: CSSLineClass.DELETE_CHANGES
      } : __assign$3(__assign$3({}, deconstructLine(oldLine.content, isCombined)), { type: toCSSClass(oldLine.type) })), { oldNumber: oldLine.oldNumber, newNumber: oldLine.newNumber }) : void 0;
      var preparedNewLine = newLine !== void 0 && newLine.newNumber !== void 0 ? __assign$3(__assign$3({}, diff3 !== void 0 ? {
        prefix: diff3.newLine.prefix,
        content: diff3.newLine.content,
        type: CSSLineClass.INSERT_CHANGES
      } : __assign$3(__assign$3({}, deconstructLine(newLine.content, isCombined)), { type: toCSSClass(newLine.type) })), { oldNumber: newLine.oldNumber, newNumber: newLine.newNumber }) : void 0;
      var _a = this.generateLineHtml(preparedOldLine, preparedNewLine), left2 = _a.left, right2 = _a.right;
      fileHtml.left += left2;
      fileHtml.right += right2;
    }
    return fileHtml;
  };
  LineByLineRenderer2.prototype.generateLineHtml = function(oldLine, newLine) {
    return {
      left: this.generateSingleLineHtml(oldLine),
      right: this.generateSingleLineHtml(newLine)
    };
  };
  LineByLineRenderer2.prototype.generateSingleLineHtml = function(line) {
    if (line === void 0)
      return "";
    var lineNumberHtml = this.hoganUtils.render(baseTemplatesPath$1, "numbers", {
      oldNumber: line.oldNumber || "",
      newNumber: line.newNumber || ""
    });
    return this.hoganUtils.render(genericTemplatesPath$1, "line", {
      type: line.type,
      lineClass: "d2h-code-linenumber",
      contentClass: "d2h-code-line",
      prefix: line.prefix === " " ? "&nbsp;" : line.prefix,
      content: line.content,
      lineNumber: lineNumberHtml
    });
  };
  return LineByLineRenderer2;
}();
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var defaultSideBySideRendererConfig = __assign$2(__assign$2({}, defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: 2500, maxLineSizeInBlockForComparison: 200 });
var genericTemplatesPath = "generic";
var baseTemplatesPath = "side-by-side";
var iconsBaseTemplatesPath = "icon";
var tagsBaseTemplatesPath = "tag";
var SideBySideRenderer = function() {
  function SideBySideRenderer2(hoganUtils, config) {
    if (config === void 0) {
      config = {};
    }
    this.hoganUtils = hoganUtils;
    this.config = __assign$2(__assign$2({}, defaultSideBySideRendererConfig), config);
  }
  SideBySideRenderer2.prototype.render = function(diffFiles) {
    var _this = this;
    var diffsHtml = diffFiles.map(function(file) {
      var diffs;
      if (file.blocks.length) {
        diffs = _this.generateFileHtml(file);
      } else {
        diffs = _this.generateEmptyDiff();
      }
      return _this.makeFileDiffHtml(file, diffs);
    }).join("\n");
    return this.hoganUtils.render(genericTemplatesPath, "wrapper", { content: diffsHtml });
  };
  SideBySideRenderer2.prototype.makeFileDiffHtml = function(file, diffs) {
    if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === 0)
      return "";
    var fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath, "file-diff");
    var filePathTemplate = this.hoganUtils.template(genericTemplatesPath, "file-path");
    var fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath, "file");
    var fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath, getFileIcon(file));
    return fileDiffTemplate.render({
      file,
      fileHtmlId: getHtmlId(file),
      diffs,
      filePath: filePathTemplate.render({
        fileDiffName: filenameDiff(file)
      }, {
        fileIcon: fileIconTemplate,
        fileTag: fileTagTemplate
      })
    });
  };
  SideBySideRenderer2.prototype.generateEmptyDiff = function() {
    return {
      right: "",
      left: this.hoganUtils.render(genericTemplatesPath, "empty-diff", {
        contentClass: "d2h-code-side-line",
        CSSLineClass
      })
    };
  };
  SideBySideRenderer2.prototype.generateFileHtml = function(file) {
    var _this = this;
    var matcher2 = newMatcherFn(newDistanceFn(function(e) {
      return deconstructLine(e.content, file.isCombined).content;
    }));
    return file.blocks.map(function(block) {
      var fileHtml = {
        left: _this.makeHeaderHtml(block.header, file),
        right: _this.makeHeaderHtml("")
      };
      _this.applyLineGroupping(block).forEach(function(_a) {
        var contextLines = _a[0], oldLines = _a[1], newLines = _a[2];
        if (oldLines.length && newLines.length && !contextLines.length) {
          _this.applyRematchMatching(oldLines, newLines, matcher2).map(function(_a2) {
            var oldLines2 = _a2[0], newLines2 = _a2[1];
            var _b2 = _this.processChangedLines(file.isCombined, oldLines2, newLines2), left3 = _b2.left, right3 = _b2.right;
            fileHtml.left += left3;
            fileHtml.right += right3;
          });
        } else if (contextLines.length) {
          contextLines.forEach(function(line) {
            var _a2 = deconstructLine(line.content, file.isCombined), prefix = _a2.prefix, content = _a2.content;
            var _b2 = _this.generateLineHtml({
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              number: line.oldNumber
            }, {
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              number: line.newNumber
            }), left3 = _b2.left, right3 = _b2.right;
            fileHtml.left += left3;
            fileHtml.right += right3;
          });
        } else if (oldLines.length || newLines.length) {
          var _b = _this.processChangedLines(file.isCombined, oldLines, newLines), left2 = _b.left, right2 = _b.right;
          fileHtml.left += left2;
          fileHtml.right += right2;
        } else {
          console.error("Unknown state reached while processing groups of lines", contextLines, oldLines, newLines);
        }
      });
      return fileHtml;
    }).reduce(function(accomulated, html2) {
      return { left: accomulated.left + html2.left, right: accomulated.right + html2.right };
    }, { left: "", right: "" });
  };
  SideBySideRenderer2.prototype.applyLineGroupping = function(block) {
    var blockLinesGroups = [];
    var oldLines = [];
    var newLines = [];
    for (var i2 = 0; i2 < block.lines.length; i2++) {
      var diffLine = block.lines[i2];
      if (diffLine.type !== LineType.INSERT && newLines.length || diffLine.type === LineType.CONTEXT && oldLines.length > 0) {
        blockLinesGroups.push([[], oldLines, newLines]);
        oldLines = [];
        newLines = [];
      }
      if (diffLine.type === LineType.CONTEXT) {
        blockLinesGroups.push([[diffLine], [], []]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length === 0) {
        blockLinesGroups.push([[], [], [diffLine]]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length > 0) {
        newLines.push(diffLine);
      } else if (diffLine.type === LineType.DELETE) {
        oldLines.push(diffLine);
      }
    }
    if (oldLines.length || newLines.length) {
      blockLinesGroups.push([[], oldLines, newLines]);
      oldLines = [];
      newLines = [];
    }
    return blockLinesGroups;
  };
  SideBySideRenderer2.prototype.applyRematchMatching = function(oldLines, newLines, matcher2) {
    var comparisons = oldLines.length * newLines.length;
    var maxLineSizeInBlock = Math.max.apply(null, [0].concat(oldLines.concat(newLines).map(function(elem) {
      return elem.content.length;
    })));
    var doMatching = comparisons < this.config.matchingMaxComparisons && maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison && (this.config.matching === "lines" || this.config.matching === "words");
    return doMatching ? matcher2(oldLines, newLines) : [[oldLines, newLines]];
  };
  SideBySideRenderer2.prototype.makeHeaderHtml = function(blockHeader, file) {
    return this.hoganUtils.render(genericTemplatesPath, "block-header", {
      CSSLineClass,
      blockHeader: (file === null || file === void 0 ? void 0 : file.isTooBig) ? blockHeader : escapeForHtml(blockHeader),
      lineClass: "d2h-code-side-linenumber",
      contentClass: "d2h-code-side-line"
    });
  };
  SideBySideRenderer2.prototype.processChangedLines = function(isCombined, oldLines, newLines) {
    var fileHtml = {
      right: "",
      left: ""
    };
    var maxLinesNumber = Math.max(oldLines.length, newLines.length);
    for (var i2 = 0; i2 < maxLinesNumber; i2++) {
      var oldLine = oldLines[i2];
      var newLine = newLines[i2];
      var diff3 = oldLine !== void 0 && newLine !== void 0 ? diffHighlight(oldLine.content, newLine.content, isCombined, this.config) : void 0;
      var preparedOldLine = oldLine !== void 0 && oldLine.oldNumber !== void 0 ? __assign$2(__assign$2({}, diff3 !== void 0 ? {
        prefix: diff3.oldLine.prefix,
        content: diff3.oldLine.content,
        type: CSSLineClass.DELETE_CHANGES
      } : __assign$2(__assign$2({}, deconstructLine(oldLine.content, isCombined)), { type: toCSSClass(oldLine.type) })), { number: oldLine.oldNumber }) : void 0;
      var preparedNewLine = newLine !== void 0 && newLine.newNumber !== void 0 ? __assign$2(__assign$2({}, diff3 !== void 0 ? {
        prefix: diff3.newLine.prefix,
        content: diff3.newLine.content,
        type: CSSLineClass.INSERT_CHANGES
      } : __assign$2(__assign$2({}, deconstructLine(newLine.content, isCombined)), { type: toCSSClass(newLine.type) })), { number: newLine.newNumber }) : void 0;
      var _a = this.generateLineHtml(preparedOldLine, preparedNewLine), left2 = _a.left, right2 = _a.right;
      fileHtml.left += left2;
      fileHtml.right += right2;
    }
    return fileHtml;
  };
  SideBySideRenderer2.prototype.generateLineHtml = function(oldLine, newLine) {
    return {
      left: this.generateSingleHtml(oldLine),
      right: this.generateSingleHtml(newLine)
    };
  };
  SideBySideRenderer2.prototype.generateSingleHtml = function(line) {
    var lineClass = "d2h-code-side-linenumber";
    var contentClass = "d2h-code-side-line";
    return this.hoganUtils.render(genericTemplatesPath, "line", {
      type: (line === null || line === void 0 ? void 0 : line.type) || "".concat(CSSLineClass.CONTEXT, " d2h-emptyplaceholder"),
      lineClass: line !== void 0 ? lineClass : "".concat(lineClass, " d2h-code-side-emptyplaceholder"),
      contentClass: line !== void 0 ? contentClass : "".concat(contentClass, " d2h-code-side-emptyplaceholder"),
      prefix: (line === null || line === void 0 ? void 0 : line.prefix) === " " ? "&nbsp;" : line === null || line === void 0 ? void 0 : line.prefix,
      content: line === null || line === void 0 ? void 0 : line.content,
      lineNumber: line === null || line === void 0 ? void 0 : line.number
    });
  };
  return SideBySideRenderer2;
}();
var compiler = {};
(function(exports) {
  (function(Hogan2) {
    var rIsWhitespace = /\S/, rQuot = /\"/g, rNewline = /\n/g, rCr = /\r/g, rSlash = /\\/g, rLineSep = /\u2028/, rParagraphSep = /\u2029/;
    Hogan2.tags = {
      "#": 1,
      "^": 2,
      "<": 3,
      "$": 4,
      "/": 5,
      "!": 6,
      ">": 7,
      "=": 8,
      "_v": 9,
      "{": 10,
      "&": 11,
      "_t": 12
    };
    Hogan2.scan = function scan(text, delimiters) {
      var len = text.length, IN_TEXT = 0, IN_TAG_TYPE = 1, IN_TAG = 2, state = IN_TEXT, tagType = null, tag2 = null, buf = "", tokens = [], seenTag = false, i2 = 0, lineStart = 0, otag = "{{", ctag = "}}";
      function addBuf() {
        if (buf.length > 0) {
          tokens.push({ tag: "_t", text: new String(buf) });
          buf = "";
        }
      }
      function lineIsWhitespace() {
        var isAllWhitespace = true;
        for (var j2 = lineStart; j2 < tokens.length; j2++) {
          isAllWhitespace = Hogan2.tags[tokens[j2].tag] < Hogan2.tags["_v"] || tokens[j2].tag == "_t" && tokens[j2].text.match(rIsWhitespace) === null;
          if (!isAllWhitespace) {
            return false;
          }
        }
        return isAllWhitespace;
      }
      function filterLine(haveSeenTag, noNewLine) {
        addBuf();
        if (haveSeenTag && lineIsWhitespace()) {
          for (var j2 = lineStart, next; j2 < tokens.length; j2++) {
            if (tokens[j2].text) {
              if ((next = tokens[j2 + 1]) && next.tag == ">") {
                next.indent = tokens[j2].text.toString();
              }
              tokens.splice(j2, 1);
            }
          }
        } else if (!noNewLine) {
          tokens.push({ tag: "\n" });
        }
        seenTag = false;
        lineStart = tokens.length;
      }
      function changeDelimiters(text2, index2) {
        var close2 = "=" + ctag, closeIndex = text2.indexOf(close2, index2), delimiters2 = trim(text2.substring(text2.indexOf("=", index2) + 1, closeIndex)).split(" ");
        otag = delimiters2[0];
        ctag = delimiters2[delimiters2.length - 1];
        return closeIndex + close2.length - 1;
      }
      if (delimiters) {
        delimiters = delimiters.split(" ");
        otag = delimiters[0];
        ctag = delimiters[1];
      }
      for (i2 = 0; i2 < len; i2++) {
        if (state == IN_TEXT) {
          if (tagChange(otag, text, i2)) {
            --i2;
            addBuf();
            state = IN_TAG_TYPE;
          } else {
            if (text.charAt(i2) == "\n") {
              filterLine(seenTag);
            } else {
              buf += text.charAt(i2);
            }
          }
        } else if (state == IN_TAG_TYPE) {
          i2 += otag.length - 1;
          tag2 = Hogan2.tags[text.charAt(i2 + 1)];
          tagType = tag2 ? text.charAt(i2 + 1) : "_v";
          if (tagType == "=") {
            i2 = changeDelimiters(text, i2);
            state = IN_TEXT;
          } else {
            if (tag2) {
              i2++;
            }
            state = IN_TAG;
          }
          seenTag = i2;
        } else {
          if (tagChange(ctag, text, i2)) {
            tokens.push({
              tag: tagType,
              n: trim(buf),
              otag,
              ctag,
              i: tagType == "/" ? seenTag - otag.length : i2 + ctag.length
            });
            buf = "";
            i2 += ctag.length - 1;
            state = IN_TEXT;
            if (tagType == "{") {
              if (ctag == "}}") {
                i2++;
              } else {
                cleanTripleStache(tokens[tokens.length - 1]);
              }
            }
          } else {
            buf += text.charAt(i2);
          }
        }
      }
      filterLine(seenTag, true);
      return tokens;
    };
    function cleanTripleStache(token2) {
      if (token2.n.substr(token2.n.length - 1) === "}") {
        token2.n = token2.n.substring(0, token2.n.length - 1);
      }
    }
    function trim(s2) {
      if (s2.trim) {
        return s2.trim();
      }
      return s2.replace(/^\s*|\s*$/g, "");
    }
    function tagChange(tag2, text, index2) {
      if (text.charAt(index2) != tag2.charAt(0)) {
        return false;
      }
      for (var i2 = 1, l2 = tag2.length; i2 < l2; i2++) {
        if (text.charAt(index2 + i2) != tag2.charAt(i2)) {
          return false;
        }
      }
      return true;
    }
    var allowedInSuper = { "_t": true, "\n": true, "$": true, "/": true };
    function buildTree(tokens, kind, stack, customTags) {
      var instructions = [], opener = null, tail = null, token2 = null;
      tail = stack[stack.length - 1];
      while (tokens.length > 0) {
        token2 = tokens.shift();
        if (tail && tail.tag == "<" && !(token2.tag in allowedInSuper)) {
          throw new Error("Illegal content in < super tag.");
        }
        if (Hogan2.tags[token2.tag] <= Hogan2.tags["$"] || isOpener(token2, customTags)) {
          stack.push(token2);
          token2.nodes = buildTree(tokens, token2.tag, stack, customTags);
        } else if (token2.tag == "/") {
          if (stack.length === 0) {
            throw new Error("Closing tag without opener: /" + token2.n);
          }
          opener = stack.pop();
          if (token2.n != opener.n && !isCloser(token2.n, opener.n, customTags)) {
            throw new Error("Nesting error: " + opener.n + " vs. " + token2.n);
          }
          opener.end = token2.i;
          return instructions;
        } else if (token2.tag == "\n") {
          token2.last = tokens.length == 0 || tokens[0].tag == "\n";
        }
        instructions.push(token2);
      }
      if (stack.length > 0) {
        throw new Error("missing closing tag: " + stack.pop().n);
      }
      return instructions;
    }
    function isOpener(token2, tags) {
      for (var i2 = 0, l2 = tags.length; i2 < l2; i2++) {
        if (tags[i2].o == token2.n) {
          token2.tag = "#";
          return true;
        }
      }
    }
    function isCloser(close2, open, tags) {
      for (var i2 = 0, l2 = tags.length; i2 < l2; i2++) {
        if (tags[i2].c == close2 && tags[i2].o == open) {
          return true;
        }
      }
    }
    function stringifySubstitutions(obj) {
      var items = [];
      for (var key2 in obj) {
        items.push('"' + esc(key2) + '": function(c,p,t,i) {' + obj[key2] + "}");
      }
      return "{ " + items.join(",") + " }";
    }
    function stringifyPartials(codeObj) {
      var partials = [];
      for (var key2 in codeObj.partials) {
        partials.push('"' + esc(key2) + '":{name:"' + esc(codeObj.partials[key2].name) + '", ' + stringifyPartials(codeObj.partials[key2]) + "}");
      }
      return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
    }
    Hogan2.stringify = function(codeObj, text, options) {
      return "{code: function (c,p,i) { " + Hogan2.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) + "}";
    };
    var serialNo = 0;
    Hogan2.generate = function(tree2, text, options) {
      serialNo = 0;
      var context = { code: "", subs: {}, partials: {} };
      Hogan2.walk(tree2, context);
      if (options.asString) {
        return this.stringify(context, text, options);
      }
      return this.makeTemplate(context, text, options);
    };
    Hogan2.wrapMain = function(code2) {
      return 'var t=this;t.b(i=i||"");' + code2 + "return t.fl();";
    };
    Hogan2.template = Hogan2.Template;
    Hogan2.makeTemplate = function(codeObj, text, options) {
      var template2 = this.makePartials(codeObj);
      template2.code = new Function("c", "p", "i", this.wrapMain(codeObj.code));
      return new this.template(template2, text, this, options);
    };
    Hogan2.makePartials = function(codeObj) {
      var key2, template2 = { subs: {}, partials: codeObj.partials, name: codeObj.name };
      for (key2 in template2.partials) {
        template2.partials[key2] = this.makePartials(template2.partials[key2]);
      }
      for (key2 in codeObj.subs) {
        template2.subs[key2] = new Function("c", "p", "t", "i", codeObj.subs[key2]);
      }
      return template2;
    };
    function esc(s2) {
      return s2.replace(rSlash, "\\\\").replace(rQuot, '\\"').replace(rNewline, "\\n").replace(rCr, "\\r").replace(rLineSep, "\\u2028").replace(rParagraphSep, "\\u2029");
    }
    function chooseMethod(s2) {
      return ~s2.indexOf(".") ? "d" : "f";
    }
    function createPartial(node, context) {
      var prefix = "<" + (context.prefix || "");
      var sym = prefix + node.n + serialNo++;
      context.partials[sym] = { name: node.n, partials: {} };
      context.code += 't.b(t.rp("' + esc(sym) + '",c,p,"' + (node.indent || "") + '"));';
      return sym;
    }
    Hogan2.codegen = {
      "#": function(node, context) {
        context.code += "if(t.s(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,0,' + node.i + "," + node.end + ',"' + node.otag + " " + node.ctag + '")){t.rs(c,p,function(c,p,t){';
        Hogan2.walk(node.nodes, context);
        context.code += "});c.pop();}";
      },
      "^": function(node, context) {
        context.code += "if(!t.s(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
        Hogan2.walk(node.nodes, context);
        context.code += "};";
      },
      ">": createPartial,
      "<": function(node, context) {
        var ctx = { partials: {}, code: "", subs: {}, inPartial: true };
        Hogan2.walk(node.nodes, ctx);
        var template2 = context.partials[createPartial(node, context)];
        template2.subs = ctx.subs;
        template2.partials = ctx.partials;
      },
      "$": function(node, context) {
        var ctx = { subs: {}, code: "", partials: context.partials, prefix: node.n };
        Hogan2.walk(node.nodes, ctx);
        context.subs[node.n] = ctx.code;
        if (!context.inPartial) {
          context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
        }
      },
      "\n": function(node, context) {
        context.code += write2('"\\n"' + (node.last ? "" : " + i"));
      },
      "_v": function(node, context) {
        context.code += "t.b(t.v(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
      },
      "_t": function(node, context) {
        context.code += write2('"' + esc(node.text) + '"');
      },
      "{": tripleStache,
      "&": tripleStache
    };
    function tripleStache(node, context) {
      context.code += "t.b(t.t(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    }
    function write2(s2) {
      return "t.b(" + s2 + ");";
    }
    Hogan2.walk = function(nodelist, context) {
      var func;
      for (var i2 = 0, l2 = nodelist.length; i2 < l2; i2++) {
        func = Hogan2.codegen[nodelist[i2].tag];
        func && func(nodelist[i2], context);
      }
      return context;
    };
    Hogan2.parse = function(tokens, text, options) {
      options = options || {};
      return buildTree(tokens, "", [], options.sectionTags || []);
    };
    Hogan2.cache = {};
    Hogan2.cacheKey = function(text, options) {
      return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join("||");
    };
    Hogan2.compile = function(text, options) {
      options = options || {};
      var key2 = Hogan2.cacheKey(text, options);
      var template2 = this.cache[key2];
      if (template2) {
        var partials = template2.partials;
        for (var name in partials) {
          delete partials[name].instance;
        }
        return template2;
      }
      template2 = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
      return this.cache[key2] = template2;
    };
  })(exports);
})(compiler);
var template = {};
(function(exports) {
  (function(Hogan2) {
    Hogan2.Template = function(codeObj, text, compiler2, options) {
      codeObj = codeObj || {};
      this.r = codeObj.code || this.r;
      this.c = compiler2;
      this.options = options || {};
      this.text = text || "";
      this.partials = codeObj.partials || {};
      this.subs = codeObj.subs || {};
      this.buf = "";
    };
    Hogan2.Template.prototype = {
      r: function(context, partials, indent) {
        return "";
      },
      v: hoganEscape,
      t: coerceToString,
      render: function render2(context, partials, indent) {
        return this.ri([context], partials || {}, indent);
      },
      ri: function(context, partials, indent) {
        return this.r(context, partials, indent);
      },
      ep: function(symbol, partials) {
        var partial = this.partials[symbol];
        var template2 = partials[partial.name];
        if (partial.instance && partial.base == template2) {
          return partial.instance;
        }
        if (typeof template2 == "string") {
          if (!this.c) {
            throw new Error("No compiler available.");
          }
          template2 = this.c.compile(template2, this.options);
        }
        if (!template2) {
          return null;
        }
        this.partials[symbol].base = template2;
        if (partial.subs) {
          if (!partials.stackText)
            partials.stackText = {};
          for (key in partial.subs) {
            if (!partials.stackText[key]) {
              partials.stackText[key] = this.activeSub !== void 0 && partials.stackText[this.activeSub] ? partials.stackText[this.activeSub] : this.text;
            }
          }
          template2 = createSpecializedPartial(template2, partial.subs, partial.partials, this.stackSubs, this.stackPartials, partials.stackText);
        }
        this.partials[symbol].instance = template2;
        return template2;
      },
      rp: function(symbol, context, partials, indent) {
        var partial = this.ep(symbol, partials);
        if (!partial) {
          return "";
        }
        return partial.ri(context, partials, indent);
      },
      rs: function(context, partials, section) {
        var tail = context[context.length - 1];
        if (!isArray2(tail)) {
          section(context, partials, this);
          return;
        }
        for (var i2 = 0; i2 < tail.length; i2++) {
          context.push(tail[i2]);
          section(context, partials, this);
          context.pop();
        }
      },
      s: function(val, ctx, partials, inverted, start2, end2, tags) {
        var pass;
        if (isArray2(val) && val.length === 0) {
          return false;
        }
        if (typeof val == "function") {
          val = this.ms(val, ctx, partials, inverted, start2, end2, tags);
        }
        pass = !!val;
        if (!inverted && pass && ctx) {
          ctx.push(typeof val == "object" ? val : ctx[ctx.length - 1]);
        }
        return pass;
      },
      d: function(key2, ctx, partials, returnFound) {
        var found, names = key2.split("."), val = this.f(names[0], ctx, partials, returnFound), doModelGet = this.options.modelGet, cx = null;
        if (key2 === "." && isArray2(ctx[ctx.length - 2])) {
          val = ctx[ctx.length - 1];
        } else {
          for (var i2 = 1; i2 < names.length; i2++) {
            found = findInScope(names[i2], val, doModelGet);
            if (found !== void 0) {
              cx = val;
              val = found;
            } else {
              val = "";
            }
          }
        }
        if (returnFound && !val) {
          return false;
        }
        if (!returnFound && typeof val == "function") {
          ctx.push(cx);
          val = this.mv(val, ctx, partials);
          ctx.pop();
        }
        return val;
      },
      f: function(key2, ctx, partials, returnFound) {
        var val = false, v2 = null, found = false, doModelGet = this.options.modelGet;
        for (var i2 = ctx.length - 1; i2 >= 0; i2--) {
          v2 = ctx[i2];
          val = findInScope(key2, v2, doModelGet);
          if (val !== void 0) {
            found = true;
            break;
          }
        }
        if (!found) {
          return returnFound ? false : "";
        }
        if (!returnFound && typeof val == "function") {
          val = this.mv(val, ctx, partials);
        }
        return val;
      },
      ls: function(func, cx, partials, text, tags) {
        var oldTags = this.options.delimiters;
        this.options.delimiters = tags;
        this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
        this.options.delimiters = oldTags;
        return false;
      },
      ct: function(text, cx, partials) {
        if (this.options.disableLambda) {
          throw new Error("Lambda features disabled.");
        }
        return this.c.compile(text, this.options).render(cx, partials);
      },
      b: function(s2) {
        this.buf += s2;
      },
      fl: function() {
        var r2 = this.buf;
        this.buf = "";
        return r2;
      },
      ms: function(func, ctx, partials, inverted, start2, end2, tags) {
        var textSource, cx = ctx[ctx.length - 1], result = func.call(cx);
        if (typeof result == "function") {
          if (inverted) {
            return true;
          } else {
            textSource = this.activeSub && this.subsText && this.subsText[this.activeSub] ? this.subsText[this.activeSub] : this.text;
            return this.ls(result, cx, partials, textSource.substring(start2, end2), tags);
          }
        }
        return result;
      },
      mv: function(func, ctx, partials) {
        var cx = ctx[ctx.length - 1];
        var result = func.call(cx);
        if (typeof result == "function") {
          return this.ct(coerceToString(result.call(cx)), cx, partials);
        }
        return result;
      },
      sub: function(name, context, partials, indent) {
        var f2 = this.subs[name];
        if (f2) {
          this.activeSub = name;
          f2(context, partials, this, indent);
          this.activeSub = false;
        }
      }
    };
    function findInScope(key2, scope, doModelGet) {
      var val;
      if (scope && typeof scope == "object") {
        if (scope[key2] !== void 0) {
          val = scope[key2];
        } else if (doModelGet && scope.get && typeof scope.get == "function") {
          val = scope.get(key2);
        }
      }
      return val;
    }
    function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
      function PartialTemplate() {
      }
      PartialTemplate.prototype = instance;
      function Substitutions() {
      }
      Substitutions.prototype = instance.subs;
      var key2;
      var partial = new PartialTemplate();
      partial.subs = new Substitutions();
      partial.subsText = {};
      partial.buf = "";
      stackSubs = stackSubs || {};
      partial.stackSubs = stackSubs;
      partial.subsText = stackText;
      for (key2 in subs) {
        if (!stackSubs[key2])
          stackSubs[key2] = subs[key2];
      }
      for (key2 in stackSubs) {
        partial.subs[key2] = stackSubs[key2];
      }
      stackPartials = stackPartials || {};
      partial.stackPartials = stackPartials;
      for (key2 in partials) {
        if (!stackPartials[key2])
          stackPartials[key2] = partials[key2];
      }
      for (key2 in stackPartials) {
        partial.partials[key2] = stackPartials[key2];
      }
      return partial;
    }
    var rAmp = /&/g, rLt = /</g, rGt = />/g, rApos = /\'/g, rQuot = /\"/g, hChars = /[&<>\"\']/;
    function coerceToString(val) {
      return String(val === null || val === void 0 ? "" : val);
    }
    function hoganEscape(str) {
      str = coerceToString(str);
      return hChars.test(str) ? str.replace(rAmp, "&amp;").replace(rLt, "&lt;").replace(rGt, "&gt;").replace(rApos, "&#39;").replace(rQuot, "&quot;") : str;
    }
    var isArray2 = Array.isArray || function(a2) {
      return Object.prototype.toString.call(a2) === "[object Array]";
    };
  })(exports);
})(template);
var Hogan = compiler;
Hogan.Template = template.Template;
Hogan.template = Hogan.Template;
var hogan = Hogan;
var defaultTemplates = {};
defaultTemplates["file-summary-line"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<li class="d2h-file-list-line">');
  t2.b("\n" + i2);
  t2.b('    <span class="d2h-file-name-wrapper">');
  t2.b("\n" + i2);
  t2.b(t2.rp("<fileIcon0", c2, p2, "      "));
  t2.b('      <a href="#');
  t2.b(t2.v(t2.f("fileHtmlId", c2, p2, 0)));
  t2.b('" class="d2h-file-name">');
  t2.b(t2.v(t2.f("fileName", c2, p2, 0)));
  t2.b("</a>");
  t2.b("\n" + i2);
  t2.b('      <span class="d2h-file-stats">');
  t2.b("\n" + i2);
  t2.b('          <span class="d2h-lines-added">');
  t2.b(t2.v(t2.f("addedLines", c2, p2, 0)));
  t2.b("</span>");
  t2.b("\n" + i2);
  t2.b('          <span class="d2h-lines-deleted">');
  t2.b(t2.v(t2.f("deletedLines", c2, p2, 0)));
  t2.b("</span>");
  t2.b("\n" + i2);
  t2.b("      </span>");
  t2.b("\n" + i2);
  t2.b("    </span>");
  t2.b("\n" + i2);
  t2.b("</li>");
  return t2.fl();
}, partials: { "<fileIcon0": { name: "fileIcon", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["file-summary-wrapper"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<div class="d2h-file-list-wrapper">');
  t2.b("\n" + i2);
  t2.b('    <div class="d2h-file-list-header">');
  t2.b("\n" + i2);
  t2.b('        <span class="d2h-file-list-title">Files changed (');
  t2.b(t2.v(t2.f("filesNumber", c2, p2, 0)));
  t2.b(")</span>");
  t2.b("\n" + i2);
  t2.b('        <a class="d2h-file-switch d2h-hide">hide</a>');
  t2.b("\n" + i2);
  t2.b('        <a class="d2h-file-switch d2h-show">show</a>');
  t2.b("\n" + i2);
  t2.b("    </div>");
  t2.b("\n" + i2);
  t2.b('    <ol class="d2h-file-list">');
  t2.b("\n" + i2);
  t2.b("    ");
  t2.b(t2.t(t2.f("files", c2, p2, 0)));
  t2.b("\n" + i2);
  t2.b("    </ol>");
  t2.b("\n" + i2);
  t2.b("</div>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-block-header"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b("<tr>");
  t2.b("\n" + i2);
  t2.b('    <td class="');
  t2.b(t2.v(t2.f("lineClass", c2, p2, 0)));
  t2.b(" ");
  t2.b(t2.v(t2.d("CSSLineClass.INFO", c2, p2, 0)));
  t2.b('"></td>');
  t2.b("\n" + i2);
  t2.b('    <td class="');
  t2.b(t2.v(t2.d("CSSLineClass.INFO", c2, p2, 0)));
  t2.b('">');
  t2.b("\n" + i2);
  t2.b('        <div class="');
  t2.b(t2.v(t2.f("contentClass", c2, p2, 0)));
  t2.b('">');
  t2.b(t2.t(t2.f("blockHeader", c2, p2, 0)));
  t2.b("</div>");
  t2.b("\n" + i2);
  t2.b("    </td>");
  t2.b("\n" + i2);
  t2.b("</tr>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-empty-diff"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b("<tr>");
  t2.b("\n" + i2);
  t2.b('    <td class="');
  t2.b(t2.v(t2.d("CSSLineClass.INFO", c2, p2, 0)));
  t2.b('">');
  t2.b("\n" + i2);
  t2.b('        <div class="');
  t2.b(t2.v(t2.f("contentClass", c2, p2, 0)));
  t2.b('">');
  t2.b("\n" + i2);
  t2.b("            File without changes");
  t2.b("\n" + i2);
  t2.b("        </div>");
  t2.b("\n" + i2);
  t2.b("    </td>");
  t2.b("\n" + i2);
  t2.b("</tr>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-file-path"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<span class="d2h-file-name-wrapper">');
  t2.b("\n" + i2);
  t2.b(t2.rp("<fileIcon0", c2, p2, "    "));
  t2.b('    <span class="d2h-file-name">');
  t2.b(t2.v(t2.f("fileDiffName", c2, p2, 0)));
  t2.b("</span>");
  t2.b("\n" + i2);
  t2.b(t2.rp("<fileTag1", c2, p2, "    "));
  t2.b("</span>");
  t2.b("\n" + i2);
  t2.b('<label class="d2h-file-collapse">');
  t2.b("\n" + i2);
  t2.b('    <input class="d2h-file-collapse-input" type="checkbox" name="viewed" value="viewed">');
  t2.b("\n" + i2);
  t2.b("    Viewed");
  t2.b("\n" + i2);
  t2.b("</label>");
  return t2.fl();
}, partials: { "<fileIcon0": { name: "fileIcon", partials: {}, subs: {} }, "<fileTag1": { name: "fileTag", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["generic-line"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b("<tr>");
  t2.b("\n" + i2);
  t2.b('    <td class="');
  t2.b(t2.v(t2.f("lineClass", c2, p2, 0)));
  t2.b(" ");
  t2.b(t2.v(t2.f("type", c2, p2, 0)));
  t2.b('">');
  t2.b("\n" + i2);
  t2.b("      ");
  t2.b(t2.t(t2.f("lineNumber", c2, p2, 0)));
  t2.b("\n" + i2);
  t2.b("    </td>");
  t2.b("\n" + i2);
  t2.b('    <td class="');
  t2.b(t2.v(t2.f("type", c2, p2, 0)));
  t2.b('">');
  t2.b("\n" + i2);
  t2.b('        <div class="');
  t2.b(t2.v(t2.f("contentClass", c2, p2, 0)));
  t2.b('">');
  t2.b("\n" + i2);
  if (t2.s(t2.f("prefix", c2, p2, 1), c2, p2, 0, 162, 238, "{{ }}")) {
    t2.rs(c2, p2, function(c3, p3, t3) {
      t3.b('            <span class="d2h-code-line-prefix">');
      t3.b(t3.t(t3.f("prefix", c3, p3, 0)));
      t3.b("</span>");
      t3.b("\n" + i2);
    });
    c2.pop();
  }
  if (!t2.s(t2.f("prefix", c2, p2, 1), c2, p2, 1, 0, 0, "")) {
    t2.b('            <span class="d2h-code-line-prefix">&nbsp;</span>');
    t2.b("\n" + i2);
  }
  if (t2.s(t2.f("content", c2, p2, 1), c2, p2, 0, 371, 445, "{{ }}")) {
    t2.rs(c2, p2, function(c3, p3, t3) {
      t3.b('            <span class="d2h-code-line-ctn">');
      t3.b(t3.t(t3.f("content", c3, p3, 0)));
      t3.b("</span>");
      t3.b("\n" + i2);
    });
    c2.pop();
  }
  if (!t2.s(t2.f("content", c2, p2, 1), c2, p2, 1, 0, 0, "")) {
    t2.b('            <span class="d2h-code-line-ctn"><br></span>');
    t2.b("\n" + i2);
  }
  t2.b("        </div>");
  t2.b("\n" + i2);
  t2.b("    </td>");
  t2.b("\n" + i2);
  t2.b("</tr>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-wrapper"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<div class="d2h-wrapper">');
  t2.b("\n" + i2);
  t2.b("    ");
  t2.b(t2.t(t2.f("content", c2, p2, 0)));
  t2.b("\n" + i2);
  t2.b("</div>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-added"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<svg aria-hidden="true" class="d2h-icon d2h-added" height="16" title="added" version="1.1" viewBox="0 0 14 16"');
  t2.b("\n" + i2);
  t2.b('     width="14">');
  t2.b("\n" + i2);
  t2.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM6 9H3V7h3V4h2v3h3v2H8v3H6V9z"></path>');
  t2.b("\n" + i2);
  t2.b("</svg>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-changed"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<svg aria-hidden="true" class="d2h-icon d2h-changed" height="16" title="modified" version="1.1"');
  t2.b("\n" + i2);
  t2.b('     viewBox="0 0 14 16" width="14">');
  t2.b("\n" + i2);
  t2.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM4 8c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3z"></path>');
  t2.b("\n" + i2);
  t2.b("</svg>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-deleted"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<svg aria-hidden="true" class="d2h-icon d2h-deleted" height="16" title="removed" version="1.1"');
  t2.b("\n" + i2);
  t2.b('     viewBox="0 0 14 16" width="14">');
  t2.b("\n" + i2);
  t2.b('    <path d="M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM11 9H3V7h8v2z"></path>');
  t2.b("\n" + i2);
  t2.b("</svg>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-renamed"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<svg aria-hidden="true" class="d2h-icon d2h-moved" height="16" title="renamed" version="1.1"');
  t2.b("\n" + i2);
  t2.b('     viewBox="0 0 14 16" width="14">');
  t2.b("\n" + i2);
  t2.b('    <path d="M6 9H3V7h3V4l5 4-5 4V9z m8-7v12c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h12c0.55 0 1 0.45 1 1z m-1 0H1v12h12V2z"></path>');
  t2.b("\n" + i2);
  t2.b("</svg>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<svg aria-hidden="true" class="d2h-icon" height="16" version="1.1" viewBox="0 0 12 16" width="12">');
  t2.b("\n" + i2);
  t2.b('    <path d="M6 5H2v-1h4v1zM2 8h7v-1H2v1z m0 2h7v-1H2v1z m0 2h7v-1H2v1z m10-7.5v9.5c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h7.5l3.5 3.5z m-1 0.5L8 2H1v12h10V5z"></path>');
  t2.b("\n" + i2);
  t2.b("</svg>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["line-by-line-file-diff"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<div id="');
  t2.b(t2.v(t2.f("fileHtmlId", c2, p2, 0)));
  t2.b('" class="d2h-file-wrapper" data-lang="');
  t2.b(t2.v(t2.d("file.language", c2, p2, 0)));
  t2.b('">');
  t2.b("\n" + i2);
  t2.b('    <div class="d2h-file-header">');
  t2.b("\n" + i2);
  t2.b("    ");
  t2.b(t2.t(t2.f("filePath", c2, p2, 0)));
  t2.b("\n" + i2);
  t2.b("    </div>");
  t2.b("\n" + i2);
  t2.b('    <div class="d2h-file-diff">');
  t2.b("\n" + i2);
  t2.b('        <div class="d2h-code-wrapper">');
  t2.b("\n" + i2);
  t2.b('            <table class="d2h-diff-table">');
  t2.b("\n" + i2);
  t2.b('                <tbody class="d2h-diff-tbody">');
  t2.b("\n" + i2);
  t2.b("                ");
  t2.b(t2.t(t2.f("diffs", c2, p2, 0)));
  t2.b("\n" + i2);
  t2.b("                </tbody>");
  t2.b("\n" + i2);
  t2.b("            </table>");
  t2.b("\n" + i2);
  t2.b("        </div>");
  t2.b("\n" + i2);
  t2.b("    </div>");
  t2.b("\n" + i2);
  t2.b("</div>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["line-by-line-numbers"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<div class="line-num1">');
  t2.b(t2.v(t2.f("oldNumber", c2, p2, 0)));
  t2.b("</div>");
  t2.b("\n" + i2);
  t2.b('<div class="line-num2">');
  t2.b(t2.v(t2.f("newNumber", c2, p2, 0)));
  t2.b("</div>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["side-by-side-file-diff"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<div id="');
  t2.b(t2.v(t2.f("fileHtmlId", c2, p2, 0)));
  t2.b('" class="d2h-file-wrapper" data-lang="');
  t2.b(t2.v(t2.d("file.language", c2, p2, 0)));
  t2.b('">');
  t2.b("\n" + i2);
  t2.b('    <div class="d2h-file-header">');
  t2.b("\n" + i2);
  t2.b("      ");
  t2.b(t2.t(t2.f("filePath", c2, p2, 0)));
  t2.b("\n" + i2);
  t2.b("    </div>");
  t2.b("\n" + i2);
  t2.b('    <div class="d2h-files-diff">');
  t2.b("\n" + i2);
  t2.b('        <div class="d2h-file-side-diff">');
  t2.b("\n" + i2);
  t2.b('            <div class="d2h-code-wrapper">');
  t2.b("\n" + i2);
  t2.b('                <table class="d2h-diff-table">');
  t2.b("\n" + i2);
  t2.b('                    <tbody class="d2h-diff-tbody">');
  t2.b("\n" + i2);
  t2.b("                    ");
  t2.b(t2.t(t2.d("diffs.left", c2, p2, 0)));
  t2.b("\n" + i2);
  t2.b("                    </tbody>");
  t2.b("\n" + i2);
  t2.b("                </table>");
  t2.b("\n" + i2);
  t2.b("            </div>");
  t2.b("\n" + i2);
  t2.b("        </div>");
  t2.b("\n" + i2);
  t2.b('        <div class="d2h-file-side-diff">');
  t2.b("\n" + i2);
  t2.b('            <div class="d2h-code-wrapper">');
  t2.b("\n" + i2);
  t2.b('                <table class="d2h-diff-table">');
  t2.b("\n" + i2);
  t2.b('                    <tbody class="d2h-diff-tbody">');
  t2.b("\n" + i2);
  t2.b("                    ");
  t2.b(t2.t(t2.d("diffs.right", c2, p2, 0)));
  t2.b("\n" + i2);
  t2.b("                    </tbody>");
  t2.b("\n" + i2);
  t2.b("                </table>");
  t2.b("\n" + i2);
  t2.b("            </div>");
  t2.b("\n" + i2);
  t2.b("        </div>");
  t2.b("\n" + i2);
  t2.b("    </div>");
  t2.b("\n" + i2);
  t2.b("</div>");
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-added"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<span class="d2h-tag d2h-added d2h-added-tag">ADDED</span>');
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-changed"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<span class="d2h-tag d2h-changed d2h-changed-tag">CHANGED</span>');
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-deleted"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<span class="d2h-tag d2h-deleted d2h-deleted-tag">DELETED</span>');
  return t2.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-renamed"] = new hogan.Template({ code: function(c2, p2, i2) {
  var t2 = this;
  t2.b(i2 = i2 || "");
  t2.b('<span class="d2h-tag d2h-moved d2h-moved-tag">RENAMED</span>');
  return t2.fl();
}, partials: {}, subs: {} });
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var HoganJsUtils = function() {
  function HoganJsUtils2(_a) {
    var _b = _a.compiledTemplates, compiledTemplates = _b === void 0 ? {} : _b, _c = _a.rawTemplates, rawTemplates = _c === void 0 ? {} : _c;
    var compiledRawTemplates = Object.entries(rawTemplates).reduce(function(previousTemplates, _a2) {
      var _b2;
      var name = _a2[0], templateString = _a2[1];
      var compiledTemplate = hogan.compile(templateString, { asString: false });
      return __assign$1(__assign$1({}, previousTemplates), (_b2 = {}, _b2[name] = compiledTemplate, _b2));
    }, {});
    this.preCompiledTemplates = __assign$1(__assign$1(__assign$1({}, defaultTemplates), compiledTemplates), compiledRawTemplates);
  }
  HoganJsUtils2.compile = function(templateString) {
    return hogan.compile(templateString, { asString: false });
  };
  HoganJsUtils2.prototype.render = function(namespace, view, params, partials, indent) {
    var templateKey = this.templateKey(namespace, view);
    try {
      var template2 = this.preCompiledTemplates[templateKey];
      return template2.render(params, partials, indent);
    } catch (e) {
      throw new Error("Could not find template to render '".concat(templateKey, "'"));
    }
  };
  HoganJsUtils2.prototype.template = function(namespace, view) {
    return this.preCompiledTemplates[this.templateKey(namespace, view)];
  };
  HoganJsUtils2.prototype.templateKey = function(namespace, view) {
    return "".concat(namespace, "-").concat(view);
  };
  return HoganJsUtils2;
}();
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var defaultDiff2HtmlConfig = __assign(__assign(__assign({}, defaultLineByLineRendererConfig), defaultSideBySideRendererConfig), { outputFormat: OutputFormatType.LINE_BY_LINE, drawFileList: true });
function html(diffInput, configuration) {
  if (configuration === void 0) {
    configuration = {};
  }
  var config = __assign(__assign({}, defaultDiff2HtmlConfig), configuration);
  var diffJson = typeof diffInput === "string" ? parse(diffInput, config) : diffInput;
  var hoganUtils = new HoganJsUtils(config);
  var fileList = config.drawFileList ? render(diffJson, hoganUtils) : "";
  var diffOutput = config.outputFormat === "side-by-side" ? new SideBySideRenderer(hoganUtils, config).render(diffJson) : new LineByLineRenderer(hoganUtils, config).render(diffJson);
  return fileList + diffOutput;
}
const diffFormats = ["side-by-side", "line-by-line"];
const CodeDiffFormat = stringEnum([...diffFormats]);
const themes = ["dark", "light"];
const themesEnum = stringEnum([...themes]);
const codeDiffProps = {
  oldContent: E().def(""),
  newContent: E().def(""),
  diffFormat: E().def(CodeDiffFormat["line-by-line"]),
  diffContext: N(),
  theme: E().def("light"),
  language: E().def("javascript"),
  hljs: PropTypes.any.isRequired
};
function changeCodeCls(htmlStr, lang) {
  return htmlStr.replace(/d2h-code-line-ctn/g, ($1) => `${$1} lang-${lang}`);
}
var CodeDiff = defineComponent({
  name: "CodeDiff",
  props: codeDiffProps,
  emits: [],
  setup(props2) {
    const diffBox = ref(null);
    const diffHtml = ref("");
    const diffBoxCls = computed(() => classes({
      dark: props2.theme === themesEnum.dark
    }, "hljs lesscode-bk-code-diff"));
    function highlightElement() {
      nextTick(() => {
        if (diffBox.value) {
          diffBox.value.querySelectorAll(`.lang-${props2.language}`).forEach((item) => {
            props2.hljs.highlightElement(item);
          });
        }
      });
    }
    function generateDiffHTML(diffContext, language) {
      const dd = createPatch("", props2.oldContent, props2.newContent, "", "", {
        context: diffContext
      });
      diffHtml.value = changeCodeCls(html(dd, {
        drawFileList: false,
        matching: "lines",
        outputFormat: props2.diffFormat
      }), language);
      highlightElement();
    }
    onMounted(() => {
      generateDiffHTML(props2.diffContext, props2.language);
    });
    watch(() => [props2.diffContext, props2.language], (newVal) => {
      const [newContext, newLanguage] = newVal;
      generateDiffHTML(newContext, newLanguage);
    });
    return () => createVNode("div", {
      "ref": diffBox,
      "class": diffBoxCls.value,
      "innerHTML": diffHtml.value
    }, null);
  }
});
const BkCodeDiff = withInstall(CodeDiff);
var tinycolor$1 = { exports: {} };
(function(module) {
  (function(Math2) {
    var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
    function tinycolor2(color, opts) {
      color = color ? color : "";
      opts = opts || {};
      if (color instanceof tinycolor2) {
        return color;
      }
      if (!(this instanceof tinycolor2)) {
        return new tinycolor2(color, opts);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) {
        this._r = mathRound(this._r);
      }
      if (this._g < 1) {
        this._g = mathRound(this._g);
      }
      if (this._b < 1) {
        this._b = mathRound(this._b);
      }
      this._ok = rgb.ok;
      this._tc_id = tinyCounter++;
    }
    tinycolor2.prototype = {
      isDark: function() {
        return this.getBrightness() < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      isValid: function() {
        return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
        return this._format;
      },
      getAlpha: function() {
        return this._a;
      },
      getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R2, G, B2;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R2 = RsRGB / 12.92;
        } else {
          R2 = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R2 + 0.7152 * G + 0.0722 * B2;
      },
      setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100 * this._a) / 100;
        return this;
      },
      toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
      },
      toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h2 = mathRound(hsv.h * 360), s2 = mathRound(hsv.s * 100), v2 = mathRound(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
      },
      toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
      },
      toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h2 = mathRound(hsl.h * 360), s2 = mathRound(hsl.s * 100), l2 = mathRound(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
      },
      toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
      },
      toRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
      },
      toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s2 = tinycolor2(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function(format2) {
        var formatSet = !!format2;
        format2 = format2 || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function() {
        return tinycolor2(this.toString());
      },
      _applyModification: function(fn2, args) {
        var color = fn2.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function() {
        return this._applyModification(lighten, arguments);
      },
      brighten: function() {
        return this._applyModification(brighten, arguments);
      },
      darken: function() {
        return this._applyModification(darken, arguments);
      },
      desaturate: function() {
        return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
        return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
        return this._applyModification(greyscale, arguments);
      },
      spin: function() {
        return this._applyModification(spin, arguments);
      },
      _applyCombination: function(fn2, args) {
        return fn2.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
        return this._applyCombination(analogous, arguments);
      },
      complement: function() {
        return this._applyCombination(complement, arguments);
      },
      monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
        return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
        return this._applyCombination(tetrad, arguments);
      }
    };
    tinycolor2.fromRatio = function(color, opts) {
      if (typeof color == "object") {
        var newColor = {};
        for (var i2 in color) {
          if (color.hasOwnProperty(i2)) {
            if (i2 === "a") {
              newColor[i2] = color[i2];
            } else {
              newColor[i2] = convertToPercentage(color[i2]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor2(color, opts);
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a2 = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok = false;
      var format2 = false;
      if (typeof color == "string") {
        color = stringInputToObject(color);
      }
      if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s2 = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s2, v2);
          ok = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s2 = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s2, l2);
          ok = true;
          format2 = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a2 = color.a;
        }
      }
      a2 = boundAlpha(a2);
      return {
        ok,
        format: color.format || format2,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a2
      };
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
      var h2, s2, l2 = (max2 + min2) / 2;
      if (max2 == min2) {
        h2 = s2 = 0;
      } else {
        var d2 = max2 - min2;
        s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, l: l2 };
    }
    function hslToRgb(h2, s2, l2) {
      var r2, g2, b2;
      h2 = bound01(h2, 360);
      s2 = bound01(s2, 100);
      l2 = bound01(l2, 100);
      function hue2rgb(p3, q3, t2) {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p3 + (q3 - p3) * 6 * t2;
        if (t2 < 1 / 2)
          return q3;
        if (t2 < 2 / 3)
          return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
        return p3;
      }
      if (s2 === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
      var h2, s2, v2 = max2;
      var d2 = max2 - min2;
      s2 = max2 === 0 ? 0 : d2 / max2;
      if (max2 == min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, v: v2 };
    }
    function hsvToRgb(h2, s2, v2) {
      h2 = bound01(h2, 360) * 6;
      s2 = bound01(s2, 100);
      v2 = bound01(v2, 100);
      var i2 = Math2.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod], g2 = [t2, v2, v2, q2, p2, p2][mod], b2 = [p2, p2, t2, v2, v2, q2][mod];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex = [
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16))
      ];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r2, g2, b2, a2, allow4Char) {
      var hex = [
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16)),
        pad2(convertDecimalToHex(a2))
      ];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r2, g2, b2, a2) {
      var hex = [
        pad2(convertDecimalToHex(a2)),
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16))
      ];
      return hex.join("");
    }
    tinycolor2.equals = function(color1, color2) {
      if (!color1 || !color2) {
        return false;
      }
      return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
    };
    tinycolor2.random = function() {
      return tinycolor2.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
      });
    };
    function desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor2(hsl);
    }
    function saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor2(hsl);
    }
    function greyscale(color) {
      return tinycolor2(color).desaturate(100);
    }
    function lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor2(hsl);
    }
    function brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor2(color).toRgb();
      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
      return tinycolor2(rgb);
    }
    function darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor2(hsl);
    }
    function spin(color, amount) {
      var hsl = tinycolor2(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor2(hsl);
    }
    function complement(color) {
      var hsl = tinycolor2(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor2(hsl);
    }
    function triad(color) {
      var hsl = tinycolor2(color).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h2 + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 240) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function tetrad(color) {
      var hsl = tinycolor2(color).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h2 + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 270) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function splitcomplement(color) {
      var hsl = tinycolor2(color).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor2(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor2(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor2(hsl));
      }
      return ret;
    }
    function monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor2(color).toHsv();
      var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor2({ h: h2, s: s2, v: v2 }));
        v2 = (v2 + modification) % 1;
      }
      return ret;
    }
    tinycolor2.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor2(color1).toRgb();
      var rgb2 = tinycolor2(color2).toRgb();
      var p2 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return tinycolor2(rgba);
    };
    tinycolor2.readability = function(color1, color2) {
      var c1 = tinycolor2(color1);
      var c2 = tinycolor2(color2);
      return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor2.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor2.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor2.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size = args.size;
      for (var i2 = 0; i2 < colorList.length; i2++) {
        readability = tinycolor2.readability(baseColor, colorList[i2]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor2(colorList[i2]);
        }
      }
      if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor2.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor2.hexNames = flip2(names);
    function flip2(o2) {
      var flipped = {};
      for (var i2 in o2) {
        if (o2.hasOwnProperty(i2)) {
          flipped[o2[i2]] = i2;
        }
      }
      return flipped;
    }
    function boundAlpha(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function bound01(n2, max2) {
      if (isOnePointZero(n2)) {
        n2 = "100%";
      }
      var processPercent = isPercentage(n2);
      n2 = mathMin(max2, mathMax(0, parseFloat(n2)));
      if (processPercent) {
        n2 = parseInt(n2 * max2, 10) / 100;
      }
      if (Math2.abs(n2 - max2) < 1e-6) {
        return 1;
      }
      return n2 % max2 / parseFloat(max2);
    }
    function clamp01(val) {
      return mathMin(1, mathMax(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n2) {
      return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") != -1;
    }
    function pad2(c2) {
      return c2.length == 1 ? "0" + c2 : "" + c2;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        n2 = n2 * 100 + "%";
      }
      return n2;
    }
    function convertDecimalToHex(d2) {
      return Math2.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
    }
    function stringInputToObject(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color == "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match2;
      if (match2 = matchers.rgb.exec(color)) {
        return { r: match2[1], g: match2[2], b: match2[3] };
      }
      if (match2 = matchers.rgba.exec(color)) {
        return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
      }
      if (match2 = matchers.hsl.exec(color)) {
        return { h: match2[1], s: match2[2], l: match2[3] };
      }
      if (match2 = matchers.hsla.exec(color)) {
        return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
      }
      if (match2 = matchers.hsv.exec(color)) {
        return { h: match2[1], s: match2[2], v: match2[3] };
      }
      if (match2 = matchers.hsva.exec(color)) {
        return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
      }
      if (match2 = matchers.hex8.exec(color)) {
        return {
          r: parseIntFromHex(match2[1]),
          g: parseIntFromHex(match2[2]),
          b: parseIntFromHex(match2[3]),
          a: convertHexToDecimal(match2[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match2 = matchers.hex6.exec(color)) {
        return {
          r: parseIntFromHex(match2[1]),
          g: parseIntFromHex(match2[2]),
          b: parseIntFromHex(match2[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match2 = matchers.hex4.exec(color)) {
        return {
          r: parseIntFromHex(match2[1] + "" + match2[1]),
          g: parseIntFromHex(match2[2] + "" + match2[2]),
          b: parseIntFromHex(match2[3] + "" + match2[3]),
          a: convertHexToDecimal(match2[4] + "" + match2[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match2 = matchers.hex3.exec(color)) {
        return {
          r: parseIntFromHex(match2[1] + "" + match2[1]),
          g: parseIntFromHex(match2[2] + "" + match2[2]),
          b: parseIntFromHex(match2[3] + "" + match2[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size;
      parms = parms || { "level": "AA", "size": "small" };
      level = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size !== "small" && size !== "large") {
        size = "small";
      }
      return { "level": level, "size": size };
    }
    if (module.exports) {
      module.exports = tinycolor2;
    } else {
      window.tinycolor = tinycolor2;
    }
  })(Math);
})(tinycolor$1);
var tinycolor = tinycolor$1.exports;
const inputContainerProps = {
  info: PropTypes.object.isRequired
};
var InputContainer = defineComponent({
  props: inputContainerProps,
  emits: ["tab", "input"],
  setup(props2, {
    emit
  }) {
    const handleTab = (e) => {
      if (props2.info.key === "a") {
        emit("tab", e);
      }
    };
    const handleInput = (e) => {
      const {
        key: key2
      } = props2.info;
      const {
        value
      } = e.target;
      emit("input", key2, value);
    };
    const colorPickerCls = computed(() => classes({
      error: props2.info.error
    }, "lesscode-bk-color-picker-input-value"));
    return () => createVNode("div", {
      "class": "lesscode-bk-color-picker-input-part"
    }, [createVNode("input", {
      "type": props2.info.name === "HEX" ? "text" : "number",
      "class": colorPickerCls.value,
      "value": props2.info.value,
      "onKeydown": handleTab,
      "onInput": handleInput
    }, null), createVNode("span", {
      "class": "lesscode-bk-color-picker-input-text"
    }, [props2.info.name])]);
  }
});
const colorPickerProps$4 = {
  colorObj: PropTypes.object.isRequired
};
var ColorInput = defineComponent({
  name: "ColorPicker",
  props: colorPickerProps$4,
  emits: ["change", "tab"],
  setup(props2, {
    emit
  }) {
    const hex = reactive({
      key: "hex",
      name: "HEX",
      value: props2.colorObj.hex,
      error: false
    });
    const r2 = reactive({
      key: "r",
      name: "R",
      value: props2.colorObj.rgba.r.toString(),
      error: false
    });
    const g2 = reactive({
      key: "g",
      name: "G",
      value: props2.colorObj.rgba.g.toString(),
      error: false
    });
    const b2 = reactive({
      key: "b",
      name: "B",
      value: props2.colorObj.rgba.b.toString(),
      error: false
    });
    const a2 = reactive({
      key: "a",
      name: "Alpha",
      value: props2.colorObj.rgba.a.toString(),
      error: false
    });
    watch(() => props2.colorObj, (val) => {
      if (tinycolor(val.hex).toString() !== tinycolor(hex.value).toString()) {
        hex.value = val.hex;
      }
      r2.value = val.rgba.r.toString();
      g2.value = val.rgba.g.toString();
      b2.value = val.rgba.b.toString();
      a2.value = val.rgba.a.toString();
      validate();
    }, {
      deep: true
    });
    const handleAlphaTab = (e) => {
      emit("tab", e);
    };
    const handleInput = (key2, value) => {
      const colorList = {
        r: r2,
        g: g2,
        b: b2,
        a: a2,
        hex
      };
      colorList[key2].value = value;
      if (validate()) {
        const colorStr = key2 === "hex" ? hex.value : `rgba(${r2.value}, ${g2.value}, ${b2.value}, ${a2.value})`;
        emit("change", colorStr);
      }
    };
    const validate = () => {
      let result = true;
      if (hex.value.startsWith("#") && (hex.value.length === 4 || hex.value.length === 7) && !hex.value.slice(1).match(/[^0-9a-fA-F]/)) {
        hex.error = false;
      } else {
        hex.error = true;
        result = false;
      }
      if (a2.value !== "" && a2.value >= 0 && a2.value <= 1) {
        a2.error = false;
      } else {
        a2.error = true;
        result = false;
      }
      for (const colorInfo of [r2, g2, b2]) {
        const {
          value
        } = colorInfo;
        if (value !== "" && value >= 0 && value <= 255) {
          colorInfo.error = false;
        } else {
          colorInfo.error = true;
          result = false;
        }
      }
      return result;
    };
    return () => createVNode("div", {
      "class": "lesscode-bk-color-picker-input"
    }, [createVNode("div", {
      "class": "lesscode-bk-color-picker-input-hex"
    }, [createVNode(InputContainer, {
      "info": hex,
      "onInput": handleInput
    }, null)]), createVNode("div", {
      "class": "lesscode-bk-color-picker-input-rgba"
    }, [createVNode(InputContainer, {
      "info": r2,
      "onInput": handleInput
    }, null), createVNode(InputContainer, {
      "info": g2,
      "onInput": handleInput
    }, null), createVNode(InputContainer, {
      "info": b2,
      "onInput": handleInput
    }, null), createVNode(InputContainer, {
      "info": a2,
      "onInput": handleInput,
      "onTab": handleAlphaTab
    }, null)])]);
  }
});
const formatColor = (colorParam) => {
  let colorValue = colorParam;
  if (colorParam === "") {
    colorValue = "#FFFFFF";
  }
  const tinyColor = tinycolor(colorParam);
  const hsl = tinyColor.toHsl();
  const hsv = tinyColor.toHsv();
  if (hsl.s === 0) {
    hsl.h = colorValue.h || 0;
    hsv.h = colorValue.h || 0;
  }
  if (hsv.v < 0.0164) {
    hsv.h = colorValue.h || 0;
    hsv.s = colorValue.s || 0;
  }
  if (hsl.l < 0.01) {
    hsl.h = colorValue.h || 0;
    hsl.s = colorValue.s || 0;
  }
  return {
    hsl,
    hsv,
    hex: tinyColor.toHexString().toUpperCase(),
    rgba: tinyColor.toRgb()
  };
};
const clamp = (value, min2, max2) => {
  if (value < min2) {
    return min2;
  }
  if (value > max2) {
    return max2;
  }
  return value;
};
const getTouches = (e, prop) => e.touches ? e.touches[0][prop] : 0;
const toRGBAString = (rgba) => {
  const { r: r2, g: g2, b: b2, a: a2 } = rgba;
  return `rgba(${[r2, g2, b2, a2].join(",")})`;
};
const colorPickerProps$3 = {
  colorObj: PropTypes.object.isRequired
};
var HueSlider = defineComponent({
  name: "ColorPicker",
  props: colorPickerProps$3,
  emits: ["change"],
  setup(props2, {
    emit
  }) {
    const containerRef = ref(null);
    const pointerStyle = computed(() => ({
      left: `${props2.colorObj.hsv.h / 360 * 100}%`
    }));
    const handleArrowKeydown = (e) => {
      const {
        clientWidth
      } = containerRef.value;
      let left2 = props2.colorObj.hsv.h / 360 * clientWidth;
      const step = 2;
      const hugeStep = 10;
      switch (e.code) {
        case "ArrowLeft":
          e.preventDefault();
          left2 = clamp(left2 - step, 0, clientWidth);
          break;
        case "ArrowRight":
          e.preventDefault();
          left2 = clamp(left2 + step, 0, clientWidth);
          break;
        case "ArrowUp":
          e.preventDefault();
          left2 = clamp(left2 - hugeStep, 0, clientWidth);
          break;
        case "ArrowDown":
          e.preventDefault();
          left2 = clamp(left2 + hugeStep, 0, clientWidth);
          break;
        default:
          return;
      }
      handlePointChange(null, left2);
    };
    const handleMouseDown = (e) => {
      containerRef.value.focus();
      handlePointChange(e);
      window.addEventListener("mousemove", handlePointChange, {
        passive: true
      });
      window.addEventListener("mouseup", handleMouseUp);
    };
    const handleMouseUp = () => {
      window.removeEventListener("mousemove", handlePointChange);
      window.removeEventListener("mouseup", handleMouseUp);
    };
    const handlePointChange = (e, appointedLeft) => {
      const {
        clientWidth
      } = containerRef.value;
      const left2 = appointedLeft !== void 0 ? appointedLeft : getLeft(e);
      changeColor(left2 / clientWidth);
    };
    const getLeft = (e) => {
      const xOffset = containerRef.value.getBoundingClientRect().left + window.pageXOffset;
      const pageX = e.pageX || getTouches(e, "PageX");
      return clamp(pageX - xOffset, 0, containerRef.value.clientWidth);
    };
    const changeColor = (ratio) => {
      const {
        h: h2,
        s: s2,
        l: l2,
        a: a2
      } = props2.colorObj.hsl;
      const newHue = ratio * 360;
      if (h2 !== newHue) {
        emit("change", {
          h: newHue,
          s: s2,
          l: l2,
          a: a2
        });
      }
    };
    return () => createVNode("div", {
      "ref": containerRef,
      "tabindex": "0",
      "class": "lesscode-bk-color-picker-hue",
      "onKeydown": handleArrowKeydown,
      "onMousedown": (e) => {
        e.stopPropagation();
        e.preventDefault();
        handleMouseDown(e);
      }
    }, [createVNode("div", {
      "class": "lesscode-bk-color-picker-hue-pointer",
      "style": pointerStyle.value
    }, [createVNode("div", {
      "class": "lesscode-bk-color-picker-hue-rectangle"
    }, null)])]);
  }
});
const colorPickerProps$2 = {
  colorObj: PropTypes.object.isRequired,
  recommend: PropTypes.oneOfType([PropTypes.array.def(() => []), PropTypes.bool.def(true)]).isRequired
};
var RecommendColors = defineComponent({
  props: colorPickerProps$2,
  emits: ["change", "tab"],
  setup(props2, {
    emit
  }) {
    const isFocused = ref(false);
    const selectedIndex = ref(-1);
    const selectedColor = ref(null);
    watch(() => props2.colorObj, () => {
      selectedIndex.value = -1;
      selectedColor.value = null;
    }, {
      deep: true
    });
    const colors = computed(() => getColorsFromRecommend(props2.recommend));
    const getColorClass = (color, index2) => classes({
      "lesscode-bk-color-picker-empty": color === "",
      "lesscode-bk-color-picker-recommend-selected-color": isFocused.value && selectedIndex.value === index2
    }, "lesscode-bk-color-picker-recommend-color");
    const handleKeydown = (e) => {
      if (e.code === "Tab") {
        emit("tab", e);
      } else {
        let index2 = 0;
        const rowNum = 10;
        const max2 = colors.value.length - 1;
        switch (e.code) {
          case "ArrowLeft":
            e.preventDefault();
            index2 = clamp(selectedIndex.value - 1, 0, max2);
            break;
          case "ArrowRight":
            e.preventDefault();
            index2 = clamp(selectedIndex.value + 1, 0, max2);
            break;
          case "ArrowUp":
            e.preventDefault();
            index2 = clamp(selectedIndex.value - rowNum, 0, max2);
            break;
          case "ArrowDown":
            e.preventDefault();
            index2 = clamp(selectedIndex.value + rowNum, 0, max2);
            break;
          default:
            return;
        }
        selectColor(index2);
      }
    };
    const selectColor = (index2) => {
      const color = colors.value[index2];
      emit("change", color);
      nextTick(() => {
        selectedIndex.value = index2;
        selectedColor.value = color;
      });
    };
    const getColorsFromRecommend = (recommend) => {
      if (recommend === true) {
        return ["", "#ff4500", "#ff8c00", "#ffd700", "#90ee90", "#ddffff", "#00ced1", "#3a84ff", "#a933f5", "#db7093", "#000000", "#494949", "#9B9B9B", "#ffffff"];
      }
      if (Array.isArray(recommend)) {
        return recommend.map((color) => tinycolor(color).isValid() ? color : "");
      }
    };
    return () => createVNode("div", {
      "tabindex": "0",
      "class": "lesscode-bk-color-picker-recommend",
      "onFocus": () => isFocused.value = true,
      "onBlur": () => isFocused.value = false,
      "onKeydown": handleKeydown
    }, [colors.value.map((color, index2) => createVNode("div", {
      "style": `background: ${color || "#fff"}`,
      "class": getColorClass(color, index2),
      "onClick": () => selectColor(index2)
    }, [selectedIndex.value === index2 ? createVNode("div", {
      "class": "lesscode-bk-color-picker-pointer"
    }, [createVNode("div", {
      "class": "lesscode-bk-color-picker-circle"
    }, null)]) : void 0]))]);
  }
});
const colorPickerProps$1 = {
  colorObj: PropTypes.object.isRequired
};
var SaturationPanel = defineComponent({
  props: colorPickerProps$1,
  emits: ["change"],
  setup(props2, {
    emit
  }) {
    const containerRef = ref(null);
    const backgroundStyle = computed(() => ({
      background: `hsl(${props2.colorObj.hsv.h}, 100%, 50%)`
    }));
    const pointerStyle = computed(() => ({
      top: `${(1 - props2.colorObj.hsv.v) * 100}%`,
      left: `${props2.colorObj.hsv.s * 100}%`
    }));
    const handleMouseDown = (e) => {
      containerRef.value.focus();
      handlePointChange(e);
      window.addEventListener("mousemove", handlePointChange, {
        passive: true
      });
      window.addEventListener("mouseup", handleMouseUp);
    };
    const handleMouseUp = () => {
      window.removeEventListener("mousemove", handlePointChange);
      window.removeEventListener("mouseup", handleMouseUp);
    };
    const handleArrowKeydown = (e) => {
      const {
        clientWidth,
        clientHeight
      } = containerRef.value;
      let left2 = props2.colorObj.hsv.s * clientWidth;
      let top2 = (1 - props2.colorObj.hsv.v) * clientHeight;
      const step = 10;
      switch (e.code) {
        case "ArrowLeft":
          e.preventDefault();
          left2 = clamp(left2 - step, 0, clientWidth);
          break;
        case "ArrowRight":
          e.preventDefault();
          left2 = clamp(left2 + step, 0, clientWidth);
          break;
        case "ArrowUp":
          e.preventDefault();
          top2 = clamp(top2 - step, 0, clientHeight);
          break;
        case "ArrowDown":
          e.preventDefault();
          top2 = clamp(top2 + step, 0, clientHeight);
          break;
        default:
          return;
      }
      handlePointChange(null, left2, top2);
    };
    const handlePointChange = (e, appointedLeft, appointedTop) => {
      const {
        clientWidth,
        clientHeight
      } = containerRef.value;
      const left2 = appointedLeft !== void 0 ? appointedLeft : getLeft(e);
      const top2 = appointedTop !== void 0 ? appointedTop : getTop(e);
      const saturation = left2 / clientWidth;
      const bright = 1 - top2 / clientHeight;
      changeColor(props2.colorObj.hsv.h, saturation, bright, props2.colorObj.hsv.a);
    };
    const getLeft = (e) => {
      const xOffset = containerRef.value.getBoundingClientRect().left + window.pageXOffset;
      const pageX = e.pageX || getTouches(e, "PageX");
      return clamp(pageX - xOffset, 0, containerRef.value.clientWidth);
    };
    const getTop = (e) => {
      const yOffset = containerRef.value.getBoundingClientRect().top + window.pageYOffset;
      const pageY = e.pageY || getTouches(e, "PageY");
      return clamp(pageY - yOffset, 0, containerRef.value.clientHeight);
    };
    const changeColor = (h2, s2, v2, a2) => {
      emit("change", {
        h: h2,
        s: s2,
        v: v2,
        a: a2
      });
    };
    return () => createVNode("div", {
      "ref": containerRef,
      "tabindex": "0",
      "class": "lesscode-bk-color-picker-saturation",
      "style": backgroundStyle.value,
      "onKeydown": handleArrowKeydown,
      "onMousedown": (e) => {
        e.stopPropagation();
        handleMouseDown(e);
      }
    }, [createVNode("div", {
      "class": "lesscode-bk-color-picker-saturation-white"
    }, null), createVNode("div", {
      "class": "lesscode-bk-color-picker-saturation-black"
    }, null), createVNode("div", {
      "class": "lesscode-bk-color-picker-pointer",
      "style": pointerStyle.value
    }, [createVNode("div", {
      "class": "lesscode-bk-color-picker-circle"
    }, null)])]);
  }
});
var ColorPickSizeEnum;
(function(ColorPickSizeEnum2) {
  ColorPickSizeEnum2["UNKNOWN"] = "";
  ColorPickSizeEnum2["SMALL"] = "small";
  ColorPickSizeEnum2["LARGE"] = "large";
})(ColorPickSizeEnum || (ColorPickSizeEnum = {}));
const colorPickerProps = {
  modelValue: PropTypes.string.def(""),
  disabled: PropTypes.bool.def(false),
  readonly: PropTypes.bool.def(false),
  transfer: PropTypes.bool.def(false),
  size: j("colorPickSize", {}).def(ColorPickSizeEnum.UNKNOWN),
  showValue: PropTypes.bool.def(true),
  recommend: PropTypes.oneOfType([PropTypes.array.def(() => []), PropTypes.bool.def(true)]).def(true),
  extCls: PropTypes.string.def(""),
  withValidate: PropTypes.bool.def(true)
};
const whiteColorObj = formatColor("#FFFFFF");
var Component$2 = defineComponent({
  name: "ColorPicker",
  directives: {
    clickoutside: ClickOutside
  },
  props: colorPickerProps,
  emits: ["update:modelValue", "change"],
  setup(props2, {
    emit
  }) {
    const formItem = useFormItem();
    const showDropdown = ref(false);
    const colorStr = ref("");
    const colorObj = reactive(JSON.parse(JSON.stringify(whiteColorObj)));
    const dropRef = ref(null);
    const saturationPanelRef = ref(null);
    const referenceRef = ref(null);
    const colorPickerCls = computed(() => classes({
      [`lesscode-bk-color-picker-${props2.size}`]: props2.size,
      "lesscode-bk-color-picker-show-dropdown": showDropdown.value,
      "lesscode-bk-color-picker-show-value": props2.showValue,
      "lesscode-bk-color-picker-disabled": props2.disabled || props2.readonly
    }, `lesscode-bk-color-picker ${props2.extCls}`));
    const isRenderRecommend = computed(() => Boolean(props2.recommend === true || Array.isArray(props2.recommend) && props2.recommend.length));
    onBeforeMount(() => {
      changeColorFromProps({
        isCreated: true
      });
    });
    watch(() => props2.modelValue, () => {
      var _a;
      changeColorFromProps();
      if (props2.withValidate) {
        (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change");
      }
    });
    const handleTriggerKeydown = (e) => {
      if (e.code === "Enter" || e.code === "NumpadEnter") {
        toggleDropdown();
      } else if (e.code === "Escape") {
        closeDropdown();
      }
    };
    const handleDropdownKeydown = (e) => {
      if (props2.transfer) {
        handleTriggerKeydown(e);
      }
    };
    const toggleDropdown = () => {
      if (props2.disabled || props2.readonly) {
        return;
      }
      showDropdown.value ? closeDropdown() : openDropdown();
    };
    const handleTabInput = (e) => {
      if (!isRenderRecommend.value) {
        e.preventDefault();
        saturationPanelRef.value.$el.focus();
      }
    };
    const handleTabRecommend = (e) => {
      e.preventDefault();
      saturationPanelRef.value.$el.focus();
    };
    const openDropdown = () => {
      var _a;
      showDropdown.value = true;
      (_a = dropRef.value) == null ? void 0 : _a.updateDropdown();
      setTimeout(() => {
        const hexInput = dropRef.value.$el.querySelector(".lesscode-bk-color-picker-input-hex .lesscode-bk-color-picker-input-value");
        hexInput.select();
      }, 100);
    };
    const closeDropdown = () => {
      var _a;
      if (showDropdown.value) {
        nextTick(() => referenceRef.value.focus());
        showDropdown.value = false;
        (_a = dropRef.value) == null ? void 0 : _a.destoryDropdown();
        changeColorFromProps();
      }
    };
    const changeColorFromProps = ({
      isCreated = false
    } = {}) => {
      if (props2.modelValue === "") {
        if (colorStr.value !== "") {
          colorStr.value = "";
          Object.assign(colorObj, whiteColorObj);
          emit("update:modelValue", colorStr.value);
        }
        return;
      }
      const propsColorObj = formatColor(props2.modelValue);
      const propsColorStr = propsColorObj.rgba.a === 1 ? propsColorObj.hex : toRGBAString(propsColorObj.rgba);
      if (propsColorStr !== colorStr.value) {
        const isValid2 = tinycolor(props2.modelValue).isValid();
        if (isCreated) {
          if (!isValid2) {
            Object.assign(colorObj, whiteColorObj);
            emit("change", "");
          } else {
            colorStr.value = propsColorStr.toLowerCase() === props2.modelValue.toLowerCase() ? props2.modelValue : propsColorStr;
            Object.assign(colorObj, propsColorObj);
          }
        } else {
          if (!isValid2) {
            colorStr.value = "";
            Object.assign(colorObj, whiteColorObj);
          } else if (propsColorStr.toLowerCase() !== colorStr.value.toLowerCase()) {
            Object.assign(colorObj, propsColorObj);
            colorStr.value = propsColorStr;
          }
        }
      }
    };
    const handleColorChange = (val) => {
      if (val === "") {
        colorStr.value = "";
        Object.assign(colorObj, whiteColorObj);
        emit("update:modelValue", "");
        emit("change", "");
        return;
      }
      const handleColorObj = formatColor(val);
      const handleColorStr = handleColorObj.rgba.a === 1 ? handleColorObj.hex : toRGBAString(handleColorObj.rgba);
      colorStr.value = handleColorStr;
      Object.assign(colorObj, handleColorObj);
      emit("update:modelValue", colorStr.value);
      emit("change", handleColorStr);
    };
    const hideDropDown = () => {
      showDropdown.value = false;
    };
    return () => withDirectives(createVNode("div", {
      "ref": referenceRef,
      "tabindex": "0",
      "class": colorPickerCls.value,
      "onKeydown": handleTriggerKeydown,
      "onClick": toggleDropdown
    }, [createVNode("div", {
      "class": "lesscode-bk-color-picker-color"
    }, [createVNode("span", {
      "class": `lesscode-bk-color-picker-color-square ${!colorStr.value && "lesscode-bk-color-picker-empty"}`,
      "style": `background: ${colorStr.value || "#FFF"}`
    }, null)]), props2.showValue ? createVNode("div", {
      "class": "lesscode-bk-color-picker-text"
    }, [createVNode("span", null, [colorStr.value])]) : void 0, createVNode("div", {
      "class": "lesscode-bk-color-picker-icon"
    }, [createVNode(angleUp, {
      "class": "icon-angle-down"
    }, null)]), createVNode(Transition, {
      "name": "lesscode-bk-fade-down-transition"
    }, {
      default: () => [withDirectives(createVNode(PickerDropdown, {
        "ref": dropRef,
        "triggerRef": referenceRef.value
      }, {
        default: () => [createVNode("div", {
          "class": "lesscode-bk-color-dropdown-container"
        }, [createVNode("div", {
          "class": "lesscode-bk-color-picker-dropdown",
          "onClick": (e) => {
            e.stopPropagation();
          },
          "onMousedown": (e) => {
            e.stopPropagation();
          },
          "onKeydown": handleDropdownKeydown
        }, [createVNode(SaturationPanel, {
          "ref": saturationPanelRef,
          "colorObj": colorObj,
          "onChange": handleColorChange
        }, null), createVNode(HueSlider, {
          "colorObj": colorObj,
          "onChange": handleColorChange
        }, null), createVNode(ColorInput, {
          "colorObj": colorObj,
          "onTab": handleTabInput,
          "onChange": handleColorChange
        }, null), isRenderRecommend.value ? createVNode("div", {
          "class": "lesscode-bk-color-picker-recommend-container"
        }, [createVNode(RecommendColors, {
          "colorObj": colorObj,
          "recommend": props2.recommend,
          "onTab": handleTabRecommend,
          "onChange": handleColorChange
        }, null)]) : void 0])])]
      }), [[vShow, showDropdown.value]])]
    })]), [[resolveDirective("clickoutside"), hideDropDown]]);
  }
});
const BkColorPicker = withInstall(Component$2);
const BkTimePicker = withInstall(TimePicker);
var raf = null;
function requestAnimationFrame$1(callback) {
  if (!raf) {
    raf = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback2) {
      return setTimeout(callback2, 16);
    }).bind(window);
  }
  return raf(callback);
}
var caf = null;
function cancelAnimationFrame$1(id) {
  if (!caf) {
    caf = (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id2) {
      clearTimeout(id2);
    }).bind(window);
  }
  caf(id);
}
function createStyles(styleText) {
  var style2 = document.createElement("style");
  if (style2.styleSheet) {
    style2.styleSheet.cssText = styleText;
  } else {
    style2.appendChild(document.createTextNode(styleText));
  }
  (document.querySelector("head") || document.body).appendChild(style2);
  return style2;
}
function createElement(tagName, props2) {
  if (props2 === void 0)
    props2 = {};
  var elem = document.createElement(tagName);
  Object.keys(props2).forEach(function(key2) {
    elem[key2] = props2[key2];
  });
  return elem;
}
function getComputedStyle$1(elem, prop, pseudo) {
  var computedStyle = window.getComputedStyle(elem, pseudo || null) || {
    display: "none"
  };
  return computedStyle[prop];
}
function getRenderInfo(elem) {
  if (!document.documentElement.contains(elem)) {
    return {
      detached: true,
      rendered: false
    };
  }
  var current = elem;
  while (current !== document) {
    if (getComputedStyle$1(current, "display") === "none") {
      return {
        detached: false,
        rendered: false
      };
    }
    current = current.parentNode;
  }
  return {
    detached: false,
    rendered: true
  };
}
var css_248z = '.resize-triggers{visibility:hidden;opacity:0;pointer-events:none}.resize-contract-trigger,.resize-contract-trigger:before,.resize-expand-trigger,.resize-triggers{content:"";position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden}.resize-contract-trigger,.resize-expand-trigger{background:#eee;overflow:auto}.resize-contract-trigger:before{width:200%;height:200%}';
var total = 0;
var style = null;
function addListener(elem, callback) {
  if (!elem.__resize_mutation_handler__) {
    elem.__resize_mutation_handler__ = handleMutation.bind(elem);
  }
  var listeners = elem.__resize_listeners__;
  if (!listeners) {
    elem.__resize_listeners__ = [];
    if (window.ResizeObserver) {
      var offsetWidth = elem.offsetWidth;
      var offsetHeight = elem.offsetHeight;
      var ro = new ResizeObserver(function() {
        if (!elem.__resize_observer_triggered__) {
          elem.__resize_observer_triggered__ = true;
          if (elem.offsetWidth === offsetWidth && elem.offsetHeight === offsetHeight) {
            return;
          }
        }
        runCallbacks(elem);
      });
      var ref2 = getRenderInfo(elem);
      var detached = ref2.detached;
      var rendered = ref2.rendered;
      elem.__resize_observer_triggered__ = detached === false && rendered === false;
      elem.__resize_observer__ = ro;
      ro.observe(elem);
    } else if (elem.attachEvent && elem.addEventListener) {
      elem.__resize_legacy_resize_handler__ = function handleLegacyResize() {
        runCallbacks(elem);
      };
      elem.attachEvent("onresize", elem.__resize_legacy_resize_handler__);
      document.addEventListener("DOMSubtreeModified", elem.__resize_mutation_handler__);
    } else {
      if (!total) {
        style = createStyles(css_248z);
      }
      initTriggers(elem);
      elem.__resize_rendered__ = getRenderInfo(elem).rendered;
      if (window.MutationObserver) {
        var mo = new MutationObserver(elem.__resize_mutation_handler__);
        mo.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
        elem.__resize_mutation_observer__ = mo;
      }
    }
  }
  elem.__resize_listeners__.push(callback);
  total++;
}
function removeListener(elem, callback) {
  var listeners = elem.__resize_listeners__;
  if (!listeners) {
    return;
  }
  if (callback) {
    listeners.splice(listeners.indexOf(callback), 1);
  }
  if (!listeners.length || !callback) {
    if (elem.detachEvent && elem.removeEventListener) {
      elem.detachEvent("onresize", elem.__resize_legacy_resize_handler__);
      document.removeEventListener("DOMSubtreeModified", elem.__resize_mutation_handler__);
      return;
    }
    if (elem.__resize_observer__) {
      elem.__resize_observer__.unobserve(elem);
      elem.__resize_observer__.disconnect();
      elem.__resize_observer__ = null;
    } else {
      if (elem.__resize_mutation_observer__) {
        elem.__resize_mutation_observer__.disconnect();
        elem.__resize_mutation_observer__ = null;
      }
      elem.removeEventListener("scroll", handleScroll);
      elem.removeChild(elem.__resize_triggers__.triggers);
      elem.__resize_triggers__ = null;
    }
    elem.__resize_listeners__ = null;
  }
  if (!--total && style) {
    style.parentNode.removeChild(style);
  }
}
function getUpdatedSize(elem) {
  var ref2 = elem.__resize_last__;
  var width = ref2.width;
  var height = ref2.height;
  var offsetWidth = elem.offsetWidth;
  var offsetHeight = elem.offsetHeight;
  if (offsetWidth !== width || offsetHeight !== height) {
    return {
      width: offsetWidth,
      height: offsetHeight
    };
  }
  return null;
}
function handleMutation() {
  var ref2 = getRenderInfo(this);
  var rendered = ref2.rendered;
  var detached = ref2.detached;
  if (rendered !== this.__resize_rendered__) {
    if (!detached && this.__resize_triggers__) {
      resetTriggers(this);
      this.addEventListener("scroll", handleScroll, true);
    }
    this.__resize_rendered__ = rendered;
    runCallbacks(this);
  }
}
function handleScroll() {
  var this$1$1 = this;
  resetTriggers(this);
  if (this.__resize_raf__) {
    cancelAnimationFrame$1(this.__resize_raf__);
  }
  this.__resize_raf__ = requestAnimationFrame$1(function() {
    var updated = getUpdatedSize(this$1$1);
    if (updated) {
      this$1$1.__resize_last__ = updated;
      runCallbacks(this$1$1);
    }
  });
}
function runCallbacks(elem) {
  if (!elem || !elem.__resize_listeners__) {
    return;
  }
  elem.__resize_listeners__.forEach(function(callback) {
    callback.call(elem, elem);
  });
}
function initTriggers(elem) {
  var position = getComputedStyle$1(elem, "position");
  if (!position || position === "static") {
    elem.style.position = "relative";
  }
  elem.__resize_old_position__ = position;
  elem.__resize_last__ = {};
  var triggers = createElement("div", {
    className: "resize-triggers"
  });
  var expand = createElement("div", {
    className: "resize-expand-trigger"
  });
  var expandChild = createElement("div");
  var contract = createElement("div", {
    className: "resize-contract-trigger"
  });
  expand.appendChild(expandChild);
  triggers.appendChild(expand);
  triggers.appendChild(contract);
  elem.appendChild(triggers);
  elem.__resize_triggers__ = {
    triggers,
    expand,
    expandChild,
    contract
  };
  resetTriggers(elem);
  elem.addEventListener("scroll", handleScroll, true);
  elem.__resize_last__ = {
    width: elem.offsetWidth,
    height: elem.offsetHeight
  };
}
function resetTriggers(elem) {
  var ref2 = elem.__resize_triggers__;
  var expand = ref2.expand;
  var expandChild = ref2.expandChild;
  var contract = ref2.contract;
  var csw = contract.scrollWidth;
  var csh = contract.scrollHeight;
  var eow = expand.offsetWidth;
  var eoh = expand.offsetHeight;
  var esw = expand.scrollWidth;
  var esh = expand.scrollHeight;
  contract.scrollLeft = csw;
  contract.scrollTop = csh;
  expandChild.style.width = eow + 1 + "px";
  expandChild.style.height = eoh + 1 + "px";
  expand.scrollLeft = esw;
  expand.scrollTop = esh;
}
var SearchSelectMenu = defineComponent({
  name: "SearchSelectMenu",
  props: {
    list: {
      type: Array
    },
    hoverId: String,
    keyword: {
      type: String,
      default: ""
    },
    multiple: {
      type: Boolean,
      default: false
    },
    selected: {
      type: Array,
      default: () => []
    },
    conditions: {
      type: Array
    },
    footerBtns: {
      type: Array,
      default: () => []
    }
  },
  emits: ["selectItem", "selectCondition", "footerClick"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("searchSelect");
    const {
      resolveClassName: resolveClassName2
    } = usePrefix();
    const localFooterBtns = computed(() => {
      if (props2.footerBtns === void 0 || props2.footerBtns.length === 0) {
        return [{
          id: "confirm",
          name: t2.value.ok
        }, {
          id: "cancel",
          name: t2.value.cancel,
          disabled: false
        }];
      }
      return props2.footerBtns;
    });
    function handleClick(item) {
      emit("selectItem", item);
    }
    function handleClickCondition(item) {
      emit("selectCondition", item);
    }
    function handleClickFooterBtn(item) {
      emit("footerClick", item);
    }
    const filterList = computed(() => {
      var _a, _b;
      if (!((_a = props2.list) == null ? void 0 : _a.length))
        return [];
      if (!((_b = props2.keyword) == null ? void 0 : _b.length))
        return props2.list;
      return props2.list.filter((item) => item.name.toLocaleLowerCase().includes(props2.keyword.toLocaleLowerCase()));
    });
    function transformNode(str) {
      if (!str)
        return str;
      let {
        keyword
      } = props2;
      const len = keyword.length;
      if (!(keyword == null ? void 0 : keyword.trim().length) || !str.toLocaleLowerCase().includes(keyword.toLocaleLowerCase()))
        return str;
      const list = [];
      let lastIndex = -1;
      keyword = keyword.replace(/([.*/]{1})/gmi, "\\$1");
      str.replace(new RegExp(`${keyword}`, "igm"), (key2, index2) => {
        if (list.length === 0 && index2 !== 0) {
          list.push(str.slice(0, index2));
        } else if (lastIndex >= 0) {
          list.push(str.slice(lastIndex + key2.length, index2));
        }
        list.push(createVNode("span", {
          "class": "is-keyword"
        }, [key2]));
        lastIndex = index2;
        return key2;
      });
      if (lastIndex >= 0) {
        list.push(str.slice(lastIndex + len));
      }
      return list.length ? list : str;
    }
    function getSearchNode(item) {
      var _a;
      if (!((_a = item.value) == null ? void 0 : _a.name))
        return transformNode(item.name);
      return [createVNode("span", {
        "class": "menu-name"
      }, [item.name, createTextVNode(":")]), item.value.name];
    }
    return {
      handleClick,
      handleClickCondition,
      handleClickFooterBtn,
      filterList,
      getSearchNode,
      localFooterBtns,
      resolveClassName: resolveClassName2
    };
  },
  render() {
    var _a, _b, _c;
    return createVNode("div", {
      "class": this.resolveClassName("search-select-menu")
    }, [!!((_a = this.conditions) == null ? void 0 : _a.length) && createVNode("ul", {
      "class": "menu-header"
    }, [this.conditions.map((item) => createVNode("li", {
      "key": item.id,
      "class": `menu-header-item  ${item.disabled ? "is-disabled" : ""}`,
      "onClick": () => !item.disabled && this.handleClickCondition(item)
    }, [item.name]))]), createVNode("ul", {
      "class": "menu-content"
    }, [(_b = this.list) == null ? void 0 : _b.map((item) => createVNode("li", {
      "class": `menu-item ${item.disabled ? "is-disabled" : ""} ${this.hoverId === item.id && !item.disabled ? "is-hover" : ""}`,
      "key": item.id,
      "id": item.id,
      "tabindex": "-1",
      "onClick": () => !item.disabled && this.handleClick(item)
    }, [this.$slots.default ? this.$slots.default({
      item,
      list: this.list,
      multiple: !!this.multiple,
      hoverId: this.hoverId,
      getSearchNode: this.getSearchNode
    }) : createVNode(Fragment, null, [this.getSearchNode(item), this.multiple && this.selected.includes(item.id) && createVNode(done, {
      "class": "is-selected"
    }, null)])]))]), this.multiple && ((_c = this.localFooterBtns) == null ? void 0 : _c.length) && createVNode("div", {
      "class": "menu-footer"
    }, [this.localFooterBtns.map((item) => createVNode("span", {
      "class": `menu-footer-btn ${item.disabled ? "is-disabled" : ""}`,
      "key": item.id,
      "onClick": () => !item.disabled && this.handleClickFooterBtn(item)
    }, [item.name]))])]);
  }
});
var ValueBehavior = /* @__PURE__ */ ((ValueBehavior2) => {
  ValueBehavior2["ALL"] = "all";
  ValueBehavior2["NEEDKEY"] = "need-key";
  return ValueBehavior2;
})(ValueBehavior || {});
const SEARCH_SLECT_PROVIDER_KEY = Symbol("SEARCH_SLECT_PROVIDER_KEY");
const useSearchSelectProvider = (data2) => {
  provide(SEARCH_SLECT_PROVIDER_KEY, data2);
};
const useSearchSelectInject = () => inject(SEARCH_SLECT_PROVIDER_KEY);
var SearchInputMode = /* @__PURE__ */ ((SearchInputMode2) => {
  SearchInputMode2["DEFAULT"] = "default";
  SearchInputMode2["EDIT"] = "edit";
  return SearchInputMode2;
})(SearchInputMode || {});
class SelectedItem {
  constructor(searchItem, type = "default", splitCode = "|") {
    this.searchItem = searchItem;
    this.type = type;
    this.splitCode = splitCode;
    this.values = [];
    this.id = searchItem.id;
    this.name = searchItem.name;
  }
  get multiple() {
    return !!this.searchItem.multiple;
  }
  get placeholder() {
    return this.searchItem.placeholder || "";
  }
  get children() {
    return this.searchItem.children || [];
  }
  get validate() {
    return !this.searchItem.noValidate;
  }
  get inputInnerHtml() {
    var _a;
    if (this.isSpecialType())
      return this.name;
    return `${this.keyInnerHtml}${((_a = this.values) == null ? void 0 : _a.map((item) => item.name).join(this.splitCode)) || ""}`;
  }
  get inputInnerText() {
    var _a;
    if (this.isSpecialType())
      return this.name;
    return `${this.keyInnerText}${((_a = this.values) == null ? void 0 : _a.map((item) => item.name).join(this.splitCode)) || ""}`;
  }
  get keyInnerHtml() {
    if (this.isSpecialType())
      return this.name;
    return this.name ? `${this.name}:\xA0` : "";
  }
  get keyInnerText() {
    if (this.isSpecialType())
      return this.name;
    return this.name ? `${this.name}: ` : "";
  }
  isSpecialType() {
    return ["text", "condition"].includes(this.type);
  }
  addValue(item) {
    if (this.multiple) {
      const index2 = this.values.findIndex((val) => val.id === item.id);
      if (index2 > -1) {
        this.values.splice(index2, 1);
        return;
      }
      this.values.push(item);
      return;
    }
    this.values = [item];
  }
  toValue() {
    var _a;
    const value = {
      id: this.id,
      name: this.name
    };
    if ((_a = this.values) == null ? void 0 : _a.length) {
      value.values = this.values.map((item) => ({ id: item.id, name: item.name }));
    }
    if (this.type && this.type !== "default") {
      value.type = this.type;
    }
    return value;
  }
  toValueKey() {
    return JSON.stringify(this.toValue());
  }
  isInValueList(item) {
    return this.children.some((v2) => v2.id === (item == null ? void 0 : item.id));
  }
}
var SearchSelectInput = defineComponent({
  name: "SearchSelectInput",
  directives: {
    clickoutside: ClickOutside
  },
  props: {
    data: {
      type: Array,
      required: true
    },
    showInputBefore: Boolean,
    showCondition: Boolean,
    clickOutside: Function,
    placeholder: String,
    conditions: {
      type: Array,
      default: () => []
    },
    defautUsingItem: Object,
    mode: {
      type: String,
      default: SearchInputMode.DEFAULT
    },
    getMenuList: Function,
    validateValues: Function,
    valueBehavior: String
  },
  emits: ["focus", "add", "delete"],
  setup(props2, {
    emit,
    expose
  }) {
    const t2 = useLocale("searchSelect");
    const {
      resolveClassName: resolveClassName2
    } = usePrefix();
    const inputRef = ref(null);
    const popoverRef = ref(null);
    const keyword = ref("");
    const showNoSelectValueError = ref(false);
    const isFocus = ref(false);
    const showPopover = ref(false);
    const usingItem = ref(props2.defautUsingItem);
    const menuHoverId = ref("");
    const loading2 = ref(false);
    const debounceSetMenuList = debounce(300, setMenuList);
    let isBindEvent = false;
    const remoteMenuList = ref([]);
    const menuList = ref([]);
    const {
      editKey,
      onValidate,
      valueSplitCode
    } = useSearchSelectInject();
    watch(editKey, () => {
      if (props2.mode === SearchInputMode.DEFAULT && editKey.value) {
        showPopover.value = false;
      }
    });
    watchEffect(() => {
      if (!keyword.value) {
        setInputText();
      }
    }, {
      flush: "pre"
    });
    watch([menuList, showPopover], () => {
      var _a;
      if (((_a = menuList.value) == null ? void 0 : _a.some((item) => !item.disabled)) && showPopover.value) {
        if (!isBindEvent) {
          if (props2.valueBehavior === ValueBehavior.NEEDKEY) {
            menuHoverId.value = menuList.value.find((item) => !item.disabled).id;
          } else {
            menuHoverId.value = "";
          }
          isBindEvent = true;
          document.addEventListener("keydown", handleDocumentKeydown);
        }
      } else {
        document.removeEventListener("keydown", handleDocumentKeydown);
        isBindEvent = false;
        if (props2.valueBehavior !== ValueBehavior.NEEDKEY) {
          menuHoverId.value = "";
        }
      }
    });
    function handleDocumentKeydown(e) {
      switch (e.code) {
        case "ArrowDown":
        case "ArrowUp":
          documentArrowEvent(e);
          break;
        case "Enter":
        case "NumpadEnter":
          documentEnterEvent(e);
          break;
      }
    }
    function documentArrowEvent(e) {
      var _a;
      e.preventDefault();
      (_a = inputRef.value) == null ? void 0 : _a.blur();
      const len = menuList.value.length;
      let i2 = len;
      let index2 = menuList.value.findIndex((set) => set.id === menuHoverId.value);
      while (i2 >= 0) {
        index2 = e.code === "ArrowDown" ? index2 + 1 : index2 - 1;
        index2 = index2 > len - 1 ? 0 : index2 < 0 ? len - 1 : index2;
        const item = menuList.value[index2];
        if (item && !item.disabled) {
          i2 = -1;
          const dom = document.getElementById(item.id);
          dom == null ? void 0 : dom.focus();
          menuHoverId.value = item.id;
          return;
        }
        i2 -= 1;
      }
    }
    function documentEnterEvent(e) {
      if (isBindEvent) {
        e.preventDefault();
        const item = menuList.value.find((item2) => item2.id === menuHoverId.value);
        item && handleSelectItem(item);
      }
    }
    function handleClickOutside(e) {
      var _a, _b;
      if (!((_a = popoverRef.value) == null ? void 0 : _a.contains(e.target)) && ((_b = props2.clickOutside) == null ? void 0 : _b.call(props2, e.target, popoverRef.value))) {
        showPopover.value = false;
        isFocus.value = false;
        emit("focus", isFocus.value);
      }
    }
    function handleInputFocus(e) {
      setInputFocus();
      e && setMenuList();
    }
    function handleInputChange(event) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      clearInput();
      let text = event.target.innerText;
      if (/(\r|\n)/gm.test(text) || /\s{2}/gm.test(text)) {
        event.preventDefault();
        text = text.replace(/(\r|\n)/gm, valueSplitCode.value).replace(/\s{2}/gm, "");
        inputRef.value.innerText = text;
        setInputFocus();
        keyword.value = text.replace(((_a = usingItem.value) == null ? void 0 : _a.keyInnerText) || "", "").trim();
        debounceSetMenuList();
      } else if (!keyword.value && text.length < (((_c = (_b = usingItem.value) == null ? void 0 : _b.inputInnerText) == null ? void 0 : _c.length) || 1)) {
        const outerText = text.replace("\xA0", " ").replace(((_d = usingItem.value) == null ? void 0 : _d.keyInnerText.replace("\xA0", " ").trim()) || "", "").trim();
        const hasKeyword = text && ((_e = usingItem.value) == null ? void 0 : _e.keyInnerText) && text.replace("\xA0", " ").includes(usingItem.value.keyInnerText.replace("\xA0", " ").trim());
        if (hasKeyword && outerText && ((_f = usingItem.value.values) == null ? void 0 : _f.length)) {
          keyword.value = outerText;
          console.info("outerText", outerText);
          debounceSetMenuList();
          return;
        }
        if (outerText || !(text == null ? void 0 : text.length)) {
          usingItem.value = null;
        }
        keyword.value = outerText ? text : "";
        debounceSetMenuList();
      } else if (!((_h = (_g = usingItem.value) == null ? void 0 : _g.values) == null ? void 0 : _h.length)) {
        keyword.value = text.replace("\xA0", " ").replace(((_i = usingItem.value) == null ? void 0 : _i.keyInnerText.replace("\xA0", " ")) || "", "").trim();
        setInputFocus();
        debounceSetMenuList();
      }
    }
    function handleInputKeyup(event) {
      switch (event.code) {
        case "Enter":
        case "NumpadEnter":
          if (props2.valueBehavior === ValueBehavior.NEEDKEY && menuList.value.some((item) => item.id === menuHoverId.value))
            return;
          handleKeyEnter(event);
          break;
        case "Backspace":
          handleKeyBackspace();
        default:
          showNoSelectValueError.value = false;
          break;
      }
    }
    async function handleKeyEnter(event) {
      var _a;
      event == null ? void 0 : event.preventDefault();
      await new Promise((r2) => setTimeout(r2, 0));
      if (!usingItem.value) {
        if (!keyword.value || props2.valueBehavior === ValueBehavior.NEEDKEY)
          return;
        const value = {
          id: keyword.value,
          name: keyword.value
        };
        const res2 = await validateUsingItemValues(value);
        if (!res2)
          return;
        emit("add", new SelectedItem(value, "text", valueSplitCode.value));
        keyword.value = "";
        setMenuList();
        return;
      }
      const {
        values
      } = usingItem.value;
      if (!(values == null ? void 0 : values.length)) {
        if ((_a = keyword.value) == null ? void 0 : _a.length) {
          if (keyword.value.includes(valueSplitCode.value)) {
            const valueList = keyword.value.split(valueSplitCode.value);
            const res2 = await validateUsingItemValues({
              id: keyword.value,
              name: keyword.value
            });
            if (!res2)
              return;
            valueList.forEach((v2) => usingItem.value.addValue({
              id: v2,
              name: v2
            }));
          } else {
            const value = {
              id: keyword.value,
              name: keyword.value
            };
            const res2 = await validateUsingItemValues(value);
            if (!res2)
              return;
            usingItem.value.addValue(value);
          }
          emit("add", usingItem.value);
          keyword.value = "";
          usingItem.value = null;
          setInputFocus(true);
          return;
        }
        showNoSelectValueError.value = true;
        return;
      }
      if (keyword.value) {
        const value = {
          id: keyword.value,
          name: keyword.value
        };
        const res2 = await validateUsingItemValues(value);
        if (!res2)
          return;
        usingItem.value.addValue(value);
        emit("add", usingItem.value);
        keyword.value = "";
        usingItem.value = null;
        setInputFocus(true);
        return;
      }
      const res = await validateUsingItemValues();
      if (!res)
        return;
      setSelectedItem();
    }
    function handleKeyBackspace() {
      var _a, _b;
      if (!usingItem.value && !keyword.value) {
        emit("delete");
        nextTick(setMenuList);
        return;
      }
      if ((_a = usingItem.value) == null ? void 0 : _a.values.length) {
        if (((_b = usingItem.value) == null ? void 0 : _b.multiple) || usingItem.value.isInValueList(usingItem.value.values[0]) || props2.mode === SearchInputMode.EDIT && !keyword.value) {
          usingItem.value.values.splice(-1, 1);
          keyword.value = "";
          setInputFocus();
          return;
        }
      } else if (!keyword.value) {
        usingItem.value = null;
        keyword.value = "";
        setMenuList();
      }
      onValidate("");
    }
    async function handleSelectItem(item, type) {
      var _a, _b, _c, _d, _e;
      if ((_a = item.value) == null ? void 0 : _a.id) {
        if (props2.valueBehavior === ValueBehavior.NEEDKEY && item.value || !props2.validateValues) {
          const seleted = new SelectedItem(__spreadProps(__spreadValues({}, item), {
            id: (_b = item.realId) != null ? _b : item.id
          }), type, valueSplitCode.value);
          seleted.addValue(item.value);
          setSelectedItem(seleted);
          if (props2.valueBehavior === ValueBehavior.NEEDKEY && menuHoverId.value) {
            setInputFocus(true);
          }
          menuHoverId.value = "";
          return;
        }
      }
      if (!usingItem.value || !((_c = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _c.innerText)) {
        usingItem.value = new SelectedItem(item, type, valueSplitCode.value);
        keyword.value = "";
        const isCondition = type === "condition";
        isCondition && setSelectedItem();
        showPopover.value = isCondition || !!usingItem.value.children.length;
        setInputFocus(props2.valueBehavior === ValueBehavior.NEEDKEY && !!menuHoverId.value);
        return;
      }
      if (((_d = usingItem.value) == null ? void 0 : _d.type) === "condition") {
        usingItem.value = new SelectedItem(item, type, valueSplitCode.value);
        setSelectedItem();
        return;
      }
      usingItem.value.addValue(item);
      const res = await validateUsingItemValues(item);
      if (!res)
        return;
      if (!usingItem.value.multiple)
        setSelectedItem();
      if (props2.valueBehavior === ValueBehavior.NEEDKEY && ((_e = usingItem.value) == null ? void 0 : _e.multiple)) {
        setInputFocus();
      }
    }
    function handleSelectCondtionItem(item) {
      handleSelectItem(item, "condition");
    }
    function handleMenuFooterClick(item) {
      switch (item.id) {
        case "confirm":
          handleKeyEnter();
          break;
        case "cancel":
          usingItem.value.values = [];
          showPopover.value = false;
          break;
      }
    }
    async function validateUsingItemValues(value) {
      if (!usingItem.value) {
        return await validateValues(null, [value]);
      }
      const {
        searchItem,
        validate,
        values
      } = usingItem.value;
      if (validate && typeof props2.validateValues === "function") {
        return await validateValues(searchItem, value ? [value] : values);
      }
      onValidate("");
      return true;
    }
    async function validateValues(searchItem, value) {
      var _a;
      const validateStr = await ((_a = props2.validateValues) == null ? void 0 : _a.call(props2, searchItem != null ? searchItem : null, value).catch(() => false));
      if (typeof validateStr === "string" || validateStr === false) {
        onValidate(validateStr || "\u6821\u9A8C\u9519\u8BEF");
        return false;
      }
      onValidate("");
      return true;
    }
    function setInputFocus(refleshMenuList = false) {
      if (refleshMenuList) {
        nextTick().then(() => {
          setMenuList();
        });
      }
      isFocus.value = true;
      showPopover.value = true;
      showNoSelectValueError.value = false;
      const timer = setTimeout(() => {
        if (inputRef.value) {
          inputRef.value.focus();
          const selection = window.getSelection();
          if (selection.focusOffset === 0) {
            selection.selectAllChildren(inputRef.value);
            selection.collapseToEnd();
          }
        }
        window.clearTimeout(timer);
      }, 0);
      emit("focus", isFocus.value);
    }
    async function setMenuList() {
      var _a, _b, _c, _d, _e;
      let list = [];
      if (typeof props2.getMenuList === "function" && (typeof ((_b = (_a = usingItem.value) == null ? void 0 : _a.searchItem) == null ? void 0 : _b.async) === "undefined" || usingItem.value.searchItem.async === true)) {
        loading2.value = true;
        list = await props2.getMenuList((_c = usingItem.value) == null ? void 0 : _c.searchItem, keyword.value).catch(() => []);
        loading2.value = false;
      } else if (!(usingItem == null ? void 0 : usingItem.value)) {
        if (!((_d = keyword.value) == null ? void 0 : _d.length)) {
          list = props2.data.filter((item) => !item.isSelected).slice();
        } else
          props2.data.filter((item) => !item.isSelected).forEach((item) => {
            var _a2, _b2;
            const isMatched = item.name.toLocaleLowerCase().includes(keyword.value.toLocaleLowerCase());
            if (isMatched) {
              list.push(item);
              (_a2 = item.children) == null ? void 0 : _a2.forEach((child) => {
                list.push(__spreadProps(__spreadValues({}, item), {
                  realId: item.id,
                  id: random(10),
                  value: child
                }));
              });
              list.push(__spreadProps(__spreadValues({}, item), {
                realId: item.id,
                id: random(10),
                value: {
                  id: keyword.value,
                  name: keyword.value
                }
              }));
            } else {
              (_b2 = item.children) == null ? void 0 : _b2.forEach((child) => {
                if (child.name.toLocaleLowerCase().includes(keyword.value.toLocaleLowerCase())) {
                  list.push(__spreadProps(__spreadValues({}, item), {
                    realId: item.id,
                    id: random(10),
                    value: child
                  }));
                }
              });
              list.push(__spreadProps(__spreadValues({}, item), {
                value: {
                  id: keyword.value,
                  name: keyword.value
                }
              }));
            }
          });
      } else if (usingItem.value.type === "condition") {
        list = props2.conditions;
      } else if (!((_e = usingItem.value.values) == null ? void 0 : _e.length) || usingItem.value.multiple || props2.mode === SearchInputMode.EDIT) {
        list = usingItem.value.children.filter((item) => item.name.toLocaleLowerCase().includes(keyword.value.toLocaleLowerCase()));
      }
      menuList.value = list;
      if (props2.valueBehavior === ValueBehavior.NEEDKEY) {
        const hoverItem = list.find((item) => !item.disabled);
        if (hoverItem && (!menuHoverId.value || menuHoverId.value && !list.some((item) => item.id === menuHoverId.value))) {
          menuHoverId.value = hoverItem.id;
        }
      }
    }
    function setSelectedItem(item) {
      emit("add", item != null ? item : usingItem.value);
      usingItem.value = null;
      keyword.value = "";
      setInputFocus(props2.valueBehavior === ValueBehavior.NEEDKEY);
    }
    function clearInput() {
      const text = inputRef.value.innerText;
      if (text[text.length - 1] === "\n" || text[0] === "\r") {
        setInputText(text.slice(0, -1));
        clearInput();
      } else if (text[0] === "\n" || text[0] === "\r") {
        setInputText(text.slice(1));
        clearInput();
      }
    }
    function setInputText(text = "") {
      var _a;
      if (inputRef.value) {
        inputRef.value.innerHTML = text || ((_a = usingItem.value) == null ? void 0 : _a.inputInnerHtml) || "";
      }
    }
    expose({
      handleInputFocus,
      isFocus
    });
    return {
      popoverRef,
      inputRef,
      keyword,
      loading: loading2,
      remoteMenuList,
      menuList,
      menuHoverId,
      isFocus,
      usingItem,
      showPopover,
      showNoSelectValueError,
      debounceSetMenuList,
      documentArrowEvent,
      handleClickOutside,
      handleInputFocus,
      handleInputChange,
      handleInputKeyup,
      handleSelectItem,
      handleSelectCondtionItem,
      handleMenuFooterClick,
      resolveClassName: resolveClassName2,
      t: t2
    };
  },
  render() {
    var _a, _b;
    const {
      multiple,
      values,
      placeholder,
      inputInnerHtml
    } = this.usingItem || {};
    const showInputAfter = !((_a = this.keyword) == null ? void 0 : _a.length) && !(values == null ? void 0 : values.length) && placeholder;
    const showPopover = this.loading || this.showNoSelectValueError || this.showPopover && !!((_b = this.menuList) == null ? void 0 : _b.length);
    const showCondition = !this.usingItem && this.showCondition;
    const menuSlots = Object.assign({}, this.$slots.menu ? {
      default: (data2) => {
        var _a2, _b2;
        return (_b2 = (_a2 = this.$slots).menu) == null ? void 0 : _b2.call(_a2, data2);
      }
    } : {});
    const inputContent = () => {
      var _a2;
      return withDirectives(createVNode("div", {
        "ref": "inputRef",
        "class": {
          "div-input": true,
          "input-before": this.showInputBefore && !((_a2 = this.keyword) == null ? void 0 : _a2.length),
          "input-after": showInputAfter
        },
        "contenteditable": true,
        "data-placeholder": !inputInnerHtml && !this.keyword ? this.placeholder : "",
        "data-tips": placeholder || "",
        "spellcheck": "false",
        "onFocus": this.handleInputFocus,
        "onInput": this.handleInputChange,
        "onKeydown": this.handleInputKeyup
      }, null), [[resolveDirective("clickoutside"), this.handleClickOutside]]);
    };
    const popoverContent = () => {
      var _a2;
      if (this.loading) {
        return createVNode("div", null, [this.t.loading]);
      }
      if (this.showNoSelectValueError) {
        return createVNode("div", null, [this.t.filterQueryMustHasValue]);
      }
      return ((_a2 = this.menuList) == null ? void 0 : _a2.length) ? createVNode("div", {
        "ref": "popoverRef",
        "class": this.resolveClassName("search-select-popover")
      }, [createVNode(SearchSelectMenu, {
        "list": this.menuList,
        "keyword": this.keyword,
        "multiple": !!multiple,
        "hoverId": this.menuHoverId,
        "selected": (values == null ? void 0 : values.map((item) => item.id)) || [],
        "conditions": showCondition ? this.conditions : [],
        "onSelectItem": this.handleSelectItem,
        "onSelectCondition": this.handleSelectCondtionItem,
        "onFooterClick": this.handleMenuFooterClick
      }, __spreadValues({}, menuSlots))]) : void 0;
    };
    return createVNode(BkPopover, {
      "trigger": "manual",
      "theme": "light",
      "placement": "bottom-start",
      "arrow": false,
      "disableOutsideClick": true,
      "isShow": showPopover
    }, {
      default: inputContent,
      content: popoverContent
    });
  }
});
var SearchSelected = defineComponent({
  name: "SearchSelected",
  props: {
    data: {
      type: Array,
      required: true
    },
    selectedList: {
      type: Array,
      required: true
    },
    overflowIndex: {
      type: Number,
      default: -1
    },
    conditions: {
      type: Array,
      default: () => []
    },
    getMenuList: Function,
    validateValues: Function,
    valueBehavior: String
  },
  emits: ["delete"],
  setup(_props, {
    emit
  }) {
    const inputRef = ref(null);
    const {
      onEditClick,
      onEditEnter,
      onEditBlur,
      editKey,
      valueSplitCode
    } = useSearchSelectInject();
    function handleDeleteSelected(index2) {
      emit("delete", index2);
    }
    function handleEditSeleted(e, item, index2) {
      e.preventDefault();
      e.stopPropagation();
      onEditClick(item, index2);
      setTimeout(() => inputRef.value.handleInputFocus(), 200);
    }
    function handleAddSelected(item, index2) {
      onEditEnter(item, index2);
    }
    function handleInputFocus(isFocus) {
      if (isFocus)
        return;
      onEditBlur();
    }
    function handleInputOutside() {
      return true;
    }
    function copySeletedItem(item) {
      const newItem = new SelectedItem(item.searchItem, item.type, valueSplitCode.value);
      newItem.values = item.values.slice();
      return newItem;
    }
    return {
      inputRef,
      editKey,
      copySeletedItem,
      handleDeleteSelected,
      handleEditSeleted,
      handleInputOutside,
      handleAddSelected,
      handleInputFocus
    };
  },
  render() {
    const contentComponent = (item, index2) => this.editKey === `${item.id}_${index2}` ? createVNode("div", {
      "class": "selected-input",
      "key": this.editKey.toString()
    }, [createVNode(SearchSelectInput, {
      "ref": "inputRef",
      "key": this.editKey.toString(),
      "mode": SearchInputMode.EDIT,
      "data": this.data,
      "showCondition": false,
      "conditions": this.conditions,
      "defautUsingItem": this.copySeletedItem(item),
      "clickOutside": this.handleInputOutside,
      "getMenuList": this.getMenuList,
      "validateValues": this.validateValues,
      "valueBehavior": this.valueBehavior,
      "onAdd": (v2) => this.handleAddSelected(v2, index2),
      "onFocus": this.handleInputFocus
    }, null)]) : createVNode("li", {
      "class": `search-container-selected ${!(this.overflowIndex >= 0 ? index2 < this.overflowIndex : index2 >= 0) ? "hidden-selected" : ""}`,
      "key": `${item.id}_${index2}`
    }, [createVNode("span", {
      "class": "selected-name",
      "onClick": (e) => this.handleEditSeleted(e, item, index2)
    }, [item.inputInnerText]), createVNode(error, {
      "class": "selected-clear",
      "onClick": () => this.handleDeleteSelected(index2)
    }, null)]);
    return createVNode(Fragment, null, [this.selectedList.map((item, index2) => [this.overflowIndex >= 0 && index2 === this.overflowIndex && createVNode("div", {
      "class": "search-container-selected overflow-selected"
    }, [createTextVNode("+"), this.selectedList.length - this.overflowIndex]), contentComponent(item, index2)])]);
  }
});
const INPUT_PADDING_WIDTH = 40;
const SELETED_MARGING_RIGHT = 6;
const SearchSelectProps = {
  data: {
    type: Array,
    default: () => []
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  shrink: {
    type: Boolean,
    default: true
  },
  maxHeight: {
    type: Number,
    default: 120
  },
  minHeight: {
    type: Number,
    default: 26
  },
  conditions: {
    type: Array,
    default: () => []
  },
  clearable: {
    type: Boolean,
    default: true
  },
  placeholder: String,
  getMenuList: Function,
  validateValues: Function,
  valueSplitCode: {
    type: String,
    default: "|"
  },
  uniqueSelect: {
    type: Boolean,
    default: false
  },
  valueBehavior: {
    type: String,
    default: ValueBehavior.ALL,
    validator(v2) {
      return [ValueBehavior.ALL, ValueBehavior.NEEDKEY].includes(v2);
    }
  }
};
var Component$1 = defineComponent({
  name: "SearchSelect",
  directives: {
    clickoutside: ClickOutside
  },
  props: SearchSelectProps,
  emits: ["update:modelValue", "search"],
  setup(props2, {
    emit
  }) {
    const t2 = useLocale("searchSelect");
    const {
      resolveClassName: resolveClassName2
    } = usePrefix();
    const localConditions = computed(() => {
      if (props2.conditions === void 0) {
        return [{
          id: "or",
          name: t2.value.or
        }, {
          id: "and",
          name: t2.value.and
        }];
      }
      return props2.conditions;
    });
    const inputRef = ref(null);
    const wrapRef = ref(null);
    const isFocus = ref(false);
    const selectedList = ref([]);
    const overflowIndex = ref(-1);
    const debounceResize = debounce(32, handleResize);
    const editKey = ref("");
    const validateStr = ref("");
    const splitCode = computed(() => props2.valueSplitCode);
    const copyData = shallowRef([]);
    watch(() => props2.data, () => {
      var _a;
      copyData.value = JSON.parse(JSON.stringify(props2.data));
      (_a = copyData.value) == null ? void 0 : _a.forEach((item) => {
        item.isSelected = props2.uniqueSelect && !!props2.modelValue.some((set) => set.id === item.id);
      });
    }, {
      immediate: true
    });
    watch(() => props2.modelValue, (v2) => {
      var _a, _b;
      if (!(v2 == null ? void 0 : v2.length)) {
        selectedList.value = [];
        (_a = copyData.value) == null ? void 0 : _a.forEach((item) => {
          item.isSelected = false;
        });
        return;
      }
      const list = [];
      v2.forEach((item) => {
        var _a2;
        const seleted = selectedList.value.find((set) => set.id === item.id && set.name === item.name);
        if ((seleted == null ? void 0 : seleted.toValueKey()) === JSON.stringify(item)) {
          seleted.values = item.values || [];
          list.push(seleted);
        } else {
          let searchItem = props2.data.find((set) => set.id === item.id);
          let searchType = "default";
          if (!searchItem) {
            searchItem = props2.conditions.find((set) => set.id === item.id);
            searchItem && (searchType = "condition");
          }
          if (!searchItem && !((_a2 = item.values) == null ? void 0 : _a2.length)) {
            searchType = "text";
          }
          const newSelected = new SelectedItem(searchItem || item, searchType, splitCode.value);
          newSelected.values = item.values || [];
          list.push(newSelected);
        }
      });
      selectedList.value = list;
      (_b = copyData.value) == null ? void 0 : _b.forEach((item) => {
        item.isSelected = props2.uniqueSelect && !!list.some((set) => set.id === item.id);
      });
    }, {
      immediate: true,
      deep: true
    });
    onMounted(() => {
      addListener(wrapRef.value.querySelector(`.${resolveClassName2("search-select-container")}`), debounceResize);
    });
    onBeforeUnmount(() => {
      removeListener(wrapRef.value.querySelector(`.${resolveClassName2("search-select-container")}`), debounceResize);
    });
    useSearchSelectProvider({
      onEditClick,
      onEditEnter,
      onEditBlur,
      onValidate,
      editKey,
      valueSplitCode: splitCode
    });
    function onEditClick(item, index2) {
      editKey.value = `${item.id}_${index2}`;
    }
    function onEditEnter(item, index2) {
      const list = selectedList.value.slice();
      list.splice(index2, 1, item);
      emit("update:modelValue", list.map((item2) => item2.toValue()));
      editKey.value = "";
    }
    function onEditBlur() {
      editKey.value = "";
      onValidate("");
    }
    function onValidate(str) {
      validateStr.value = str || "";
    }
    function handleResize() {
      if (isFocus.value || selectedList.value.length < 1) {
        overflowIndex.value = -1;
        return;
      }
      const inputEl = wrapRef.value.querySelector(`.${resolveClassName2("search-select-container")}`);
      const maxWidth = wrapRef.value.querySelector(".search-container").clientWidth - SELETED_MARGING_RIGHT - 2;
      const tagList = inputEl.querySelectorAll(".search-container-selected:not(.overflow-selected)");
      let width = 0;
      let index2 = 0;
      let i2 = 0;
      while (index2 === 0 && width <= maxWidth - INPUT_PADDING_WIDTH && i2 <= tagList.length - 1) {
        const el = tagList[i2];
        if (el.clientHeight > props2.minHeight) {
          overflowIndex.value = i2;
          return;
        }
        width += el ? el.clientWidth + SELETED_MARGING_RIGHT : 0;
        if (width >= maxWidth - INPUT_PADDING_WIDTH) {
          index2 = i2;
        }
        i2 += 1;
      }
      if (index2 === tagList.length - 1 && width <= maxWidth) {
        overflowIndex.value = -1;
        return;
      }
      overflowIndex.value = width >= maxWidth - INPUT_PADDING_WIDTH ? index2 : index2 - 1;
    }
    function handleWrapClick() {
      if (!editKey.value) {
        inputRef.value.handleInputFocus();
      }
    }
    function handleClearAll() {
      selectedList.value = [];
      overflowIndex.value = -1;
      emit("update:modelValue", []);
    }
    function handleInputOutside(target) {
      var _a;
      return !((_a = wrapRef.value) == null ? void 0 : _a.contains(target));
    }
    function handleAddSelected(item) {
      const list = selectedList.value.slice();
      list.push(item);
      onValidate("");
      emit("update:modelValue", list.map((item2) => item2.toValue()));
    }
    function handleDeleteSelected(index2) {
      const list = selectedList.value.slice();
      list.splice(typeof index2 === "number" ? index2 : selectedList.value.length - 1, 1);
      onValidate("");
      emit("update:modelValue", list.map((item) => item.toValue()));
    }
    function handleInputFocus(v2) {
      var _a;
      v2 && (overflowIndex.value = -1);
      if (v2 === false) {
        (_a = wrapRef.value.querySelector(`.${resolveClassName2("search-select-container")}`)) == null ? void 0 : _a.scrollTo(0, 0);
      }
      isFocus.value = v2;
    }
    function handleClickSearch(e) {
      emit("search", e);
    }
    return {
      inputRef,
      wrapRef,
      isFocus,
      copyData,
      selectedList,
      overflowIndex,
      validateStr,
      splitCode,
      onEditClick,
      onEditEnter,
      handleWrapClick,
      handleInputFocus,
      handleResize,
      handleClearAll,
      handleInputOutside,
      handleAddSelected,
      handleDeleteSelected,
      handleClickSearch,
      localConditions,
      resolveClassName: resolveClassName2,
      t: t2
    };
  },
  render() {
    var _a, _b;
    const maxHeight = `${!this.shrink || this.isFocus ? this.maxHeight : this.minHeight}px`;
    const showCondition = !!this.selectedList.length && this.selectedList.slice(-1)[0].type !== "condition";
    const menuSlots = Object.assign({}, this.$slots.menu ? {
      menu: (data2) => {
        var _a2, _b2;
        return (_b2 = (_a2 = this.$slots).menu) == null ? void 0 : _b2.call(_a2, data2);
      }
    } : {});
    return createVNode("div", {
      "class": this.resolveClassName("search-select"),
      "ref": "wrapRef"
    }, [createVNode("div", {
      "class": {
        [this.resolveClassName("search-select-container")]: true,
        "is-focus": this.isFocus
      },
      "onClick": this.handleWrapClick
    }, [createVNode("div", {
      "class": "search-prefix"
    }, [(_b = (_a = this.$slots).prepend) == null ? void 0 : _b.call(_a)]), createVNode("div", {
      "class": "search-container",
      "style": {
        maxHeight
      }
    }, [createVNode(SearchSelected, {
      "data": this.copyData,
      "conditions": this.localConditions,
      "selectedList": this.selectedList,
      "overflowIndex": this.overflowIndex,
      "getMenuList": this.getMenuList,
      "validateValues": this.validateValues,
      "valueBehavior": this.valueBehavior,
      "onDelete": this.handleDeleteSelected
    }, __spreadValues({}, menuSlots)), createVNode("div", {
      "class": "search-container-input"
    }, [createVNode(SearchSelectInput, {
      "ref": "inputRef",
      "data": this.copyData,
      "showInputBefore": !this.selectedList.length,
      "showCondition": showCondition,
      "conditions": this.localConditions,
      "placeholder": this.placeholder || this.t.pleaseSelect,
      "clickOutside": this.handleInputOutside,
      "getMenuList": this.getMenuList,
      "validateValues": this.validateValues,
      "valueBehavior": this.valueBehavior,
      "onAdd": this.handleAddSelected,
      "onDelete": this.handleDeleteSelected,
      "onFocus": this.handleInputFocus
    }, __spreadValues({}, menuSlots))])]), createVNode("div", {
      "class": "search-nextfix"
    }, [this.clearable && !!this.selectedList.length && createVNode(close$1, {
      "class": "search-clear",
      "onClick": this.handleClearAll
    }, null), this.$slots.append ? this.$slots.append() : createVNode(search, {
      "onClick": this.handleClickSearch,
      "class": `search-nextfix-icon ${this.isFocus ? "is-focus" : ""}`
    }, null)])]), !!this.validateStr.length && createVNode("div", {
      "class": this.resolveClassName("search-select-tips")
    }, [this.$slots.validate ? this.$slots.validate() : createVNode(Fragment, null, [createVNode(exclamationCircleShape, {
      "class": "select-tips"
    }, null), this.validateStr || ""])])]);
  }
});
const BkSearchSelect = withInstall(Component$1);
function triggerType() {
  return j("trigger", {}).def("hover");
}
const PopConfirmProps = {
  trigger: triggerType(),
  title: PropTypes.string.def(""),
  content: PropTypes.string.def(""),
  confirmText: PropTypes.string.def(""),
  cancelText: PropTypes.string.def(""),
  placement: PropTypes.oneOfType([placementType$1().def(PlacementEnum.TOP), PropTypes.string]).def(PlacementEnum.TOP),
  theme: PropTypes.string.def("light "),
  icon: PropTypes.string.def(""),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).def("auto")
};
var Component = defineComponent({
  name: "PopConfirm",
  components: {
    BkPopover,
    BkButton
  },
  props: PopConfirmProps,
  emits: ["confirm", "cancel"],
  setup(props2, {
    emit,
    slots
  }) {
    const visible = ref(false);
    const t2 = useLocale("popConfirm");
    function ensure(e) {
      visible.value = false;
      emit("confirm");
      e.stopPropagation();
    }
    function cancel(e) {
      visible.value = false;
      emit("cancel");
      e.stopPropagation();
    }
    function renderIcon() {
      if (typeof slots.icon === "function") {
        return slots.icon();
      }
      return props2.icon;
    }
    const icon = renderIcon();
    return () => createVNode(BkPopover, {
      "isShow": visible.value,
      "trigger": props2.trigger,
      "theme": props2.theme,
      "width": props2.width,
      "onAfterShow": () => visible.value = true,
      "extCls": "lesscode-bk-pop-confirm-box"
    }, {
      default: () => slots.default(),
      content: () => createVNode("div", {
        "class": "lesscode-bk-pop-confirm"
      }, [typeof slots.content === "function" ? slots.content() : createVNode(Fragment, null, [props2.title ? createVNode("div", {
        "class": "lesscode-bk-pop-confirm-title"
      }, [icon ? createVNode("span", {
        "class": "lesscode-bk-pop-confirm-icon"
      }, [icon]) : "", createVNode("span", null, [props2.title])]) : "", createVNode("div", {
        "class": "lesscode-bk-pop-confirm-content"
      }, [!props2.title ? icon : "", props2.content])]), createVNode("div", {
        "class": "lesscode-bk-pop-confirm-footer"
      }, [createVNode(BkButton, {
        "onClick": ensure,
        "size": "small",
        "theme": "primary"
      }, {
        default: () => [t2.value.ok]
      }), createVNode(BkButton, {
        "onClick": cancel,
        "size": "small"
      }, {
        default: () => [t2.value.cancel]
      })])])
    });
  }
});
const BKPopConfirm = withInstall(Component);
var components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alert: BkAlert,
  AnimateNumber: BkAnimateNumber,
  Affix: BkAffix,
  Backtop: BkBacktop,
  Badge: BkBadge,
  Breadcrumb: BkBreadcrumb,
  Button: BkButton,
  Card: BkCard,
  Checkbox: BkCheckbox,
  Collapse: BkCollapse,
  Dialog: BkDialog,
  Exception: BkException,
  FixedNavbar: BkFixedNavbar,
  Input: BkInput,
  Link: BkLink,
  Loading: BkLoading,
  Modal: BkModal,
  Popover: BkPopover,
  Popover2: BkPopover2,
  Progress: BkProgress,
  Radio: BkRadio,
  Rate: BkRate,
  Swiper: BkSwiper,
  Select: BkSelect,
  Sideslider: BkSideslider,
  Steps: BkSteps,
  Switcher: BkSwitcher,
  Table: BkTable,
  TableColumn: BkTableColumn,
  Tag: BkTag,
  TagInput,
  Divider: BkDivider,
  Tab: BkTab,
  Message,
  InfoBox: BkInfoBox,
  Notify,
  Menu: BkMenu,
  Navigation,
  DatePicker: BkDatePicker,
  Transfer,
  Tree: BkTree,
  VirtualRender: BkVirtualRender,
  Form: BkForm,
  Pagination: BkPagination,
  Container: BkContainer,
  containerProps: BkContainer,
  Dropdown: BkDropdown,
  Cascader: BkCascader,
  Slider,
  ResizeLayout: BkResizeLayout,
  TimeLine: BkTimeline,
  Process: BkProcess,
  Upload,
  CodeDiff: BkCodeDiff,
  ColorPicker: BkColorPicker,
  TimePicker: BkTimePicker,
  SearchSelect: BkSearchSelect,
  OverflowTitle: BkOverflowTitle,
  $bkPopover: createPopoverComponent,
  ConfigProvider: BkConfigProvider,
  PopConfirm: BKPopConfirm
}, Symbol.toStringTag, { value: "Module" }));
const createInstall = (prefix = "Bk") => (app, options) => {
  const pre = app.config.globalProperties.bkUIPrefix || prefix;
  Object.keys(components).forEach((key2) => {
    const component = components[key2];
    if ("install" in component) {
      app.use(component, { prefix: pre });
    } else {
      app.component(pre + key2, components[key2]);
    }
  });
  if (options) {
    provideGlobalConfig(options);
  }
};
var preset = {
  createInstall,
  install: createInstall(),
  version: "0.0.1"
};
export { createPopoverComponent as $bkPopover, BkAffix as Affix, BkAlert as Alert, BkAnimateNumber as AnimateNumber, BkBacktop as Backtop, BkBadge as Badge, BkBreadcrumb as Breadcrumb, BkButton as Button, BkCard as Card, BkCascader as Cascader, BkCheckbox as Checkbox, BkCodeDiff as CodeDiff, BkCollapse as Collapse, BkColorPicker as ColorPicker, BkConfigProvider as ConfigProvider, BkContainer as Container, BkDatePicker as DatePicker, BkDialog as Dialog, BkDivider as Divider, BkDropdown as Dropdown, BkException as Exception, BkFixedNavbar as FixedNavbar, BkForm as Form, BkInfoBox as InfoBox, BkInput as Input, BkLink as Link, BkLoading as Loading, BkMenu as Menu, Message, BkModal as Modal, Navigation, Notify, BkOverflowTitle as OverflowTitle, BkPagination as Pagination, BKPopConfirm as PopConfirm, BkPopover as Popover, BkPopover2 as Popover2, BkProcess as Process, BkProgress as Progress, BkRadio as Radio, BkRate as Rate, BkResizeLayout as ResizeLayout, BkSearchSelect as SearchSelect, BkSelect as Select, BkSideslider as Sideslider, Slider, BkSteps as Steps, BkSwiper as Swiper, BkSwitcher as Switcher, BkTab as Tab, BkTable as Table, BkTableColumn as TableColumn, BkTag as Tag, TagInput, BkTimeline as TimeLine, BkTimePicker as TimePicker, Transfer, BkTree as Tree, Upload, BkVirtualRender as VirtualRender, ellipsis as bkEllipsis, createInstance as bkEllipsisInstance, tooltips as bkTooltips, ClickOutside as clickoutside, BkContainer as containerProps, preset as default, mousewheel, overflowTitle, provideGlobalConfig, setPrefixVariable, useGlobalConfig, useLocale, usePrefix };
